// This file is generated by the Taichi Amalgamator
// DO NOT EDIT BY HAND, unless you know that you are doing.
#define TC_INCLUDED
#define TC_AMALGAMATED
#define TC_ISE_NONE
/*******************************************************************************
    copyright (c) the taichi authors (2016- ). all rights reserved.
    the use of this software is governed by the license file.
*******************************************************************************/


#include <cstring>
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstddef>
#include <cstdint>
#include <utility>
#include <type_traits>
#include <cstdint>
#include <algorithm>
#include <memory>
#include <csignal>
#include <vector>


//******************************************************************************
//                                 System State
//******************************************************************************


// Reference:
// https://blog.kowalczyk.info/article/j/guide-to-predefined-macros-in-c-compilers-gcc-clang-msvc-etc..html

// Platforms

// Windows
#if defined(_WIN64)
#define TC_PLATFORM_WINDOWS
#endif

#if defined(_WIN32) && !defined(_WIN64)
static_assert(false, "32-bit Windows systems are not supported")
#endif

// Linux
#if defined(__linux__)
#define TC_PLATFORM_LINUX
#endif

// OSX
#if defined(__APPLE__)
#define TC_PLATFORM_OSX
#endif

#if (defined(TC_PLATFORM_LINUX) || defined(TC_PLATFORM_OSX))
#define TC_PLATFORM_UNIX
#endif

// Compilers

// MSVC
#if defined(_MSC_VER)
#define TC_COMPILER_MSVC
#endif

// MINGW
#if defined(__MINGW64__)
#define TC_COMPILER_MINGW
#endif

// gcc
#if defined(__GNUC__)
#define TC_COMPILER__GCC
#endif

// clang
#if defined(__clang__)
#define TC_COMPILER_CLANG
#endif

#if defined(TC_COMPILER_MSVC)
#define TC_ALIGNED(x) __declspec(align(x))
#else
#define TC_ALIGNED(x) __attribute__((aligned(x)))
#endif

// Do not disable assert...
#ifdef NDEBUG
#undef NDEBUG
#endif

#ifdef _WIN64
#define __FILENAME__ \
  (strrchr(__FILE__, '\\') ? strrchr(__FILE__, '\\') + 1 : __FILE__)
#pragma warning(push)
#pragma warning(disable : 4005)
#include <windows.h>
#pragma warning(pop)
#include <intrin.h>
#define TC_EXPORT __declspec(dllexport)
#else
#define __FILENAME__ \
  (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
#define TC_EXPORT
#endif
#define TC_P(x) \
  { TC_DEBUG("{}", taichi::TextSerializer::serialize(#x, (x))); }

#ifndef _WIN64
#define sscanf_s sscanf
#define sprintf_s sprintf
#endif

#undef assert
#ifdef _WIN64
#ifndef TC_PASS_EXCEPTION_TO_PYTHON
// For Visual Studio debugging...
#define DEBUG_TRIGGER __debugbreak()
#else
#define DEBUG_TRIGGER
#endif
#else
#define DEBUG_TRIGGER
#endif

#define assert_info(x, info)               \
  {                                        \
    bool ___ret___ = static_cast<bool>(x); \
    if (!___ret___) {                      \
      TC_ERROR(info);                      \
    }                                      \
  }

#define TC_STATIC_ASSERT(x) static_assert((x), #x);
#define TC_ASSERT(x) TC_ASSERT_INFO((x), #x)
#define TC_ASSERT_INFO assert_info
// TODO: this should be part of logging
#define TC_NOT_IMPLEMENTED TC_ERROR("Not Implemented.");

#define TC_NAMESPACE_BEGIN namespace taichi {
#define TC_NAMESPACE_END }

TC_EXPORT void taichi_raise_assertion_failure_in_python(const char *msg);


TC_NAMESPACE_BEGIN

//******************************************************************************
//                                 System State
//******************************************************************************

class CoreState {
 public:
  bool python_imported = false;
  bool trigger_gdb_when_crash = false;

  static CoreState &get_instance();

  static void set_python_imported(bool val) {
    get_instance().python_imported = val;
  }

  static void set_trigger_gdb_when_crash(bool val) {
    get_instance().trigger_gdb_when_crash = val;
  }
};

//******************************************************************************
//                                 Types
//******************************************************************************

using uchar = unsigned char;

using int8 = int8_t;
using uint8 = uint8_t;

using int16 = int16_t;
using uint16 = uint16_t;

using int32 = int32_t;
using uint32 = uint32_t;
using uint = unsigned int;

using int64 = int64_t;
using uint64 = uint64_t;

#ifdef _WIN64
#define TC_FORCE_INLINE __forceinline
#else
#define TC_FORCE_INLINE inline __attribute__((always_inline))
#endif

using float32 = float;
using float64 = double;

#ifdef TC_USE_DOUBLE
using real = float64;
#else
using real = float32;
#endif

// Float literal for both float32/64
// (Learned from https://github.com/hi2p-perim/lightmetrica-v2)
real constexpr operator"" _f(long double v) {
  return real(v);
}
real constexpr operator"" _f(unsigned long long v) {
  return real(v);
}

float32 constexpr operator"" _f32(long double v) {
  return float32(v);
}
float32 constexpr operator"" _f32(unsigned long long v) {
  return float32(v);
}

float32 constexpr operator"" _fs(long double v) {
  return float32(v);
}
float32 constexpr operator"" _fs(unsigned long long v) {
  return float32(v);
}

float64 constexpr operator"" _f64(long double v) {
  return float64(v);
}
float64 constexpr operator"" _f64(unsigned long long v) {
  return float64(v);
}

float64 constexpr operator"" _fd(long double v) {
  return float64(v);
}
float64 constexpr operator"" _fd(unsigned long long v) {
  return float64(v);
}

TC_EXPORT void print_traceback();

TC_NAMESPACE_END
//******************************************************************************
//                           Meta-programming
//******************************************************************************

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <cstring>
#include <string>
#include <map>
#include <functional>
#include <memory>
#include <iostream>

namespace taichi {

namespace meta {
template <template <int> class F, int bgn, int end, typename... Args>
struct RepeatFunctionHelper {
  TC_FORCE_INLINE static void run(Args &&... args) {
    F<bgn>::run(args...);
    RepeatFunctionHelper<F, bgn + 1, end, Args...>::run(
        std::forward<Args>(args)...);
  }
};

template <template <int> class F, int bgn, typename... Args>
struct RepeatFunctionHelper<F, bgn, bgn, Args...> {
  TC_FORCE_INLINE static void run(Args &&... args) {
    return;
  }
};

template <template <int> class F, int bgn, int end, typename... Args>
TC_FORCE_INLINE void repeat_function(Args &&... args) {
  RepeatFunctionHelper<F, bgn, end, Args...>::run(std::forward<Args>(args)...);
}
}

using meta::repeat_function;

template <typename option, typename... Args>
struct type_switch {
  using type = typename std::conditional<
      std::is_same<typename option::first_type, std::true_type>::value,
      typename option::second_type,
      typename type_switch<Args...>::type>::type;
};

template <typename option>
struct type_switch<option> {
  static_assert(
      std::is_same<typename option::first_type, std::true_type>::value,
      "None of the options in type_switch works.");
  using type = typename option::second_type;
};

template <typename... Args>
using type_switch_t = typename type_switch<Args...>::type;

namespace STATIC_IF {
// reference: https://github.com/wichtounet/cpp_utils

struct identity {
  template <typename T>
  T operator()(T &&x) const {
    return std::forward<T>(x);
  }
};

template <bool Cond>
struct statement {
  template <typename F>
  void then(const F &f) {
    f(identity());
  }

  template <typename F>
  void else_(const F &) {
  }
};

template <>
struct statement<false> {
  template <typename F>
  void then(const F &) {
  }

  template <typename F>
  void else_(const F &f) {
    f(identity());
  }
};

template <bool Cond, typename F>
inline statement<Cond> static_if(F const &f) {
  statement<Cond> if_;
  if_.then(f);
  return if_;
}
}

using STATIC_IF::static_if;

#define TC_STATIC_IF(x) taichi::static_if<(x)>([&](const auto& id) -> void {
#define TC_STATIC_ELSE \
  }).else_([&](const auto &id) -> void {
#define TC_STATIC_END_IF \
  });

// After we switch to C++17, we should use
// (Note the the behaviour of 'return' is still different.)

/*
#define TC_STATIC_IF(x) if constexpr(x) {
#define TC_STATIC_ELSE \
    } else {
#define TC_STATIC_END_IF \
    }
*/

template <typename T, typename G>
struct copy_refcv {
  TC_STATIC_ASSERT(
      (std::is_same<G, std::remove_cv_t<std::remove_reference_t<G>>>::value));
  static constexpr bool has_lvalue_ref = std::is_lvalue_reference<T>::value;
  static constexpr bool has_rvalue_ref = std::is_rvalue_reference<T>::value;
  static constexpr bool has_const =
      std::is_const<std::remove_reference_t<T>>::value;
  static constexpr bool has_volatile =
      std::is_volatile<std::remove_reference_t<T>>::value;
  using G1 = std::conditional_t<has_const, const G, G>;
  using G2 = std::conditional_t<has_volatile, volatile G1, G1>;
  using G3 = std::conditional_t<has_lvalue_ref, G2 &, G2>;
  using type = std::conditional_t<has_rvalue_ref, G3 &&, G3>;
};

template <typename T, typename G>
using copy_refcv_t = typename copy_refcv<T, G>::type;

TC_STATIC_ASSERT((std::is_same<const volatile int, volatile const int>::value));
TC_STATIC_ASSERT(
    (std::is_same<int,
                  std::remove_volatile_t<
                      std::remove_const_t<const volatile int>>>::value));
TC_STATIC_ASSERT(
    (std::is_same<int,
                  std::remove_const_t<
                      std::remove_volatile_t<const volatile int>>>::value));
TC_STATIC_ASSERT((std::is_same<int &, std::add_const_t<int &>>::value));
TC_STATIC_ASSERT((std::is_same<copy_refcv_t<int, real>, real>::value));
TC_STATIC_ASSERT((std::is_same<copy_refcv_t<int &, real>, real &>::value));
TC_STATIC_ASSERT((copy_refcv<const int &, real>::has_lvalue_ref));
TC_STATIC_ASSERT(
    (std::is_same<copy_refcv<const int &, real>::G2, const real>::value));
TC_STATIC_ASSERT(
    (std::is_same<copy_refcv_t<const int &, real>, const real &>::value));
TC_STATIC_ASSERT((std::is_same<copy_refcv_t<const volatile int &, real>,
                               const volatile real &>::value));

// clang-format off
#define TC_REPEAT27(F) \
  F(0);                \
  F(1);                \
  F(2);                \
  F(3);                \
  F(4);                \
  F(5);                \
  F(6);                \
  F(7);                \
  F(8);                \
  F(9);                \
  F(10);               \
  F(11);               \
  F(12);               \
  F(13);               \
  F(14);               \
  F(15);               \
  F(16);               \
  F(17);               \
  F(18);               \
  F(19);               \
  F(20);               \
  F(21);               \
  F(22);               \
  F(23);               \
  F(24);               \
  F(25);               \
  F(26);

#define TC_LIST27(F)   \
  F(0),             \
  F(1),             \
  F(2),             \
  F(3),             \
  F(4),             \
  F(5),             \
  F(6),             \
  F(7),             \
  F(8),             \
  F(9),             \
  F(10),            \
  F(11),            \
  F(12),            \
  F(13),            \
  F(14),            \
  F(15),            \
  F(16),            \
  F(17),            \
  F(18),            \
  F(19),            \
  F(20),            \
  F(21),            \
  F(22),            \
  F(23),            \
  F(24),            \
  F(25),            \
  F(26)
// clang-format on
}

//******************************************************************************
//                               Logging
//******************************************************************************
//
// Copyright(c) 2016 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


//
// Include a bundled header-only copy of fmtlib or an external one.
// By default spdlog include its own copy.
//

#if !defined(SPDLOG_FMT_EXTERNAL)

#ifndef FMT_HEADER_ONLY
#define FMT_HEADER_ONLY
#endif
#ifndef FMT_USE_WINDOWS_H
#define FMT_USE_WINDOWS_H 0
#endif
/*
 Formatting library for C++

 Copyright (c) 2012 - 2016, Victor Zverovich
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FMT_FORMAT_H_
#define FMT_FORMAT_H_

#include <cassert>
#include <clocale>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <limits>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>
#include <utility>  // for std::pair

// The fmt library version in the form major * 10000 + minor * 100 + patch.
#define FMT_VERSION 40000

#ifdef _SECURE_SCL
# define FMT_SECURE_SCL _SECURE_SCL
#else
# define FMT_SECURE_SCL 0
#endif

#if FMT_SECURE_SCL
# include <iterator>
#endif

#ifdef _MSC_VER
# define FMT_MSC_VER _MSC_VER
#else
# define FMT_MSC_VER 0
#endif

#if FMT_MSC_VER && FMT_MSC_VER <= 1500
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
typedef __int64          intmax_t;
#else
#include <stdint.h>
#endif

#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)
# ifdef FMT_EXPORT
#  define FMT_API __declspec(dllexport)
# elif defined(FMT_SHARED)
#  define FMT_API __declspec(dllimport)
# endif
#endif
#ifndef FMT_API
# define FMT_API
#endif

#ifdef __GNUC__
# define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
# define FMT_GCC_EXTENSION __extension__
# if FMT_GCC_VERSION >= 406
#  pragma GCC diagnostic push
// Disable the warning about "long long" which is sometimes reported even
// when using __extension__.
#  pragma GCC diagnostic ignored "-Wlong-long"
// Disable the warning about declaration shadowing because it affects too
// many valid cases.
#  pragma GCC diagnostic ignored "-Wshadow"
// Disable the warning about implicit conversions that may change the sign of
// an integer; silencing it otherwise would require many explicit casts.
#  pragma GCC diagnostic ignored "-Wsign-conversion"
# endif
# if __cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__
#  define FMT_HAS_GXX_CXX11 1
# endif
#else
# define FMT_GCC_EXTENSION
#endif

#if defined(__INTEL_COMPILER)
# define FMT_ICC_VERSION __INTEL_COMPILER
#elif defined(__ICL)
# define FMT_ICC_VERSION __ICL
#endif

#if defined(__clang__) && !defined(FMT_ICC_VERSION)
# define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdocumentation-unknown-command"
# pragma clang diagnostic ignored "-Wpadded"
#endif

#ifdef __GNUC_LIBSTD__
# define FMT_GNUC_LIBSTD_VERSION (__GNUC_LIBSTD__ * 100 + __GNUC_LIBSTD_MINOR__)
#endif

#ifdef __has_feature
# define FMT_HAS_FEATURE(x) __has_feature(x)
#else
# define FMT_HAS_FEATURE(x) 0
#endif

#ifdef __has_builtin
# define FMT_HAS_BUILTIN(x) __has_builtin(x)
#else
# define FMT_HAS_BUILTIN(x) 0
#endif

#ifdef __has_cpp_attribute
# define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
#else
# define FMT_HAS_CPP_ATTRIBUTE(x) 0
#endif

#ifndef FMT_USE_VARIADIC_TEMPLATES
// Variadic templates are available in GCC since version 4.4
// (http://gcc.gnu.org/projects/cxx0x.html) and in Visual C++
// since version 2013.
# define FMT_USE_VARIADIC_TEMPLATES \
   (FMT_HAS_FEATURE(cxx_variadic_templates) || \
       (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800)
#endif

#ifndef FMT_USE_RVALUE_REFERENCES
// Don't use rvalue references when compiling with clang and an old libstdc++
// as the latter doesn't provide std::move.
# if defined(FMT_GNUC_LIBSTD_VERSION) && FMT_GNUC_LIBSTD_VERSION <= 402
#  define FMT_USE_RVALUE_REFERENCES 0
# else
#  define FMT_USE_RVALUE_REFERENCES \
    (FMT_HAS_FEATURE(cxx_rvalue_references) || \
        (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1600)
# endif
#endif

// Check if exceptions are disabled.
#if defined(__GNUC__) && !defined(__EXCEPTIONS)
# define FMT_EXCEPTIONS 0
#endif
#if FMT_MSC_VER && !_HAS_EXCEPTIONS
# define FMT_EXCEPTIONS 0
#endif
#ifndef FMT_EXCEPTIONS
# define FMT_EXCEPTIONS 1
#endif

#ifndef FMT_THROW
# if FMT_EXCEPTIONS
#  define FMT_THROW(x) throw x
# else
#  define FMT_THROW(x) assert(false)
# endif
#endif

// Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).
#ifndef FMT_USE_NOEXCEPT
# define FMT_USE_NOEXCEPT 0
#endif

#if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \
    (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \
    FMT_MSC_VER >= 1900
# define FMT_DETECTED_NOEXCEPT noexcept
#else
# define FMT_DETECTED_NOEXCEPT throw()
#endif

#ifndef FMT_NOEXCEPT
# if FMT_EXCEPTIONS
#  define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT
# else
#  define FMT_NOEXCEPT
# endif
#endif

// This is needed because GCC still uses throw() in its headers when exceptions
// are disabled.
#if FMT_GCC_VERSION
# define FMT_DTOR_NOEXCEPT FMT_DETECTED_NOEXCEPT
#else
# define FMT_DTOR_NOEXCEPT FMT_NOEXCEPT
#endif

#ifndef FMT_OVERRIDE
# if (defined(FMT_USE_OVERRIDE) && FMT_USE_OVERRIDE) || FMT_HAS_FEATURE(cxx_override) || \
   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \
   FMT_MSC_VER >= 1900
#  define FMT_OVERRIDE override
# else
#  define FMT_OVERRIDE
# endif
#endif

#ifndef FMT_NULL
# if FMT_HAS_FEATURE(cxx_nullptr) || \
   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \
   FMT_MSC_VER >= 1600
#  define FMT_NULL nullptr
# else
#  define FMT_NULL NULL
# endif
#endif

// A macro to disallow the copy constructor and operator= functions
// This should be used in the private: declarations for a class
#ifndef FMT_USE_DELETED_FUNCTIONS
# define FMT_USE_DELETED_FUNCTIONS 0
#endif

#if FMT_USE_DELETED_FUNCTIONS || FMT_HAS_FEATURE(cxx_deleted_functions) || \
  (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800
# define FMT_DELETED_OR_UNDEFINED  = delete
# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \
    TypeName(const TypeName&) = delete; \
    TypeName& operator=(const TypeName&) = delete
#else
# define FMT_DELETED_OR_UNDEFINED
# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \
    TypeName(const TypeName&); \
    TypeName& operator=(const TypeName&)
#endif

#ifndef FMT_USE_DEFAULTED_FUNCTIONS
# define FMT_USE_DEFAULTED_FUNCTIONS 0
#endif

#ifndef FMT_DEFAULTED_COPY_CTOR
# if FMT_USE_DEFAULTED_FUNCTIONS || FMT_HAS_FEATURE(cxx_defaulted_functions) || \
   (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800
#  define FMT_DEFAULTED_COPY_CTOR(TypeName) \
    TypeName(const TypeName&) = default;
# else
#  define FMT_DEFAULTED_COPY_CTOR(TypeName)
# endif
#endif

#ifndef FMT_USE_USER_DEFINED_LITERALS
// All compilers which support UDLs also support variadic templates. This
// makes the fmt::literals implementation easier. However, an explicit check
// for variadic templates is added here just in case.
// For Intel's compiler both it and the system gcc/msc must support UDLs.
# define FMT_USE_USER_DEFINED_LITERALS \
   FMT_USE_VARIADIC_TEMPLATES && FMT_USE_RVALUE_REFERENCES && \
   (FMT_HAS_FEATURE(cxx_user_literals) || \
     (FMT_GCC_VERSION >= 407 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900) && \
   (!defined(FMT_ICC_VERSION) || FMT_ICC_VERSION >= 1500)
#endif

#ifndef FMT_USE_EXTERN_TEMPLATES
# define FMT_USE_EXTERN_TEMPLATES \
    (FMT_CLANG_VERSION >= 209 || (FMT_GCC_VERSION >= 303 && FMT_HAS_GXX_CXX11))
#endif

#ifdef FMT_HEADER_ONLY
// If header only do not use extern templates.
# undef FMT_USE_EXTERN_TEMPLATES
# define FMT_USE_EXTERN_TEMPLATES 0
#endif

#ifndef FMT_ASSERT
# define FMT_ASSERT(condition, message) assert((condition) && message)
#endif

// __builtin_clz is broken in clang with Microsoft CodeGen:
// https://github.com/fmtlib/fmt/issues/519
#ifndef _MSC_VER
# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clz)
#  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
# endif

# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clzll)
#  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
# endif
#endif

// Some compilers masquerade as both MSVC and GCC-likes or
// otherwise support __builtin_clz and __builtin_clzll, so
// only define FMT_BUILTIN_CLZ using the MSVC intrinsics
// if the clz and clzll builtins are not available.
#if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(_MANAGED)
# include <intrin.h>  // _BitScanReverse, _BitScanReverse64

namespace fmt {
namespace internal {
# pragma intrinsic(_BitScanReverse)
inline uint32_t clz(uint32_t x) {
  unsigned long r = 0;
  _BitScanReverse(&r, x);

  assert(x != 0);
  // Static analysis complains about using uninitialized data
  // "r", but the only way that can happen is if "x" is 0,
  // which the callers guarantee to not happen.
# pragma warning(suppress: 6102)
  return 31 - r;
}
# define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)

# ifdef _WIN64
#  pragma intrinsic(_BitScanReverse64)
# endif

inline uint32_t clzll(uint64_t x) {
  unsigned long r = 0;
# ifdef _WIN64
  _BitScanReverse64(&r, x);
# else
  // Scan the high 32 bits.
  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))
    return 63 - (r + 32);

  // Scan the low 32 bits.
  _BitScanReverse(&r, static_cast<uint32_t>(x));
# endif

  assert(x != 0);
  // Static analysis complains about using uninitialized data
  // "r", but the only way that can happen is if "x" is 0,
  // which the callers guarantee to not happen.
# pragma warning(suppress: 6102)
  return 63 - r;
}
# define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)
}
}
#endif

namespace fmt {
namespace internal {
struct DummyInt {
  int data[2];
  operator int() const { return 0; }
};
typedef std::numeric_limits<fmt::internal::DummyInt> FPUtil;

// Dummy implementations of system functions such as signbit and ecvt called
// if the latter are not available.
inline DummyInt signbit(...) { return DummyInt(); }
inline DummyInt _ecvt_s(...) { return DummyInt(); }
inline DummyInt isinf(...) { return DummyInt(); }
inline DummyInt _finite(...) { return DummyInt(); }
inline DummyInt isnan(...) { return DummyInt(); }
inline DummyInt _isnan(...) { return DummyInt(); }

// A helper function to suppress bogus "conditional expression is constant"
// warnings.
template <typename T>
inline T const_check(T value) { return value; }
}
}  // namespace fmt

namespace std {
// Standard permits specialization of std::numeric_limits. This specialization
// is used to resolve ambiguity between isinf and std::isinf in glibc:
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48891
// and the same for isnan and signbit.
template <>
class numeric_limits<fmt::internal::DummyInt> :
    public std::numeric_limits<int> {
 public:
  // Portable version of isinf.
  template <typename T>
  static bool isinfinity(T x) {
    using namespace fmt::internal;
    // The resolution "priority" is:
    // isinf macro > std::isinf > ::isinf > fmt::internal::isinf
    if (const_check(sizeof(isinf(x)) == sizeof(bool) ||
                    sizeof(isinf(x)) == sizeof(int))) {
      return isinf(x) != 0;
    }
    return !_finite(static_cast<double>(x));
  }

  // Portable version of isnan.
  template <typename T>
  static bool isnotanumber(T x) {
    using namespace fmt::internal;
    if (const_check(sizeof(isnan(x)) == sizeof(bool) ||
                    sizeof(isnan(x)) == sizeof(int))) {
      return isnan(x) != 0;
    }
    return _isnan(static_cast<double>(x)) != 0;
  }

  // Portable version of signbit.
  static bool isnegative(double x) {
    using namespace fmt::internal;
    if (const_check(sizeof(signbit(x)) == sizeof(bool) ||
                    sizeof(signbit(x)) == sizeof(int))) {
      return signbit(x) != 0;
    }
    if (x < 0) return true;
    if (!isnotanumber(x)) return false;
    int dec = 0, sign = 0;
    char buffer[2];  // The buffer size must be >= 2 or _ecvt_s will fail.
    _ecvt_s(buffer, sizeof(buffer), x, 0, &dec, &sign);
    return sign != 0;
  }
};
}  // namespace std

namespace fmt {

// Fix the warning about long long on older versions of GCC
// that don't support the diagnostic pragma.
FMT_GCC_EXTENSION typedef long long LongLong;
FMT_GCC_EXTENSION typedef unsigned long long ULongLong;

#if FMT_USE_RVALUE_REFERENCES
using std::move;
#endif

template <typename Char>
class BasicWriter;

typedef BasicWriter<char> Writer;
typedef BasicWriter<wchar_t> WWriter;

template <typename Char>
class ArgFormatter;

struct FormatSpec;

template <typename Impl, typename Char, typename Spec = fmt::FormatSpec>
class BasicPrintfArgFormatter;

template <typename CharType,
          typename ArgFormatter = fmt::ArgFormatter<CharType> >
class BasicFormatter;

/**
  \rst
  A string reference. It can be constructed from a C string or
  ``std::basic_string``.

  You can use one of the following typedefs for common character types:

  +------------+-------------------------+
  | Type       | Definition              |
  +============+=========================+
  | StringRef  | BasicStringRef<char>    |
  +------------+-------------------------+
  | WStringRef | BasicStringRef<wchar_t> |
  +------------+-------------------------+

  This class is most useful as a parameter type to allow passing
  different types of strings to a function, for example::

    template <typename... Args>
    std::string format(StringRef format_str, const Args & ... args);

    format("{}", 42);
    format(std::string("{}"), 42);
  \endrst
 */
template <typename Char>
class BasicStringRef {
 private:
  const Char *data_;
  std::size_t size_;

 public:
  /** Constructs a string reference object from a C string and a size. */
  BasicStringRef(const Char *s, std::size_t size) : data_(s), size_(size) {}

  /**
    \rst
    Constructs a string reference object from a C string computing
    the size with ``std::char_traits<Char>::length``.
    \endrst
   */
  BasicStringRef(const Char *s)
    : data_(s), size_(std::char_traits<Char>::length(s)) {}

  /**
    \rst
    Constructs a string reference from a ``std::basic_string`` object.
    \endrst
   */
  template <typename Allocator>
  BasicStringRef(
      const std::basic_string<Char, std::char_traits<Char>, Allocator> &s)
  : data_(s.c_str()), size_(s.size()) {}

  /**
    \rst
    Converts a string reference to an ``std::string`` object.
    \endrst
   */
  std::basic_string<Char> to_string() const {
    return std::basic_string<Char>(data_, size_);
  }

  /** Returns a pointer to the string data. */
  const Char *data() const { return data_; }

  /** Returns the string size. */
  std::size_t size() const { return size_; }

  // Lexicographically compare this string reference to other.
  int compare(BasicStringRef other) const {
    std::size_t size = size_ < other.size_ ? size_ : other.size_;
    int result = std::char_traits<Char>::compare(data_, other.data_, size);
    if (result == 0)
      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);
    return result;
  }

  friend bool operator==(BasicStringRef lhs, BasicStringRef rhs) {
    return lhs.compare(rhs) == 0;
  }
  friend bool operator!=(BasicStringRef lhs, BasicStringRef rhs) {
    return lhs.compare(rhs) != 0;
  }
  friend bool operator<(BasicStringRef lhs, BasicStringRef rhs) {
    return lhs.compare(rhs) < 0;
  }
  friend bool operator<=(BasicStringRef lhs, BasicStringRef rhs) {
    return lhs.compare(rhs) <= 0;
  }
  friend bool operator>(BasicStringRef lhs, BasicStringRef rhs) {
    return lhs.compare(rhs) > 0;
  }
  friend bool operator>=(BasicStringRef lhs, BasicStringRef rhs) {
    return lhs.compare(rhs) >= 0;
  }
};

typedef BasicStringRef<char> StringRef;
typedef BasicStringRef<wchar_t> WStringRef;

/**
  \rst
  A reference to a null terminated string. It can be constructed from a C
  string or ``std::basic_string``.

  You can use one of the following typedefs for common character types:

  +-------------+--------------------------+
  | Type        | Definition               |
  +=============+==========================+
  | CStringRef  | BasicCStringRef<char>    |
  +-------------+--------------------------+
  | WCStringRef | BasicCStringRef<wchar_t> |
  +-------------+--------------------------+

  This class is most useful as a parameter type to allow passing
  different types of strings to a function, for example::

    template <typename... Args>
    std::string format(CStringRef format_str, const Args & ... args);

    format("{}", 42);
    format(std::string("{}"), 42);
  \endrst
 */
template <typename Char>
class BasicCStringRef {
 private:
  const Char *data_;

 public:
  /** Constructs a string reference object from a C string. */
  BasicCStringRef(const Char *s) : data_(s) {}

  /**
    \rst
    Constructs a string reference from a ``std::basic_string`` object.
    \endrst
   */
  template <typename Allocator>
  BasicCStringRef(
      const std::basic_string<Char, std::char_traits<Char>, Allocator> &s)
  : data_(s.c_str()) {}

  /** Returns the pointer to a C string. */
  const Char *c_str() const { return data_; }
};

typedef BasicCStringRef<char> CStringRef;
typedef BasicCStringRef<wchar_t> WCStringRef;

/** A formatting error such as invalid format string. */
class FormatError : public std::runtime_error {
 public:
  explicit FormatError(CStringRef message)
  : std::runtime_error(message.c_str()) {}
  FormatError(const FormatError &ferr) : std::runtime_error(ferr) {}
  FMT_API ~FormatError() FMT_DTOR_NOEXCEPT;
};

namespace internal {

// MakeUnsigned<T>::Type gives an unsigned type corresponding to integer type T.
template <typename T>
struct MakeUnsigned { typedef T Type; };

#define FMT_SPECIALIZE_MAKE_UNSIGNED(T, U) \
  template <> \
  struct MakeUnsigned<T> { typedef U Type; }

FMT_SPECIALIZE_MAKE_UNSIGNED(char, unsigned char);
FMT_SPECIALIZE_MAKE_UNSIGNED(signed char, unsigned char);
FMT_SPECIALIZE_MAKE_UNSIGNED(short, unsigned short);
FMT_SPECIALIZE_MAKE_UNSIGNED(int, unsigned);
FMT_SPECIALIZE_MAKE_UNSIGNED(long, unsigned long);
FMT_SPECIALIZE_MAKE_UNSIGNED(LongLong, ULongLong);

// Casts nonnegative integer to unsigned.
template <typename Int>
inline typename MakeUnsigned<Int>::Type to_unsigned(Int value) {
  FMT_ASSERT(value >= 0, "negative value");
  return static_cast<typename MakeUnsigned<Int>::Type>(value);
}

// The number of characters to store in the MemoryBuffer object itself
// to avoid dynamic memory allocation.
enum { INLINE_BUFFER_SIZE = 500 };

#if FMT_SECURE_SCL
// Use checked iterator to avoid warnings on MSVC.
template <typename T>
inline stdext::checked_array_iterator<T*> make_ptr(T *ptr, std::size_t size) {
  return stdext::checked_array_iterator<T*>(ptr, size);
}
#else
template <typename T>
inline T *make_ptr(T *ptr, std::size_t) { return ptr; }
#endif
}  // namespace internal

/**
  \rst
  A buffer supporting a subset of ``std::vector``'s operations.
  \endrst
 */
template <typename T>
class Buffer {
 private:
  FMT_DISALLOW_COPY_AND_ASSIGN(Buffer);

 protected:
  T *ptr_;
  std::size_t size_;
  std::size_t capacity_;

  Buffer(T *ptr = FMT_NULL, std::size_t capacity = 0)
    : ptr_(ptr), size_(0), capacity_(capacity) {}

  /**
    \rst
    Increases the buffer capacity to hold at least *size* elements updating
    ``ptr_`` and ``capacity_``.
    \endrst
   */
  virtual void grow(std::size_t size) = 0;

 public:
  virtual ~Buffer() {}

  /** Returns the size of this buffer. */
  std::size_t size() const { return size_; }

  /** Returns the capacity of this buffer. */
  std::size_t capacity() const { return capacity_; }

  /**
    Resizes the buffer. If T is a POD type new elements may not be initialized.
   */
  void resize(std::size_t new_size) {
    if (new_size > capacity_)
      grow(new_size);
    size_ = new_size;
  }

  /**
    \rst
    Reserves space to store at least *capacity* elements.
    \endrst
   */
  void reserve(std::size_t capacity) {
    if (capacity > capacity_)
      grow(capacity);
  }

  void clear() FMT_NOEXCEPT { size_ = 0; }

  void push_back(const T &value) {
    if (size_ == capacity_)
      grow(size_ + 1);
    ptr_[size_++] = value;
  }

  /** Appends data to the end of the buffer. */
  template <typename U>
  void append(const U *begin, const U *end);

  T &operator[](std::size_t index) { return ptr_[index]; }
  const T &operator[](std::size_t index) const { return ptr_[index]; }
};

template <typename T>
template <typename U>
void Buffer<T>::append(const U *begin, const U *end) {
  FMT_ASSERT(end >= begin, "negative value");
  std::size_t new_size = size_ + (end - begin);
  if (new_size > capacity_)
    grow(new_size);
  std::uninitialized_copy(begin, end,
                          internal::make_ptr(ptr_, capacity_) + size_);
  size_ = new_size;
}

namespace internal {

// A memory buffer for trivially copyable/constructible types with the first
// SIZE elements stored in the object itself.
template <typename T, std::size_t SIZE, typename Allocator = std::allocator<T> >
class MemoryBuffer : private Allocator, public Buffer<T> {
 private:
  T data_[SIZE];

  // Deallocate memory allocated by the buffer.
  void deallocate() {
    if (this->ptr_ != data_) Allocator::deallocate(this->ptr_, this->capacity_);
  }

 protected:
  void grow(std::size_t size) FMT_OVERRIDE;

 public:
  explicit MemoryBuffer(const Allocator &alloc = Allocator())
      : Allocator(alloc), Buffer<T>(data_, SIZE) {}
  ~MemoryBuffer() { deallocate(); }

#if FMT_USE_RVALUE_REFERENCES
 private:
  // Move data from other to this buffer.
  void move(MemoryBuffer &other) {
    Allocator &this_alloc = *this, &other_alloc = other;
    this_alloc = std::move(other_alloc);
    this->size_ = other.size_;
    this->capacity_ = other.capacity_;
    if (other.ptr_ == other.data_) {
      this->ptr_ = data_;
      std::uninitialized_copy(other.data_, other.data_ + this->size_,
                              make_ptr(data_, this->capacity_));
    } else {
      this->ptr_ = other.ptr_;
      // Set pointer to the inline array so that delete is not called
      // when deallocating.
      other.ptr_ = other.data_;
    }
  }

 public:
  MemoryBuffer(MemoryBuffer &&other) {
    move(other);
  }

  MemoryBuffer &operator=(MemoryBuffer &&other) {
    assert(this != &other);
    deallocate();
    move(other);
    return *this;
  }
#endif

  // Returns a copy of the allocator associated with this buffer.
  Allocator get_allocator() const { return *this; }
};

template <typename T, std::size_t SIZE, typename Allocator>
void MemoryBuffer<T, SIZE, Allocator>::grow(std::size_t size) {
  std::size_t new_capacity = this->capacity_ + this->capacity_ / 2;
  if (size > new_capacity)
      new_capacity = size;
  T *new_ptr = this->allocate(new_capacity, FMT_NULL);
  // The following code doesn't throw, so the raw pointer above doesn't leak.
  std::uninitialized_copy(this->ptr_, this->ptr_ + this->size_,
                          make_ptr(new_ptr, new_capacity));
  std::size_t old_capacity = this->capacity_;
  T *old_ptr = this->ptr_;
  this->capacity_ = new_capacity;
  this->ptr_ = new_ptr;
  // deallocate may throw (at least in principle), but it doesn't matter since
  // the buffer already uses the new storage and will deallocate it in case
  // of exception.
  if (old_ptr != data_)
    Allocator::deallocate(old_ptr, old_capacity);
}

// A fixed-size buffer.
template <typename Char>
class FixedBuffer : public fmt::Buffer<Char> {
 public:
  FixedBuffer(Char *array, std::size_t size) : fmt::Buffer<Char>(array, size) {}

 protected:
  FMT_API void grow(std::size_t size) FMT_OVERRIDE;
};

template <typename Char>
class BasicCharTraits {
 public:
#if FMT_SECURE_SCL
  typedef stdext::checked_array_iterator<Char*> CharPtr;
#else
  typedef Char *CharPtr;
#endif
  static Char cast(int value) { return static_cast<Char>(value); }
};

template <typename Char>
class CharTraits;

template <>
class CharTraits<char> : public BasicCharTraits<char> {
 private:
  // Conversion from wchar_t to char is not allowed.
  static char convert(wchar_t);

 public:
  static char convert(char value) { return value; }

  // Formats a floating-point number.
  template <typename T>
  FMT_API static int format_float(char *buffer, std::size_t size,
      const char *format, unsigned width, int precision, T value);
};

#if FMT_USE_EXTERN_TEMPLATES
extern template int CharTraits<char>::format_float<double>
        (char *buffer, std::size_t size,
         const char* format, unsigned width, int precision, double value);
extern template int CharTraits<char>::format_float<long double>
        (char *buffer, std::size_t size,
         const char* format, unsigned width, int precision, long double value);
#endif

template <>
class CharTraits<wchar_t> : public BasicCharTraits<wchar_t> {
 public:
  static wchar_t convert(char value) { return value; }
  static wchar_t convert(wchar_t value) { return value; }

  template <typename T>
  FMT_API static int format_float(wchar_t *buffer, std::size_t size,
      const wchar_t *format, unsigned width, int precision, T value);
};

#if FMT_USE_EXTERN_TEMPLATES
extern template int CharTraits<wchar_t>::format_float<double>
        (wchar_t *buffer, std::size_t size,
         const wchar_t* format, unsigned width, int precision, double value);
extern template int CharTraits<wchar_t>::format_float<long double>
        (wchar_t *buffer, std::size_t size,
         const wchar_t* format, unsigned width, int precision, long double value);
#endif

// Checks if a number is negative - used to avoid warnings.
template <bool IsSigned>
struct SignChecker {
  template <typename T>
  static bool is_negative(T value) { return value < 0; }
};

template <>
struct SignChecker<false> {
  template <typename T>
  static bool is_negative(T) { return false; }
};

// Returns true if value is negative, false otherwise.
// Same as (value < 0) but doesn't produce warnings if T is an unsigned type.
template <typename T>
inline bool is_negative(T value) {
  return SignChecker<std::numeric_limits<T>::is_signed>::is_negative(value);
}

// Selects uint32_t if FitsIn32Bits is true, uint64_t otherwise.
template <bool FitsIn32Bits>
struct TypeSelector { typedef uint32_t Type; };

template <>
struct TypeSelector<false> { typedef uint64_t Type; };

template <typename T>
struct IntTraits {
  // Smallest of uint32_t and uint64_t that is large enough to represent
  // all values of T.
  typedef typename
    TypeSelector<std::numeric_limits<T>::digits <= 32>::Type MainType;
};

FMT_API void report_unknown_type(char code, const char *type);

// Static data is placed in this class template to allow header-only
// configuration.
template <typename T = void>
struct FMT_API BasicData {
  static const uint32_t POWERS_OF_10_32[];
  static const uint64_t POWERS_OF_10_64[];
  static const char DIGITS[];
};

#if FMT_USE_EXTERN_TEMPLATES
extern template struct BasicData<void>;
#endif

typedef BasicData<> Data;

#ifdef FMT_BUILTIN_CLZLL
// Returns the number of decimal digits in n. Leading zeros are not counted
// except for n == 0 in which case count_digits returns 1.
inline unsigned count_digits(uint64_t n) {
  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.
  int t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 >> 12;
  return to_unsigned(t) - (n < Data::POWERS_OF_10_64[t]) + 1;
}
#else
// Fallback version of count_digits used when __builtin_clz is not available.
inline unsigned count_digits(uint64_t n) {
  unsigned count = 1;
  for (;;) {
    // Integer division is slow so do it for a group of four digits instead
    // of for every digit. The idea comes from the talk by Alexandrescu
    // "Three Optimization Tips for C++". See speed-test for a comparison.
    if (n < 10) return count;
    if (n < 100) return count + 1;
    if (n < 1000) return count + 2;
    if (n < 10000) return count + 3;
    n /= 10000u;
    count += 4;
  }
}
#endif

#ifdef FMT_BUILTIN_CLZ
// Optional version of count_digits for better performance on 32-bit platforms.
inline unsigned count_digits(uint32_t n) {
  int t = (32 - FMT_BUILTIN_CLZ(n | 1)) * 1233 >> 12;
  return to_unsigned(t) - (n < Data::POWERS_OF_10_32[t]) + 1;
}
#endif

// A functor that doesn't add a thousands separator.
struct NoThousandsSep {
  template <typename Char>
  void operator()(Char *) {}
};

// A functor that adds a thousands separator.
class ThousandsSep {
 private:
  fmt::StringRef sep_;

  // Index of a decimal digit with the least significant digit having index 0.
  unsigned digit_index_;

 public:
  explicit ThousandsSep(fmt::StringRef sep) : sep_(sep), digit_index_(0) {}

  template <typename Char>
  void operator()(Char *&buffer) {
    if (++digit_index_ % 3 != 0)
      return;
    buffer -= sep_.size();
    std::uninitialized_copy(sep_.data(), sep_.data() + sep_.size(),
                            internal::make_ptr(buffer, sep_.size()));
  }
};

// Formats a decimal unsigned integer value writing into buffer.
// thousands_sep is a functor that is called after writing each char to
// add a thousands separator if necessary.
template <typename UInt, typename Char, typename ThousandsSep>
inline void format_decimal(Char *buffer, UInt value, unsigned num_digits,
                           ThousandsSep thousands_sep) {
  buffer += num_digits;
  while (value >= 100) {
    // Integer division is slow so do it for a group of two digits instead
    // of for every digit. The idea comes from the talk by Alexandrescu
    // "Three Optimization Tips for C++". See speed-test for a comparison.
    unsigned index = static_cast<unsigned>((value % 100) * 2);
    value /= 100;
    *--buffer = Data::DIGITS[index + 1];
    thousands_sep(buffer);
    *--buffer = Data::DIGITS[index];
    thousands_sep(buffer);
  }
  if (value < 10) {
    *--buffer = static_cast<char>('0' + value);
    return;
  }
  unsigned index = static_cast<unsigned>(value * 2);
  *--buffer = Data::DIGITS[index + 1];
  thousands_sep(buffer);
  *--buffer = Data::DIGITS[index];
}

template <typename UInt, typename Char>
inline void format_decimal(Char *buffer, UInt value, unsigned num_digits) {
  format_decimal(buffer, value, num_digits, NoThousandsSep());
  return;
}

#ifndef _WIN32
# define FMT_USE_WINDOWS_H 0
#elif !defined(FMT_USE_WINDOWS_H)
# define FMT_USE_WINDOWS_H 1
#endif

// Define FMT_USE_WINDOWS_H to 0 to disable use of windows.h.
// All the functionality that relies on it will be disabled too.
#if FMT_USE_WINDOWS_H
// A converter from UTF-8 to UTF-16.
// It is only provided for Windows since other systems support UTF-8 natively.
class UTF8ToUTF16 {
 private:
  MemoryBuffer<wchar_t, INLINE_BUFFER_SIZE> buffer_;

 public:
  FMT_API explicit UTF8ToUTF16(StringRef s);
  operator WStringRef() const { return WStringRef(&buffer_[0], size()); }
  size_t size() const { return buffer_.size() - 1; }
  const wchar_t *c_str() const { return &buffer_[0]; }
  std::wstring str() const { return std::wstring(&buffer_[0], size()); }
};

// A converter from UTF-16 to UTF-8.
// It is only provided for Windows since other systems support UTF-8 natively.
class UTF16ToUTF8 {
 private:
  MemoryBuffer<char, INLINE_BUFFER_SIZE> buffer_;

 public:
  UTF16ToUTF8() {}
  FMT_API explicit UTF16ToUTF8(WStringRef s);
  operator StringRef() const { return StringRef(&buffer_[0], size()); }
  size_t size() const { return buffer_.size() - 1; }
  const char *c_str() const { return &buffer_[0]; }
  std::string str() const { return std::string(&buffer_[0], size()); }

  // Performs conversion returning a system error code instead of
  // throwing exception on conversion error. This method may still throw
  // in case of memory allocation error.
  FMT_API int convert(WStringRef s);
};

FMT_API void format_windows_error(fmt::Writer &out, int error_code,
                                  fmt::StringRef message) FMT_NOEXCEPT;
#endif

// A formatting argument value.
struct Value {
  template <typename Char>
  struct StringValue {
    const Char *value;
    std::size_t size;
  };

  typedef void (*FormatFunc)(
      void *formatter, const void *arg, void *format_str_ptr);

  struct CustomValue {
    const void *value;
    FormatFunc format;
  };

  union {
    int int_value;
    unsigned uint_value;
    LongLong long_long_value;
    ULongLong ulong_long_value;
    double double_value;
    long double long_double_value;
    const void *pointer;
    StringValue<char> string;
    StringValue<signed char> sstring;
    StringValue<unsigned char> ustring;
    StringValue<wchar_t> wstring;
    CustomValue custom;
  };

  enum Type {
    NONE, NAMED_ARG,
    // Integer types should go first,
    INT, UINT, LONG_LONG, ULONG_LONG, BOOL, CHAR, LAST_INTEGER_TYPE = CHAR,
    // followed by floating-point types.
    DOUBLE, LONG_DOUBLE, LAST_NUMERIC_TYPE = LONG_DOUBLE,
    CSTRING, STRING, WSTRING, POINTER, CUSTOM
  };
};

// A formatting argument. It is a trivially copyable/constructible type to
// allow storage in internal::MemoryBuffer.
struct Arg : Value {
  Type type;
};

template <typename Char>
struct NamedArg;
template <typename Char, typename T>
struct NamedArgWithType;

template <typename T = void>
struct Null {};

// A helper class template to enable or disable overloads taking wide
// characters and strings in MakeValue.
template <typename T, typename Char>
struct WCharHelper {
  typedef Null<T> Supported;
  typedef T Unsupported;
};

template <typename T>
struct WCharHelper<T, wchar_t> {
  typedef T Supported;
  typedef Null<T> Unsupported;
};

typedef char Yes[1];
typedef char No[2];

template <typename T>
T &get();

// These are non-members to workaround an overload resolution bug in bcc32.
Yes &convert(fmt::ULongLong);
No &convert(...);

template<typename T, bool ENABLE_CONVERSION>
struct ConvertToIntImpl {
  enum { value = ENABLE_CONVERSION };
};

template<typename T, bool ENABLE_CONVERSION>
struct ConvertToIntImpl2 {
  enum { value = false };
};

template<typename T>
struct ConvertToIntImpl2<T, true> {
  enum {
    // Don't convert numeric types.
    value = ConvertToIntImpl<T, !std::numeric_limits<T>::is_specialized>::value
  };
};

template<typename T>
struct ConvertToInt {
  enum {
    enable_conversion = sizeof(fmt::internal::convert(get<T>())) == sizeof(Yes)
  };
  enum { value = ConvertToIntImpl2<T, enable_conversion>::value };
};

#define FMT_DISABLE_CONVERSION_TO_INT(Type) \
  template <> \
  struct ConvertToInt<Type> {  enum { value = 0 }; }

// Silence warnings about convering float to int.
FMT_DISABLE_CONVERSION_TO_INT(float);
FMT_DISABLE_CONVERSION_TO_INT(double);
FMT_DISABLE_CONVERSION_TO_INT(long double);

template<bool B, class T = void>
struct EnableIf {};

template<class T>
struct EnableIf<true, T> { typedef T type; };

template<bool B, class T, class F>
struct Conditional { typedef T type; };

template<class T, class F>
struct Conditional<false, T, F> { typedef F type; };

// For bcc32 which doesn't understand ! in template arguments.
template <bool>
struct Not { enum { value = 0 }; };

template <>
struct Not<false> { enum { value = 1 }; };

template <typename T>
struct FalseType { enum { value = 0 }; };

template <typename T, T> struct LConvCheck {
  LConvCheck(int) {}
};

// Returns the thousands separator for the current locale.
// We check if ``lconv`` contains ``thousands_sep`` because on Android
// ``lconv`` is stubbed as an empty struct.
template <typename LConv>
inline StringRef thousands_sep(
    LConv *lc, LConvCheck<char *LConv::*, &LConv::thousands_sep> = 0) {
  return lc->thousands_sep;
}

inline fmt::StringRef thousands_sep(...) { return ""; }

#define FMT_CONCAT(a, b) a##b

#if FMT_GCC_VERSION >= 303
# define FMT_UNUSED __attribute__((unused))
#else
# define FMT_UNUSED
#endif

#ifndef FMT_USE_STATIC_ASSERT
# define FMT_USE_STATIC_ASSERT 0
#endif

#if FMT_USE_STATIC_ASSERT || FMT_HAS_FEATURE(cxx_static_assert) || \
  (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1600
# define FMT_STATIC_ASSERT(cond, message) static_assert(cond, message)
#else
# define FMT_CONCAT_(a, b) FMT_CONCAT(a, b)
# define FMT_STATIC_ASSERT(cond, message) \
  typedef int FMT_CONCAT_(Assert, __LINE__)[(cond) ? 1 : -1] FMT_UNUSED
#endif

template <typename Formatter, typename Char, typename T>
void format_arg(Formatter &, const Char *, const T &) {
  FMT_STATIC_ASSERT(FalseType<T>::value,
                    "Cannot format argument. To enable the use of ostream "
                    "operator<< include fmt/ostream.h. Otherwise provide "
                    "an overload of format_arg.");
}

// Makes an Arg object from any type.
template <typename Formatter>
class MakeValue : public Arg {
 public:
  typedef typename Formatter::Char Char;

 private:
  // The following two methods are private to disallow formatting of
  // arbitrary pointers. If you want to output a pointer cast it to
  // "void *" or "const void *". In particular, this forbids formatting
  // of "[const] volatile char *" which is printed as bool by iostreams.
  // Do not implement!
  template <typename T>
  MakeValue(const T *value);
  template <typename T>
  MakeValue(T *value);

  // The following methods are private to disallow formatting of wide
  // characters and strings into narrow strings as in
  //   fmt::format("{}", L"test");
  // To fix this, use a wide format string: fmt::format(L"{}", L"test").
#if !FMT_MSC_VER || defined(_NATIVE_WCHAR_T_DEFINED)
  MakeValue(typename WCharHelper<wchar_t, Char>::Unsupported);
#endif
  MakeValue(typename WCharHelper<wchar_t *, Char>::Unsupported);
  MakeValue(typename WCharHelper<const wchar_t *, Char>::Unsupported);
  MakeValue(typename WCharHelper<const std::wstring &, Char>::Unsupported);
  MakeValue(typename WCharHelper<WStringRef, Char>::Unsupported);

  void set_string(StringRef str) {
    string.value = str.data();
    string.size = str.size();
  }

  void set_string(WStringRef str) {
    wstring.value = str.data();
    wstring.size = str.size();
  }

  // Formats an argument of a custom type, such as a user-defined class.
  template <typename T>
  static void format_custom_arg(
      void *formatter, const void *arg, void *format_str_ptr) {
    format_arg(*static_cast<Formatter*>(formatter),
               *static_cast<const Char**>(format_str_ptr),
               *static_cast<const T*>(arg));
  }

 public:
  MakeValue() {}

#define FMT_MAKE_VALUE_(Type, field, TYPE, rhs) \
  MakeValue(Type value) { field = rhs; } \
  static uint64_t type(Type) { return Arg::TYPE; }

#define FMT_MAKE_VALUE(Type, field, TYPE) \
  FMT_MAKE_VALUE_(Type, field, TYPE, value)

  FMT_MAKE_VALUE(bool, int_value, BOOL)
  FMT_MAKE_VALUE(short, int_value, INT)
  FMT_MAKE_VALUE(unsigned short, uint_value, UINT)
  FMT_MAKE_VALUE(int, int_value, INT)
  FMT_MAKE_VALUE(unsigned, uint_value, UINT)

  MakeValue(long value) {
    // To minimize the number of types we need to deal with, long is
    // translated either to int or to long long depending on its size.
    if (const_check(sizeof(long) == sizeof(int)))
      int_value = static_cast<int>(value);
    else
      long_long_value = value;
  }
  static uint64_t type(long) {
    return sizeof(long) == sizeof(int) ? Arg::INT : Arg::LONG_LONG;
  }

  MakeValue(unsigned long value) {
    if (const_check(sizeof(unsigned long) == sizeof(unsigned)))
      uint_value = static_cast<unsigned>(value);
    else
      ulong_long_value = value;
  }
  static uint64_t type(unsigned long) {
    return sizeof(unsigned long) == sizeof(unsigned) ?
          Arg::UINT : Arg::ULONG_LONG;
  }

  FMT_MAKE_VALUE(LongLong, long_long_value, LONG_LONG)
  FMT_MAKE_VALUE(ULongLong, ulong_long_value, ULONG_LONG)
  FMT_MAKE_VALUE(float, double_value, DOUBLE)
  FMT_MAKE_VALUE(double, double_value, DOUBLE)
  FMT_MAKE_VALUE(long double, long_double_value, LONG_DOUBLE)
  FMT_MAKE_VALUE(signed char, int_value, INT)
  FMT_MAKE_VALUE(unsigned char, uint_value, UINT)
  FMT_MAKE_VALUE(char, int_value, CHAR)

#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)
  MakeValue(typename WCharHelper<wchar_t, Char>::Supported value) {
    int_value = value;
  }
  static uint64_t type(wchar_t) { return Arg::CHAR; }
#endif

#define FMT_MAKE_STR_VALUE(Type, TYPE) \
  MakeValue(Type value) { set_string(value); } \
  static uint64_t type(Type) { return Arg::TYPE; }

  FMT_MAKE_VALUE(char *, string.value, CSTRING)
  FMT_MAKE_VALUE(const char *, string.value, CSTRING)
  FMT_MAKE_VALUE(signed char *, sstring.value, CSTRING)
  FMT_MAKE_VALUE(const signed char *, sstring.value, CSTRING)
  FMT_MAKE_VALUE(unsigned char *, ustring.value, CSTRING)
  FMT_MAKE_VALUE(const unsigned char *, ustring.value, CSTRING)
  FMT_MAKE_STR_VALUE(const std::string &, STRING)
  FMT_MAKE_STR_VALUE(StringRef, STRING)
  FMT_MAKE_VALUE_(CStringRef, string.value, CSTRING, value.c_str())

#define FMT_MAKE_WSTR_VALUE(Type, TYPE) \
  MakeValue(typename WCharHelper<Type, Char>::Supported value) { \
    set_string(value); \
  } \
  static uint64_t type(Type) { return Arg::TYPE; }

  FMT_MAKE_WSTR_VALUE(wchar_t *, WSTRING)
  FMT_MAKE_WSTR_VALUE(const wchar_t *, WSTRING)
  FMT_MAKE_WSTR_VALUE(const std::wstring &, WSTRING)
  FMT_MAKE_WSTR_VALUE(WStringRef, WSTRING)

  FMT_MAKE_VALUE(void *, pointer, POINTER)
  FMT_MAKE_VALUE(const void *, pointer, POINTER)

  template <typename T>
  MakeValue(const T &value,
            typename EnableIf<Not<
              ConvertToInt<T>::value>::value, int>::type = 0) {
    custom.value = &value;
    custom.format = &format_custom_arg<T>;
  }

  template <typename T>
  static typename EnableIf<Not<ConvertToInt<T>::value>::value, uint64_t>::type
      type(const T &) {
    return Arg::CUSTOM;
  }

  // Additional template param `Char_` is needed here because make_type always
  // uses char.
  template <typename Char_>
  MakeValue(const NamedArg<Char_> &value) { pointer = &value; }
  template <typename Char_, typename T>
  MakeValue(const NamedArgWithType<Char_, T> &value) { pointer = &value; }

  template <typename Char_>
  static uint64_t type(const NamedArg<Char_> &) { return Arg::NAMED_ARG; }
  template <typename Char_, typename T>
  static uint64_t type(const NamedArgWithType<Char_, T> &) { return Arg::NAMED_ARG; }
};

template <typename Formatter>
class MakeArg : public Arg {
public:
  MakeArg() {
    type = Arg::NONE;
  }

  template <typename T>
  MakeArg(const T &value)
  : Arg(MakeValue<Formatter>(value)) {
    type = static_cast<Arg::Type>(MakeValue<Formatter>::type(value));
  }
};

template <typename Char>
struct NamedArg : Arg {
  BasicStringRef<Char> name;

  template <typename T>
  NamedArg(BasicStringRef<Char> argname, const T &value)
  : Arg(MakeArg< BasicFormatter<Char> >(value)), name(argname) {}
};

template <typename Char, typename T>
struct NamedArgWithType : NamedArg<Char> {
  NamedArgWithType(BasicStringRef<Char> argname, const T &value)
  : NamedArg<Char>(argname, value) {}
};

class RuntimeError : public std::runtime_error {
 protected:
  RuntimeError() : std::runtime_error("") {}
  RuntimeError(const RuntimeError &rerr) : std::runtime_error(rerr) {}
  FMT_API ~RuntimeError() FMT_DTOR_NOEXCEPT;
};

template <typename Char>
class ArgMap;
}  // namespace internal

/** An argument list. */
class ArgList {
 private:
  // To reduce compiled code size per formatting function call, types of first
  // MAX_PACKED_ARGS arguments are passed in the types_ field.
  uint64_t types_;
  union {
    // If the number of arguments is less than MAX_PACKED_ARGS, the argument
    // values are stored in values_, otherwise they are stored in args_.
    // This is done to reduce compiled code size as storing larger objects
    // may require more code (at least on x86-64) even if the same amount of
    // data is actually copied to stack. It saves ~10% on the bloat test.
    const internal::Value *values_;
    const internal::Arg *args_;
  };

  internal::Arg::Type type(unsigned index) const {
    return type(types_, index);
  }

  template <typename Char>
  friend class internal::ArgMap;

 public:
  // Maximum number of arguments with packed types.
  enum { MAX_PACKED_ARGS = 16 };

  ArgList() : types_(0) {}

  ArgList(ULongLong types, const internal::Value *values)
  : types_(types), values_(values) {}
  ArgList(ULongLong types, const internal::Arg *args)
  : types_(types), args_(args) {}

  uint64_t types() const { return types_; }

  /** Returns the argument at specified index. */
  internal::Arg operator[](unsigned index) const {
    using internal::Arg;
    Arg arg;
    bool use_values = type(MAX_PACKED_ARGS - 1) == Arg::NONE;
    if (index < MAX_PACKED_ARGS) {
      Arg::Type arg_type = type(index);
      internal::Value &val = arg;
      if (arg_type != Arg::NONE)
        val = use_values ? values_[index] : args_[index];
      arg.type = arg_type;
      return arg;
    }
    if (use_values) {
      // The index is greater than the number of arguments that can be stored
      // in values, so return a "none" argument.
      arg.type = Arg::NONE;
      return arg;
    }
    for (unsigned i = MAX_PACKED_ARGS; i <= index; ++i) {
      if (args_[i].type == Arg::NONE)
        return args_[i];
    }
    return args_[index];
  }

  static internal::Arg::Type type(uint64_t types, unsigned index) {
    unsigned shift = index * 4;
    uint64_t mask = 0xf;
    return static_cast<internal::Arg::Type>(
          (types & (mask << shift)) >> shift);
  }
};

#define FMT_DISPATCH(call) static_cast<Impl*>(this)->call

/**
  \rst
  An argument visitor based on the `curiously recurring template pattern
  <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.

  To use `~fmt::ArgVisitor` define a subclass that implements some or all of the
  visit methods with the same signatures as the methods in `~fmt::ArgVisitor`,
  for example, `~fmt::ArgVisitor::visit_int()`.
  Pass the subclass as the *Impl* template parameter. Then calling
  `~fmt::ArgVisitor::visit` for some argument will dispatch to a visit method
  specific to the argument type. For example, if the argument type is
  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass
  will be called. If the subclass doesn't contain a method with this signature,
  then a corresponding method of `~fmt::ArgVisitor` will be called.

  **Example**::

    class MyArgVisitor : public fmt::ArgVisitor<MyArgVisitor, void> {
     public:
      void visit_int(int value) { fmt::print("{}", value); }
      void visit_double(double value) { fmt::print("{}", value ); }
    };
  \endrst
 */
template <typename Impl, typename Result>
class ArgVisitor {
 private:
  typedef internal::Arg Arg;

 public:
  void report_unhandled_arg() {}

  Result visit_unhandled_arg() {
    FMT_DISPATCH(report_unhandled_arg());
    return Result();
  }

  /** Visits an ``int`` argument. **/
  Result visit_int(int value) {
    return FMT_DISPATCH(visit_any_int(value));
  }

  /** Visits a ``long long`` argument. **/
  Result visit_long_long(LongLong value) {
    return FMT_DISPATCH(visit_any_int(value));
  }

  /** Visits an ``unsigned`` argument. **/
  Result visit_uint(unsigned value) {
    return FMT_DISPATCH(visit_any_int(value));
  }

  /** Visits an ``unsigned long long`` argument. **/
  Result visit_ulong_long(ULongLong value) {
    return FMT_DISPATCH(visit_any_int(value));
  }

  /** Visits a ``bool`` argument. **/
  Result visit_bool(bool value) {
    return FMT_DISPATCH(visit_any_int(value));
  }

  /** Visits a ``char`` or ``wchar_t`` argument. **/
  Result visit_char(int value) {
    return FMT_DISPATCH(visit_any_int(value));
  }

  /** Visits an argument of any integral type. **/
  template <typename T>
  Result visit_any_int(T) {
    return FMT_DISPATCH(visit_unhandled_arg());
  }

  /** Visits a ``double`` argument. **/
  Result visit_double(double value) {
    return FMT_DISPATCH(visit_any_double(value));
  }

  /** Visits a ``long double`` argument. **/
  Result visit_long_double(long double value) {
    return FMT_DISPATCH(visit_any_double(value));
  }

  /** Visits a ``double`` or ``long double`` argument. **/
  template <typename T>
  Result visit_any_double(T) {
    return FMT_DISPATCH(visit_unhandled_arg());
  }

  /** Visits a null-terminated C string (``const char *``) argument. **/
  Result visit_cstring(const char *) {
    return FMT_DISPATCH(visit_unhandled_arg());
  }

  /** Visits a string argument. **/
  Result visit_string(Arg::StringValue<char>) {
    return FMT_DISPATCH(visit_unhandled_arg());
  }

  /** Visits a wide string argument. **/
  Result visit_wstring(Arg::StringValue<wchar_t>) {
    return FMT_DISPATCH(visit_unhandled_arg());
  }

  /** Visits a pointer argument. **/
  Result visit_pointer(const void *) {
    return FMT_DISPATCH(visit_unhandled_arg());
  }

  /** Visits an argument of a custom (user-defined) type. **/
  Result visit_custom(Arg::CustomValue) {
    return FMT_DISPATCH(visit_unhandled_arg());
  }

  /**
    \rst
    Visits an argument dispatching to the appropriate visit method based on
    the argument type. For example, if the argument type is ``double`` then
    the `~fmt::ArgVisitor::visit_double()` method of the *Impl* class will be
    called.
    \endrst
   */
  Result visit(const Arg &arg) {
    switch (arg.type) {
    case Arg::NONE:
    case Arg::NAMED_ARG:
      FMT_ASSERT(false, "invalid argument type");
      break;
    case Arg::INT:
      return FMT_DISPATCH(visit_int(arg.int_value));
    case Arg::UINT:
      return FMT_DISPATCH(visit_uint(arg.uint_value));
    case Arg::LONG_LONG:
      return FMT_DISPATCH(visit_long_long(arg.long_long_value));
    case Arg::ULONG_LONG:
      return FMT_DISPATCH(visit_ulong_long(arg.ulong_long_value));
    case Arg::BOOL:
      return FMT_DISPATCH(visit_bool(arg.int_value != 0));
    case Arg::CHAR:
      return FMT_DISPATCH(visit_char(arg.int_value));
    case Arg::DOUBLE:
      return FMT_DISPATCH(visit_double(arg.double_value));
    case Arg::LONG_DOUBLE:
      return FMT_DISPATCH(visit_long_double(arg.long_double_value));
    case Arg::CSTRING:
      return FMT_DISPATCH(visit_cstring(arg.string.value));
    case Arg::STRING:
      return FMT_DISPATCH(visit_string(arg.string));
    case Arg::WSTRING:
      return FMT_DISPATCH(visit_wstring(arg.wstring));
    case Arg::POINTER:
      return FMT_DISPATCH(visit_pointer(arg.pointer));
    case Arg::CUSTOM:
      return FMT_DISPATCH(visit_custom(arg.custom));
    }
    return Result();
  }
};

enum Alignment {
  ALIGN_DEFAULT, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER, ALIGN_NUMERIC
};

// Flags.
enum {
  SIGN_FLAG = 1, PLUS_FLAG = 2, MINUS_FLAG = 4, HASH_FLAG = 8,
  CHAR_FLAG = 0x10  // Argument has char type - used in error reporting.
};

// An empty format specifier.
struct EmptySpec {};

// A type specifier.
template <char TYPE>
struct TypeSpec : EmptySpec {
  Alignment align() const { return ALIGN_DEFAULT; }
  unsigned width() const { return 0; }
  int precision() const { return -1; }
  bool flag(unsigned) const { return false; }
  char type() const { return TYPE; }
  char type_prefix() const { return TYPE; }
  char fill() const { return ' '; }
};

// A width specifier.
struct WidthSpec {
  unsigned width_;
  // Fill is always wchar_t and cast to char if necessary to avoid having
  // two specialization of WidthSpec and its subclasses.
  wchar_t fill_;

  WidthSpec(unsigned width, wchar_t fill) : width_(width), fill_(fill) {}

  unsigned width() const { return width_; }
  wchar_t fill() const { return fill_; }
};

// An alignment specifier.
struct AlignSpec : WidthSpec {
  Alignment align_;

  AlignSpec(unsigned width, wchar_t fill, Alignment align = ALIGN_DEFAULT)
  : WidthSpec(width, fill), align_(align) {}

  Alignment align() const { return align_; }

  int precision() const { return -1; }
};

// An alignment and type specifier.
template <char TYPE>
struct AlignTypeSpec : AlignSpec {
  AlignTypeSpec(unsigned width, wchar_t fill) : AlignSpec(width, fill) {}

  bool flag(unsigned) const { return false; }
  char type() const { return TYPE; }
  char type_prefix() const { return TYPE; }
};

// A full format specifier.
struct FormatSpec : AlignSpec {
  unsigned flags_;
  int precision_;
  char type_;

  FormatSpec(
    unsigned width = 0, char type = 0, wchar_t fill = ' ')
  : AlignSpec(width, fill), flags_(0), precision_(-1), type_(type) {}

  bool flag(unsigned f) const { return (flags_ & f) != 0; }
  int precision() const { return precision_; }
  char type() const { return type_; }
  char type_prefix() const { return type_; }
};

// An integer format specifier.
template <typename T, typename SpecT = TypeSpec<0>, typename Char = char>
class IntFormatSpec : public SpecT {
 private:
  T value_;

 public:
  IntFormatSpec(T val, const SpecT &spec = SpecT())
  : SpecT(spec), value_(val) {}

  T value() const { return value_; }
};

// A string format specifier.
template <typename Char>
class StrFormatSpec : public AlignSpec {
 private:
  const Char *str_;

 public:
  template <typename FillChar>
  StrFormatSpec(const Char *str, unsigned width, FillChar fill)
  : AlignSpec(width, fill), str_(str) {
    internal::CharTraits<Char>::convert(FillChar());
  }

  const Char *str() const { return str_; }
};

/**
  Returns an integer format specifier to format the value in base 2.
 */
IntFormatSpec<int, TypeSpec<'b'> > bin(int value);

/**
  Returns an integer format specifier to format the value in base 8.
 */
IntFormatSpec<int, TypeSpec<'o'> > oct(int value);

/**
  Returns an integer format specifier to format the value in base 16 using
  lower-case letters for the digits above 9.
 */
IntFormatSpec<int, TypeSpec<'x'> > hex(int value);

/**
  Returns an integer formatter format specifier to format in base 16 using
  upper-case letters for the digits above 9.
 */
IntFormatSpec<int, TypeSpec<'X'> > hexu(int value);

/**
  \rst
  Returns an integer format specifier to pad the formatted argument with the
  fill character to the specified width using the default (right) numeric
  alignment.

  **Example**::

    MemoryWriter out;
    out << pad(hex(0xcafe), 8, '0');
    // out.str() == "0000cafe"

  \endrst
 */
template <char TYPE_CODE, typename Char>
IntFormatSpec<int, AlignTypeSpec<TYPE_CODE>, Char> pad(
    int value, unsigned width, Char fill = ' ');

#define FMT_DEFINE_INT_FORMATTERS(TYPE) \
inline IntFormatSpec<TYPE, TypeSpec<'b'> > bin(TYPE value) { \
  return IntFormatSpec<TYPE, TypeSpec<'b'> >(value, TypeSpec<'b'>()); \
} \
 \
inline IntFormatSpec<TYPE, TypeSpec<'o'> > oct(TYPE value) { \
  return IntFormatSpec<TYPE, TypeSpec<'o'> >(value, TypeSpec<'o'>()); \
} \
 \
inline IntFormatSpec<TYPE, TypeSpec<'x'> > hex(TYPE value) { \
  return IntFormatSpec<TYPE, TypeSpec<'x'> >(value, TypeSpec<'x'>()); \
} \
 \
inline IntFormatSpec<TYPE, TypeSpec<'X'> > hexu(TYPE value) { \
  return IntFormatSpec<TYPE, TypeSpec<'X'> >(value, TypeSpec<'X'>()); \
} \
 \
template <char TYPE_CODE> \
inline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> > pad( \
    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE> > f, unsigned width) { \
  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> >( \
      f.value(), AlignTypeSpec<TYPE_CODE>(width, ' ')); \
} \
 \
/* For compatibility with older compilers we provide two overloads for pad, */ \
/* one that takes a fill character and one that doesn't. In the future this */ \
/* can be replaced with one overload making the template argument Char      */ \
/* default to char (C++11). */ \
template <char TYPE_CODE, typename Char> \
inline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char> pad( \
    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE>, Char> f, \
    unsigned width, Char fill) { \
  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char>( \
      f.value(), AlignTypeSpec<TYPE_CODE>(width, fill)); \
} \
 \
inline IntFormatSpec<TYPE, AlignTypeSpec<0> > pad( \
    TYPE value, unsigned width) { \
  return IntFormatSpec<TYPE, AlignTypeSpec<0> >( \
      value, AlignTypeSpec<0>(width, ' ')); \
} \
 \
template <typename Char> \
inline IntFormatSpec<TYPE, AlignTypeSpec<0>, Char> pad( \
   TYPE value, unsigned width, Char fill) { \
 return IntFormatSpec<TYPE, AlignTypeSpec<0>, Char>( \
     value, AlignTypeSpec<0>(width, fill)); \
}

FMT_DEFINE_INT_FORMATTERS(int)
FMT_DEFINE_INT_FORMATTERS(long)
FMT_DEFINE_INT_FORMATTERS(unsigned)
FMT_DEFINE_INT_FORMATTERS(unsigned long)
FMT_DEFINE_INT_FORMATTERS(LongLong)
FMT_DEFINE_INT_FORMATTERS(ULongLong)

/**
  \rst
  Returns a string formatter that pads the formatted argument with the fill
  character to the specified width using the default (left) string alignment.

  **Example**::

    std::string s = str(MemoryWriter() << pad("abc", 8));
    // s == "abc     "

  \endrst
 */
template <typename Char>
inline StrFormatSpec<Char> pad(
    const Char *str, unsigned width, Char fill = ' ') {
  return StrFormatSpec<Char>(str, width, fill);
}

inline StrFormatSpec<wchar_t> pad(
    const wchar_t *str, unsigned width, char fill = ' ') {
  return StrFormatSpec<wchar_t>(str, width, fill);
}

namespace internal {

template <typename Char>
class ArgMap {
 private:
  typedef std::vector<
    std::pair<fmt::BasicStringRef<Char>, internal::Arg> > MapType;
  typedef typename MapType::value_type Pair;

  MapType map_;

 public:
  FMT_API void init(const ArgList &args);

  const internal::Arg *find(const fmt::BasicStringRef<Char> &name) const {
    // The list is unsorted, so just return the first matching name.
    for (typename MapType::const_iterator it = map_.begin(), end = map_.end();
         it != end; ++it) {
      if (it->first == name)
        return &it->second;
    }
    return FMT_NULL;
  }
};

template <typename Impl, typename Char, typename Spec = fmt::FormatSpec>
class ArgFormatterBase : public ArgVisitor<Impl, void> {
 private:
  BasicWriter<Char> &writer_;
  Spec &spec_;

  FMT_DISALLOW_COPY_AND_ASSIGN(ArgFormatterBase);

  void write_pointer(const void *p) {
    spec_.flags_ = HASH_FLAG;
    spec_.type_ = 'x';
    writer_.write_int(reinterpret_cast<uintptr_t>(p), spec_);
  }

  // workaround MSVC two-phase lookup issue
  typedef internal::Arg Arg;

 protected:
  BasicWriter<Char> &writer() { return writer_; }
  Spec &spec() { return spec_; }

  void write(bool value) {
    const char *str_value = value ? "true" : "false";
    Arg::StringValue<char> str = { str_value, std::strlen(str_value) };
    writer_.write_str(str, spec_);
  }

  void write(const char *value) {
    Arg::StringValue<char> str = {value, value ? std::strlen(value) : 0};
    writer_.write_str(str, spec_);
  }

 public:
  typedef Spec SpecType;

  ArgFormatterBase(BasicWriter<Char> &w, Spec &s)
  : writer_(w), spec_(s) {}

  template <typename T>
  void visit_any_int(T value) { writer_.write_int(value, spec_); }

  template <typename T>
  void visit_any_double(T value) { writer_.write_double(value, spec_); }

  void visit_bool(bool value) {
    if (spec_.type_) {
      visit_any_int(value);
      return;
    }
    write(value);
  }

  void visit_char(int value) {
    if (spec_.type_ && spec_.type_ != 'c') {
      spec_.flags_ |= CHAR_FLAG;
      writer_.write_int(value, spec_);
      return;
    }
    if (spec_.align_ == ALIGN_NUMERIC || spec_.flags_ != 0)
      FMT_THROW(FormatError("invalid format specifier for char"));
    typedef typename BasicWriter<Char>::CharPtr CharPtr;
    Char fill = internal::CharTraits<Char>::cast(spec_.fill());
    CharPtr out = CharPtr();
    const unsigned CHAR_SIZE = 1;
    if (spec_.width_ > CHAR_SIZE) {
      out = writer_.grow_buffer(spec_.width_);
      if (spec_.align_ == ALIGN_RIGHT) {
        std::uninitialized_fill_n(out, spec_.width_ - CHAR_SIZE, fill);
        out += spec_.width_ - CHAR_SIZE;
      } else if (spec_.align_ == ALIGN_CENTER) {
        out = writer_.fill_padding(out, spec_.width_,
                                   internal::const_check(CHAR_SIZE), fill);
      } else {
        std::uninitialized_fill_n(out + CHAR_SIZE,
                                  spec_.width_ - CHAR_SIZE, fill);
      }
    } else {
      out = writer_.grow_buffer(CHAR_SIZE);
    }
    *out = internal::CharTraits<Char>::cast(value);
  }

  void visit_cstring(const char *value) {
    if (spec_.type_ == 'p')
      return write_pointer(value);
    write(value);
  }

  // Qualification with "internal" here and below is a workaround for nvcc.
  void visit_string(internal::Arg::StringValue<char> value) {
    writer_.write_str(value, spec_);
  }

  using ArgVisitor<Impl, void>::visit_wstring;

  void visit_wstring(internal::Arg::StringValue<Char> value) {
    writer_.write_str(value, spec_);
  }

  void visit_pointer(const void *value) {
    if (spec_.type_ && spec_.type_ != 'p')
      report_unknown_type(spec_.type_, "pointer");
    write_pointer(value);
  }
};

class FormatterBase {
 private:
  ArgList args_;
  int next_arg_index_;

  // Returns the argument with specified index.
  FMT_API Arg do_get_arg(unsigned arg_index, const char *&error);

 protected:
  const ArgList &args() const { return args_; }

  explicit FormatterBase(const ArgList &args) {
    args_ = args;
    next_arg_index_ = 0;
  }

  // Returns the next argument.
  Arg next_arg(const char *&error) {
    if (next_arg_index_ >= 0)
      return do_get_arg(internal::to_unsigned(next_arg_index_++), error);
    error = "cannot switch from manual to automatic argument indexing";
    return Arg();
  }

  // Checks if manual indexing is used and returns the argument with
  // specified index.
  Arg get_arg(unsigned arg_index, const char *&error) {
    return check_no_auto_index(error) ? do_get_arg(arg_index, error) : Arg();
  }

  bool check_no_auto_index(const char *&error) {
    if (next_arg_index_ > 0) {
      error = "cannot switch from automatic to manual argument indexing";
      return false;
    }
    next_arg_index_ = -1;
    return true;
  }

  template <typename Char>
  void write(BasicWriter<Char> &w, const Char *start, const Char *end) {
    if (start != end)
      w << BasicStringRef<Char>(start, internal::to_unsigned(end - start));
  }
};
}  // namespace internal

/**
  \rst
  An argument formatter based on the `curiously recurring template pattern
  <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.

  To use `~fmt::BasicArgFormatter` define a subclass that implements some or
  all of the visit methods with the same signatures as the methods in
  `~fmt::ArgVisitor`, for example, `~fmt::ArgVisitor::visit_int()`.
  Pass the subclass as the *Impl* template parameter. When a formatting
  function processes an argument, it will dispatch to a visit method
  specific to the argument type. For example, if the argument type is
  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass
  will be called. If the subclass doesn't contain a method with this signature,
  then a corresponding method of `~fmt::BasicArgFormatter` or its superclass
  will be called.
  \endrst
 */
template <typename Impl, typename Char, typename Spec = fmt::FormatSpec>
class BasicArgFormatter : public internal::ArgFormatterBase<Impl, Char, Spec> {
 private:
  BasicFormatter<Char, Impl> &formatter_;
  const Char *format_;

 public:
  /**
    \rst
    Constructs an argument formatter object.
    *formatter* is a reference to the main formatter object, *spec* contains
    format specifier information for standard argument types, and *fmt* points
    to the part of the format string being parsed for custom argument types.
    \endrst
   */
  BasicArgFormatter(BasicFormatter<Char, Impl> &formatter,
                    Spec &spec, const Char *fmt)
  : internal::ArgFormatterBase<Impl, Char, Spec>(formatter.writer(), spec),
    formatter_(formatter), format_(fmt) {}

  /** Formats an argument of a custom (user-defined) type. */
  void visit_custom(internal::Arg::CustomValue c) {
    c.format(&formatter_, c.value, &format_);
  }
};

/** The default argument formatter. */
template <typename Char>
class ArgFormatter :
    public BasicArgFormatter<ArgFormatter<Char>, Char, FormatSpec> {
 public:
  /** Constructs an argument formatter object. */
  ArgFormatter(BasicFormatter<Char> &formatter,
               FormatSpec &spec, const Char *fmt)
  : BasicArgFormatter<ArgFormatter<Char>,
                      Char, FormatSpec>(formatter, spec, fmt) {}
};

/** This template formats data and writes the output to a writer. */
template <typename CharType, typename ArgFormatter>
class BasicFormatter : private internal::FormatterBase {
 public:
  /** The character type for the output. */
  typedef CharType Char;

 private:
  BasicWriter<Char> &writer_;
  internal::ArgMap<Char> map_;

  FMT_DISALLOW_COPY_AND_ASSIGN(BasicFormatter);

  using internal::FormatterBase::get_arg;

  // Checks if manual indexing is used and returns the argument with
  // specified name.
  internal::Arg get_arg(BasicStringRef<Char> arg_name, const char *&error);

  // Parses argument index and returns corresponding argument.
  internal::Arg parse_arg_index(const Char *&s);

  // Parses argument name and returns corresponding argument.
  internal::Arg parse_arg_name(const Char *&s);

 public:
  /**
   \rst
   Constructs a ``BasicFormatter`` object. References to the arguments and
   the writer are stored in the formatter object so make sure they have
   appropriate lifetimes.
   \endrst
   */
  BasicFormatter(const ArgList &args, BasicWriter<Char> &w)
    : internal::FormatterBase(args), writer_(w) {}

  /** Returns a reference to the writer associated with this formatter. */
  BasicWriter<Char> &writer() { return writer_; }

  /** Formats stored arguments and writes the output to the writer. */
  void format(BasicCStringRef<Char> format_str);

  // Formats a single argument and advances format_str, a format string pointer.
  const Char *format(const Char *&format_str, const internal::Arg &arg);
};

// Generates a comma-separated list with results of applying f to
// numbers 0..n-1.
# define FMT_GEN(n, f) FMT_GEN##n(f)
# define FMT_GEN1(f)  f(0)
# define FMT_GEN2(f)  FMT_GEN1(f),  f(1)
# define FMT_GEN3(f)  FMT_GEN2(f),  f(2)
# define FMT_GEN4(f)  FMT_GEN3(f),  f(3)
# define FMT_GEN5(f)  FMT_GEN4(f),  f(4)
# define FMT_GEN6(f)  FMT_GEN5(f),  f(5)
# define FMT_GEN7(f)  FMT_GEN6(f),  f(6)
# define FMT_GEN8(f)  FMT_GEN7(f),  f(7)
# define FMT_GEN9(f)  FMT_GEN8(f),  f(8)
# define FMT_GEN10(f) FMT_GEN9(f),  f(9)
# define FMT_GEN11(f) FMT_GEN10(f), f(10)
# define FMT_GEN12(f) FMT_GEN11(f), f(11)
# define FMT_GEN13(f) FMT_GEN12(f), f(12)
# define FMT_GEN14(f) FMT_GEN13(f), f(13)
# define FMT_GEN15(f) FMT_GEN14(f), f(14)

namespace internal {
inline uint64_t make_type() { return 0; }

template <typename T>
inline uint64_t make_type(const T &arg) {
  return MakeValue< BasicFormatter<char> >::type(arg);
}

template <std::size_t N, bool/*IsPacked*/= (N < ArgList::MAX_PACKED_ARGS)>
struct ArgArray;

template <std::size_t N>
struct ArgArray<N, true/*IsPacked*/> {
  typedef Value Type[N > 0 ? N : 1];

  template <typename Formatter, typename T>
  static Value make(const T &value) {
#ifdef __clang__
    Value result = MakeValue<Formatter>(value);
    // Workaround a bug in Apple LLVM version 4.2 (clang-425.0.28) of clang:
    // https://github.com/fmtlib/fmt/issues/276
    (void)result.custom.format;
    return result;
#else
    return MakeValue<Formatter>(value);
#endif
  }
};

template <std::size_t N>
struct ArgArray<N, false/*IsPacked*/> {
  typedef Arg Type[N + 1]; // +1 for the list end Arg::NONE

  template <typename Formatter, typename T>
  static Arg make(const T &value) { return MakeArg<Formatter>(value); }
};

#if FMT_USE_VARIADIC_TEMPLATES
template <typename Arg, typename... Args>
inline uint64_t make_type(const Arg &first, const Args & ... tail) {
  return make_type(first) | (make_type(tail...) << 4);
}

#else

struct ArgType {
  uint64_t type;

  ArgType() : type(0) {}

  template <typename T>
  ArgType(const T &arg) : type(make_type(arg)) {}
};

# define FMT_ARG_TYPE_DEFAULT(n) ArgType t##n = ArgType()

inline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {
  return t0.type | (t1.type << 4) | (t2.type << 8) | (t3.type << 12) |
      (t4.type << 16) | (t5.type << 20) | (t6.type << 24) | (t7.type << 28) |
      (t8.type << 32) | (t9.type << 36) | (t10.type << 40) | (t11.type << 44) |
      (t12.type << 48) | (t13.type << 52) | (t14.type << 56);
}
#endif
}  // namespace internal

# define FMT_MAKE_TEMPLATE_ARG(n) typename T##n
# define FMT_MAKE_ARG_TYPE(n) T##n
# define FMT_MAKE_ARG(n) const T##n &v##n
# define FMT_ASSIGN_char(n) \
  arr[n] = fmt::internal::MakeValue< fmt::BasicFormatter<char> >(v##n)
# define FMT_ASSIGN_wchar_t(n) \
  arr[n] = fmt::internal::MakeValue< fmt::BasicFormatter<wchar_t> >(v##n)

#if FMT_USE_VARIADIC_TEMPLATES
// Defines a variadic function returning void.
# define FMT_VARIADIC_VOID(func, arg_type) \
  template <typename... Args> \
  void func(arg_type arg0, const Args & ... args) { \
    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \
    typename ArgArray::Type array{ \
      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \
    func(arg0, fmt::ArgList(fmt::internal::make_type(args...), array)); \
  }

// Defines a variadic constructor.
# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \
  template <typename... Args> \
  ctor(arg0_type arg0, arg1_type arg1, const Args & ... args) { \
    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \
    typename ArgArray::Type array{ \
      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \
    func(arg0, arg1, fmt::ArgList(fmt::internal::make_type(args...), array)); \
  }

#else

# define FMT_MAKE_REF(n) \
  fmt::internal::MakeValue< fmt::BasicFormatter<Char> >(v##n)
# define FMT_MAKE_REF2(n) v##n

// Defines a wrapper for a function taking one argument of type arg_type
// and n additional arguments of arbitrary types.
# define FMT_WRAP1(func, arg_type, n) \
  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \
  inline void func(arg_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \
    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \
    func(arg1, fmt::ArgList( \
      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \
  }

// Emulates a variadic function returning void on a pre-C++11 compiler.
# define FMT_VARIADIC_VOID(func, arg_type) \
  inline void func(arg_type arg) { func(arg, fmt::ArgList()); } \
  FMT_WRAP1(func, arg_type, 1) FMT_WRAP1(func, arg_type, 2) \
  FMT_WRAP1(func, arg_type, 3) FMT_WRAP1(func, arg_type, 4) \
  FMT_WRAP1(func, arg_type, 5) FMT_WRAP1(func, arg_type, 6) \
  FMT_WRAP1(func, arg_type, 7) FMT_WRAP1(func, arg_type, 8) \
  FMT_WRAP1(func, arg_type, 9) FMT_WRAP1(func, arg_type, 10)

# define FMT_CTOR(ctor, func, arg0_type, arg1_type, n) \
  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \
  ctor(arg0_type arg0, arg1_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \
    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \
    func(arg0, arg1, fmt::ArgList( \
      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \
  }

// Emulates a variadic constructor on a pre-C++11 compiler.
# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 1) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 2) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 3) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 4) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 5) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 6) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 7) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 8) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 9) \
  FMT_CTOR(ctor, func, arg0_type, arg1_type, 10)
#endif

// Generates a comma-separated list with results of applying f to pairs
// (argument, index).
#define FMT_FOR_EACH1(f, x0) f(x0, 0)
#define FMT_FOR_EACH2(f, x0, x1) \
  FMT_FOR_EACH1(f, x0), f(x1, 1)
#define FMT_FOR_EACH3(f, x0, x1, x2) \
  FMT_FOR_EACH2(f, x0 ,x1), f(x2, 2)
#define FMT_FOR_EACH4(f, x0, x1, x2, x3) \
  FMT_FOR_EACH3(f, x0, x1, x2), f(x3, 3)
#define FMT_FOR_EACH5(f, x0, x1, x2, x3, x4) \
  FMT_FOR_EACH4(f, x0, x1, x2, x3), f(x4, 4)
#define FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5) \
  FMT_FOR_EACH5(f, x0, x1, x2, x3, x4), f(x5, 5)
#define FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6) \
  FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5), f(x6, 6)
#define FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7) \
  FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6), f(x7, 7)
#define FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8) \
  FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7), f(x8, 8)
#define FMT_FOR_EACH10(f, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) \
  FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8), f(x9, 9)

/**
 An error returned by an operating system or a language runtime,
 for example a file opening error.
*/
class SystemError : public internal::RuntimeError {
 private:
  FMT_API void init(int err_code, CStringRef format_str, ArgList args);

 protected:
  int error_code_;

  typedef char Char;  // For FMT_VARIADIC_CTOR.

  SystemError() {}

 public:
  /**
   \rst
   Constructs a :class:`fmt::SystemError` object with a description
   formatted with `fmt::format_system_error`. *message* and additional
   arguments passed into the constructor are formatted similarly to
   `fmt::format`.

   **Example**::

     // This throws a SystemError with the description
     //   cannot open file 'madeup': No such file or directory
     // or similar (system message may vary).
     const char *filename = "madeup";
     std::FILE *file = std::fopen(filename, "r");
     if (!file)
       throw fmt::SystemError(errno, "cannot open file '{}'", filename);
   \endrst
  */
  SystemError(int error_code, CStringRef message) {
    init(error_code, message, ArgList());
  }
  FMT_DEFAULTED_COPY_CTOR(SystemError)
  FMT_VARIADIC_CTOR(SystemError, init, int, CStringRef)

  FMT_API ~SystemError() FMT_DTOR_NOEXCEPT;

  int error_code() const { return error_code_; }
};

/**
  \rst
  Formats an error returned by an operating system or a language runtime,
  for example a file opening error, and writes it to *out* in the following
  form:

  .. parsed-literal::
     *<message>*: *<system-message>*

  where *<message>* is the passed message and *<system-message>* is
  the system message corresponding to the error code.
  *error_code* is a system error code as given by ``errno``.
  If *error_code* is not a valid error code such as -1, the system message
  may look like "Unknown error -1" and is platform-dependent.
  \endrst
 */
FMT_API void format_system_error(fmt::Writer &out, int error_code,
                                 fmt::StringRef message) FMT_NOEXCEPT;

/**
  \rst
  This template provides operations for formatting and writing data into
  a character stream. The output is stored in a buffer provided by a subclass
  such as :class:`fmt::BasicMemoryWriter`.

  You can use one of the following typedefs for common character types:

  +---------+----------------------+
  | Type    | Definition           |
  +=========+======================+
  | Writer  | BasicWriter<char>    |
  +---------+----------------------+
  | WWriter | BasicWriter<wchar_t> |
  +---------+----------------------+

  \endrst
 */
template <typename Char>
class BasicWriter {
 private:
  // Output buffer.
  Buffer<Char> &buffer_;

  FMT_DISALLOW_COPY_AND_ASSIGN(BasicWriter);

  typedef typename internal::CharTraits<Char>::CharPtr CharPtr;

#if FMT_SECURE_SCL
  // Returns pointer value.
  static Char *get(CharPtr p) { return p.base(); }
#else
  static Char *get(Char *p) { return p; }
#endif

  // Fills the padding around the content and returns the pointer to the
  // content area.
  static CharPtr fill_padding(CharPtr buffer,
      unsigned total_size, std::size_t content_size, wchar_t fill);

  // Grows the buffer by n characters and returns a pointer to the newly
  // allocated area.
  CharPtr grow_buffer(std::size_t n) {
    std::size_t size = buffer_.size();
    buffer_.resize(size + n);
    return internal::make_ptr(&buffer_[size], n);
  }

  // Writes an unsigned decimal integer.
  template <typename UInt>
  Char *write_unsigned_decimal(UInt value, unsigned prefix_size = 0) {
    unsigned num_digits = internal::count_digits(value);
    Char *ptr = get(grow_buffer(prefix_size + num_digits));
    internal::format_decimal(ptr + prefix_size, value, num_digits);
    return ptr;
  }

  // Writes a decimal integer.
  template <typename Int>
  void write_decimal(Int value) {
    typedef typename internal::IntTraits<Int>::MainType MainType;
    MainType abs_value = static_cast<MainType>(value);
    if (internal::is_negative(value)) {
      abs_value = 0 - abs_value;
      *write_unsigned_decimal(abs_value, 1) = '-';
    } else {
      write_unsigned_decimal(abs_value, 0);
    }
  }

  // Prepare a buffer for integer formatting.
  CharPtr prepare_int_buffer(unsigned num_digits,
      const EmptySpec &, const char *prefix, unsigned prefix_size) {
    unsigned size = prefix_size + num_digits;
    CharPtr p = grow_buffer(size);
    std::uninitialized_copy(prefix, prefix + prefix_size, p);
    return p + size - 1;
  }

  template <typename Spec>
  CharPtr prepare_int_buffer(unsigned num_digits,
    const Spec &spec, const char *prefix, unsigned prefix_size);

  // Formats an integer.
  template <typename T, typename Spec>
  void write_int(T value, Spec spec);

  // Formats a floating-point number (double or long double).
  template <typename T, typename Spec>
  void write_double(T value, const Spec &spec);

  // Writes a formatted string.
  template <typename StrChar>
  CharPtr write_str(const StrChar *s, std::size_t size, const AlignSpec &spec);

  template <typename StrChar, typename Spec>
  void write_str(const internal::Arg::StringValue<StrChar> &str,
                 const Spec &spec);

  // This following methods are private to disallow writing wide characters
  // and strings to a char stream. If you want to print a wide string as a
  // pointer as std::ostream does, cast it to const void*.
  // Do not implement!
  void operator<<(typename internal::WCharHelper<wchar_t, Char>::Unsupported);
  void operator<<(
      typename internal::WCharHelper<const wchar_t *, Char>::Unsupported);

  // Appends floating-point length specifier to the format string.
  // The second argument is only used for overload resolution.
  void append_float_length(Char *&format_ptr, long double) {
    *format_ptr++ = 'L';
  }

  template<typename T>
  void append_float_length(Char *&, T) {}

  template <typename Impl, typename Char_, typename Spec_>
  friend class internal::ArgFormatterBase;

  template <typename Impl, typename Char_, typename Spec_>
  friend class BasicPrintfArgFormatter;

 protected:
  /**
    Constructs a ``BasicWriter`` object.
   */
  explicit BasicWriter(Buffer<Char> &b) : buffer_(b) {}

 public:
  /**
    \rst
    Destroys a ``BasicWriter`` object.
    \endrst
   */
  virtual ~BasicWriter() {}

  /**
    Returns the total number of characters written.
   */
  std::size_t size() const { return buffer_.size(); }

  /**
    Returns a pointer to the output buffer content. No terminating null
    character is appended.
   */
  const Char *data() const FMT_NOEXCEPT { return &buffer_[0]; }

  /**
    Returns a pointer to the output buffer content with terminating null
    character appended.
   */
  const Char *c_str() const {
    std::size_t size = buffer_.size();
    buffer_.reserve(size + 1);
    buffer_[size] = '\0';
    return &buffer_[0];
  }

  /**
    \rst
    Returns the content of the output buffer as an `std::string`.
    \endrst
   */
  std::basic_string<Char> str() const {
    return std::basic_string<Char>(&buffer_[0], buffer_.size());
  }

  /**
    \rst
    Writes formatted data.

    *args* is an argument list representing arbitrary arguments.

    **Example**::

       MemoryWriter out;
       out.write("Current point:\n");
       out.write("({:+f}, {:+f})", -3.14, 3.14);

    This will write the following output to the ``out`` object:

    .. code-block:: none

       Current point:
       (-3.140000, +3.140000)

    The output can be accessed using :func:`data()`, :func:`c_str` or
    :func:`str` methods.

    See also :ref:`syntax`.
    \endrst
   */
  void write(BasicCStringRef<Char> format, ArgList args) {
    BasicFormatter<Char>(args, *this).format(format);
  }
  FMT_VARIADIC_VOID(write, BasicCStringRef<Char>)

  BasicWriter &operator<<(int value) {
    write_decimal(value);
    return *this;
  }
  BasicWriter &operator<<(unsigned value) {
    return *this << IntFormatSpec<unsigned>(value);
  }
  BasicWriter &operator<<(long value) {
    write_decimal(value);
    return *this;
  }
  BasicWriter &operator<<(unsigned long value) {
    return *this << IntFormatSpec<unsigned long>(value);
  }
  BasicWriter &operator<<(LongLong value) {
    write_decimal(value);
    return *this;
  }

  /**
    \rst
    Formats *value* and writes it to the stream.
    \endrst
   */
  BasicWriter &operator<<(ULongLong value) {
    return *this << IntFormatSpec<ULongLong>(value);
  }

  BasicWriter &operator<<(double value) {
    write_double(value, FormatSpec());
    return *this;
  }

  /**
    \rst
    Formats *value* using the general format for floating-point numbers
    (``'g'``) and writes it to the stream.
    \endrst
   */
  BasicWriter &operator<<(long double value) {
    write_double(value, FormatSpec());
    return *this;
  }

  /**
    Writes a character to the stream.
   */
  BasicWriter &operator<<(char value) {
    buffer_.push_back(value);
    return *this;
  }

  BasicWriter &operator<<(
      typename internal::WCharHelper<wchar_t, Char>::Supported value) {
    buffer_.push_back(value);
    return *this;
  }

  /**
    \rst
    Writes *value* to the stream.
    \endrst
   */
  BasicWriter &operator<<(fmt::BasicStringRef<Char> value) {
    const Char *str = value.data();
    buffer_.append(str, str + value.size());
    return *this;
  }

  BasicWriter &operator<<(
      typename internal::WCharHelper<StringRef, Char>::Supported value) {
    const char *str = value.data();
    buffer_.append(str, str + value.size());
    return *this;
  }

  template <typename T, typename Spec, typename FillChar>
  BasicWriter &operator<<(IntFormatSpec<T, Spec, FillChar> spec) {
    internal::CharTraits<Char>::convert(FillChar());
    write_int(spec.value(), spec);
    return *this;
  }

  template <typename StrChar>
  BasicWriter &operator<<(const StrFormatSpec<StrChar> &spec) {
    const StrChar *s = spec.str();
    write_str(s, std::char_traits<Char>::length(s), spec);
    return *this;
  }

  void clear() FMT_NOEXCEPT { buffer_.clear(); }

  Buffer<Char> &buffer() FMT_NOEXCEPT { return buffer_; }
};

template <typename Char>
template <typename StrChar>
typename BasicWriter<Char>::CharPtr BasicWriter<Char>::write_str(
      const StrChar *s, std::size_t size, const AlignSpec &spec) {
  CharPtr out = CharPtr();
  if (spec.width() > size) {
    out = grow_buffer(spec.width());
    Char fill = internal::CharTraits<Char>::cast(spec.fill());
    if (spec.align() == ALIGN_RIGHT) {
      std::uninitialized_fill_n(out, spec.width() - size, fill);
      out += spec.width() - size;
    } else if (spec.align() == ALIGN_CENTER) {
      out = fill_padding(out, spec.width(), size, fill);
    } else {
      std::uninitialized_fill_n(out + size, spec.width() - size, fill);
    }
  } else {
    out = grow_buffer(size);
  }
  std::uninitialized_copy(s, s + size, out);
  return out;
}

template <typename Char>
template <typename StrChar, typename Spec>
void BasicWriter<Char>::write_str(
    const internal::Arg::StringValue<StrChar> &s, const Spec &spec) {
  // Check if StrChar is convertible to Char.
  internal::CharTraits<Char>::convert(StrChar());
  if (spec.type_ && spec.type_ != 's')
    internal::report_unknown_type(spec.type_, "string");
  const StrChar *str_value = s.value;
  std::size_t str_size = s.size;
  if (str_size == 0) {
    if (!str_value) {
      FMT_THROW(FormatError("string pointer is null"));
    }
  }
  std::size_t precision = static_cast<std::size_t>(spec.precision_);
  if (spec.precision_ >= 0 && precision < str_size)
    str_size = precision;
  write_str(str_value, str_size, spec);
}

template <typename Char>
typename BasicWriter<Char>::CharPtr
  BasicWriter<Char>::fill_padding(
    CharPtr buffer, unsigned total_size,
    std::size_t content_size, wchar_t fill) {
  std::size_t padding = total_size - content_size;
  std::size_t left_padding = padding / 2;
  Char fill_char = internal::CharTraits<Char>::cast(fill);
  std::uninitialized_fill_n(buffer, left_padding, fill_char);
  buffer += left_padding;
  CharPtr content = buffer;
  std::uninitialized_fill_n(buffer + content_size,
                            padding - left_padding, fill_char);
  return content;
}

template <typename Char>
template <typename Spec>
typename BasicWriter<Char>::CharPtr
  BasicWriter<Char>::prepare_int_buffer(
    unsigned num_digits, const Spec &spec,
    const char *prefix, unsigned prefix_size) {
  unsigned width = spec.width();
  Alignment align = spec.align();
  Char fill = internal::CharTraits<Char>::cast(spec.fill());
  if (spec.precision() > static_cast<int>(num_digits)) {
    // Octal prefix '0' is counted as a digit, so ignore it if precision
    // is specified.
    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')
      --prefix_size;
    unsigned number_size =
        prefix_size + internal::to_unsigned(spec.precision());
    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);
    if (number_size >= width)
      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);
    buffer_.reserve(width);
    unsigned fill_size = width - number_size;
    if (align != ALIGN_LEFT) {
      CharPtr p = grow_buffer(fill_size);
      std::uninitialized_fill(p, p + fill_size, fill);
    }
    CharPtr result = prepare_int_buffer(
        num_digits, subspec, prefix, prefix_size);
    if (align == ALIGN_LEFT) {
      CharPtr p = grow_buffer(fill_size);
      std::uninitialized_fill(p, p + fill_size, fill);
    }
    return result;
  }
  unsigned size = prefix_size + num_digits;
  if (width <= size) {
    CharPtr p = grow_buffer(size);
    std::uninitialized_copy(prefix, prefix + prefix_size, p);
    return p + size - 1;
  }
  CharPtr p = grow_buffer(width);
  CharPtr end = p + width;
  if (align == ALIGN_LEFT) {
    std::uninitialized_copy(prefix, prefix + prefix_size, p);
    p += size;
    std::uninitialized_fill(p, end, fill);
  } else if (align == ALIGN_CENTER) {
    p = fill_padding(p, width, size, fill);
    std::uninitialized_copy(prefix, prefix + prefix_size, p);
    p += size;
  } else {
    if (align == ALIGN_NUMERIC) {
      if (prefix_size != 0) {
        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);
        size -= prefix_size;
      }
    } else {
      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);
    }
    std::uninitialized_fill(p, end - size, fill);
    p = end;
  }
  return p - 1;
}

template <typename Char>
template <typename T, typename Spec>
void BasicWriter<Char>::write_int(T value, Spec spec) {
  unsigned prefix_size = 0;
  typedef typename internal::IntTraits<T>::MainType UnsignedType;
  UnsignedType abs_value = static_cast<UnsignedType>(value);
  char prefix[4] = "";
  if (internal::is_negative(value)) {
    prefix[0] = '-';
    ++prefix_size;
    abs_value = 0 - abs_value;
  } else if (spec.flag(SIGN_FLAG)) {
    prefix[0] = spec.flag(PLUS_FLAG) ? '+' : ' ';
    ++prefix_size;
  }
  switch (spec.type()) {
  case 0: case 'd': {
    unsigned num_digits = internal::count_digits(abs_value);
    CharPtr p = prepare_int_buffer(num_digits, spec, prefix, prefix_size) + 1;
    internal::format_decimal(get(p), abs_value, 0);
    break;
  }
  case 'x': case 'X': {
    UnsignedType n = abs_value;
    if (spec.flag(HASH_FLAG)) {
      prefix[prefix_size++] = '0';
      prefix[prefix_size++] = spec.type_prefix();
    }
    unsigned num_digits = 0;
    do {
      ++num_digits;
    } while ((n >>= 4) != 0);
    Char *p = get(prepare_int_buffer(
      num_digits, spec, prefix, prefix_size));
    n = abs_value;
    const char *digits = spec.type() == 'x' ?
        "0123456789abcdef" : "0123456789ABCDEF";
    do {
      *p-- = digits[n & 0xf];
    } while ((n >>= 4) != 0);
    break;
  }
  case 'b': case 'B': {
    UnsignedType n = abs_value;
    if (spec.flag(HASH_FLAG)) {
      prefix[prefix_size++] = '0';
      prefix[prefix_size++] = spec.type_prefix();
    }
    unsigned num_digits = 0;
    do {
      ++num_digits;
    } while ((n >>= 1) != 0);
    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));
    n = abs_value;
    do {
      *p-- = static_cast<Char>('0' + (n & 1));
    } while ((n >>= 1) != 0);
    break;
  }
  case 'o': {
    UnsignedType n = abs_value;
    if (spec.flag(HASH_FLAG))
      prefix[prefix_size++] = '0';
    unsigned num_digits = 0;
    do {
      ++num_digits;
    } while ((n >>= 3) != 0);
    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));
    n = abs_value;
    do {
      *p-- = static_cast<Char>('0' + (n & 7));
    } while ((n >>= 3) != 0);
    break;
  }
  case 'n': {
    unsigned num_digits = internal::count_digits(abs_value);
    fmt::StringRef sep = "";
#if !(defined(ANDROID) || defined(__ANDROID__))
    sep = internal::thousands_sep(std::localeconv());
#endif
    unsigned size = static_cast<unsigned>(
          num_digits + sep.size() * ((num_digits - 1) / 3));
    CharPtr p = prepare_int_buffer(size, spec, prefix, prefix_size) + 1;
    internal::format_decimal(get(p), abs_value, 0, internal::ThousandsSep(sep));
    break;
  }
  default:
    internal::report_unknown_type(
      spec.type(), spec.flag(CHAR_FLAG) ? "char" : "integer");
    break;
  }
}

template <typename Char>
template <typename T, typename Spec>
void BasicWriter<Char>::write_double(T value, const Spec &spec) {
  // Check type.
  char type = spec.type();
  bool upper = false;
  switch (type) {
  case 0:
    type = 'g';
    break;
  case 'e': case 'f': case 'g': case 'a':
    break;
  case 'F':
#if FMT_MSC_VER
    // MSVC's printf doesn't support 'F'.
    type = 'f';
#endif
    // Fall through.
  case 'E': case 'G': case 'A':
    upper = true;
    break;
  default:
    internal::report_unknown_type(type, "double");
    break;
  }

  char sign = 0;
  // Use isnegative instead of value < 0 because the latter is always
  // false for NaN.
  if (internal::FPUtil::isnegative(static_cast<double>(value))) {
    sign = '-';
    value = -value;
  } else if (spec.flag(SIGN_FLAG)) {
    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';
  }

  if (internal::FPUtil::isnotanumber(value)) {
    // Format NaN ourselves because sprintf's output is not consistent
    // across platforms.
    std::size_t nan_size = 4;
    const char *nan = upper ? " NAN" : " nan";
    if (!sign) {
      --nan_size;
      ++nan;
    }
    CharPtr out = write_str(nan, nan_size, spec);
    if (sign)
      *out = sign;
    return;
  }

  if (internal::FPUtil::isinfinity(value)) {
    // Format infinity ourselves because sprintf's output is not consistent
    // across platforms.
    std::size_t inf_size = 4;
    const char *inf = upper ? " INF" : " inf";
    if (!sign) {
      --inf_size;
      ++inf;
    }
    CharPtr out = write_str(inf, inf_size, spec);
    if (sign)
      *out = sign;
    return;
  }

  std::size_t offset = buffer_.size();
  unsigned width = spec.width();
  if (sign) {
    buffer_.reserve(buffer_.size() + (width > 1u ? width : 1u));
    if (width > 0)
      --width;
    ++offset;
  }

  // Build format string.
  enum { MAX_FORMAT_SIZE = 10}; // longest format: %#-*.*Lg
  Char format[MAX_FORMAT_SIZE];
  Char *format_ptr = format;
  *format_ptr++ = '%';
  unsigned width_for_sprintf = width;
  if (spec.flag(HASH_FLAG))
    *format_ptr++ = '#';
  if (spec.align() == ALIGN_CENTER) {
    width_for_sprintf = 0;
  } else {
    if (spec.align() == ALIGN_LEFT)
      *format_ptr++ = '-';
    if (width != 0)
      *format_ptr++ = '*';
  }
  if (spec.precision() >= 0) {
    *format_ptr++ = '.';
    *format_ptr++ = '*';
  }

  append_float_length(format_ptr, value);
  *format_ptr++ = type;
  *format_ptr = '\0';

  // Format using snprintf.
  Char fill = internal::CharTraits<Char>::cast(spec.fill());
  unsigned n = 0;
  Char *start = FMT_NULL;
  for (;;) {
    std::size_t buffer_size = buffer_.capacity() - offset;
#if FMT_MSC_VER
    // MSVC's vsnprintf_s doesn't work with zero size, so reserve
    // space for at least one extra character to make the size non-zero.
    // Note that the buffer's capacity will increase by more than 1.
    if (buffer_size == 0) {
      buffer_.reserve(offset + 1);
      buffer_size = buffer_.capacity() - offset;
    }
#endif
    start = &buffer_[offset];
    int result = internal::CharTraits<Char>::format_float(
        start, buffer_size, format, width_for_sprintf, spec.precision(), value);
    if (result >= 0) {
      n = internal::to_unsigned(result);
      if (offset + n < buffer_.capacity())
        break;  // The buffer is large enough - continue with formatting.
      buffer_.reserve(offset + n + 1);
    } else {
      // If result is negative we ask to increase the capacity by at least 1,
      // but as std::vector, the buffer grows exponentially.
      buffer_.reserve(buffer_.capacity() + 1);
    }
  }
  if (sign) {
    if ((spec.align() != ALIGN_RIGHT && spec.align() != ALIGN_DEFAULT) ||
        *start != ' ') {
      *(start - 1) = sign;
      sign = 0;
    } else {
      *(start - 1) = fill;
    }
    ++n;
  }
  if (spec.align() == ALIGN_CENTER && spec.width() > n) {
    width = spec.width();
    CharPtr p = grow_buffer(width);
    std::memmove(get(p) + (width - n) / 2, get(p), n * sizeof(Char));
    fill_padding(p, spec.width(), n, fill);
    return;
  }
  if (spec.fill() != ' ' || sign) {
    while (*start == ' ')
      *start++ = fill;
    if (sign)
      *(start - 1) = sign;
  }
  grow_buffer(n);
}

/**
  \rst
  This class template provides operations for formatting and writing data
  into a character stream. The output is stored in a memory buffer that grows
  dynamically.

  You can use one of the following typedefs for common character types
  and the standard allocator:

  +---------------+-----------------------------------------------------+
  | Type          | Definition                                          |
  +===============+=====================================================+
  | MemoryWriter  | BasicMemoryWriter<char, std::allocator<char>>       |
  +---------------+-----------------------------------------------------+
  | WMemoryWriter | BasicMemoryWriter<wchar_t, std::allocator<wchar_t>> |
  +---------------+-----------------------------------------------------+

  **Example**::

     MemoryWriter out;
     out << "The answer is " << 42 << "\n";
     out.write("({:+f}, {:+f})", -3.14, 3.14);

  This will write the following output to the ``out`` object:

  .. code-block:: none

     The answer is 42
     (-3.140000, +3.140000)

  The output can be converted to an ``std::string`` with ``out.str()`` or
  accessed as a C string with ``out.c_str()``.
  \endrst
 */
template <typename Char, typename Allocator = std::allocator<Char> >
class BasicMemoryWriter : public BasicWriter<Char> {
 private:
  internal::MemoryBuffer<Char, internal::INLINE_BUFFER_SIZE, Allocator> buffer_;

 public:
  explicit BasicMemoryWriter(const Allocator& alloc = Allocator())
    : BasicWriter<Char>(buffer_), buffer_(alloc) {}

#if FMT_USE_RVALUE_REFERENCES
  /**
    \rst
    Constructs a :class:`fmt::BasicMemoryWriter` object moving the content
    of the other object to it.
    \endrst
   */
  BasicMemoryWriter(BasicMemoryWriter &&other)
    : BasicWriter<Char>(buffer_), buffer_(std::move(other.buffer_)) {
  }

  /**
    \rst
    Moves the content of the other ``BasicMemoryWriter`` object to this one.
    \endrst
   */
  BasicMemoryWriter &operator=(BasicMemoryWriter &&other) {
    buffer_ = std::move(other.buffer_);
    return *this;
  }
#endif
};

typedef BasicMemoryWriter<char> MemoryWriter;
typedef BasicMemoryWriter<wchar_t> WMemoryWriter;

/**
  \rst
  This class template provides operations for formatting and writing data
  into a fixed-size array. For writing into a dynamically growing buffer
  use :class:`fmt::BasicMemoryWriter`.

  Any write method will throw ``std::runtime_error`` if the output doesn't fit
  into the array.

  You can use one of the following typedefs for common character types:

  +--------------+---------------------------+
  | Type         | Definition                |
  +==============+===========================+
  | ArrayWriter  | BasicArrayWriter<char>    |
  +--------------+---------------------------+
  | WArrayWriter | BasicArrayWriter<wchar_t> |
  +--------------+---------------------------+
  \endrst
 */
template <typename Char>
class BasicArrayWriter : public BasicWriter<Char> {
 private:
  internal::FixedBuffer<Char> buffer_;

 public:
  /**
   \rst
   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the
   given size.
   \endrst
   */
  BasicArrayWriter(Char *array, std::size_t size)
    : BasicWriter<Char>(buffer_), buffer_(array, size) {}

  /**
   \rst
   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the
   size known at compile time.
   \endrst
   */
  template <std::size_t SIZE>
  explicit BasicArrayWriter(Char (&array)[SIZE])
    : BasicWriter<Char>(buffer_), buffer_(array, SIZE) {}
};

typedef BasicArrayWriter<char> ArrayWriter;
typedef BasicArrayWriter<wchar_t> WArrayWriter;

// Reports a system error without throwing an exception.
// Can be used to report errors from destructors.
FMT_API void report_system_error(int error_code,
                                 StringRef message) FMT_NOEXCEPT;

#if FMT_USE_WINDOWS_H

/** A Windows error. */
class WindowsError : public SystemError {
 private:
  FMT_API void init(int error_code, CStringRef format_str, ArgList args);

 public:
  /**
   \rst
   Constructs a :class:`fmt::WindowsError` object with the description
   of the form

   .. parsed-literal::
     *<message>*: *<system-message>*

   where *<message>* is the formatted message and *<system-message>* is the
   system message corresponding to the error code.
   *error_code* is a Windows error code as given by ``GetLastError``.
   If *error_code* is not a valid error code such as -1, the system message
   will look like "error -1".

   **Example**::

     // This throws a WindowsError with the description
     //   cannot open file 'madeup': The system cannot find the file specified.
     // or similar (system message may vary).
     const char *filename = "madeup";
     LPOFSTRUCT of = LPOFSTRUCT();
     HFILE file = OpenFile(filename, &of, OF_READ);
     if (file == HFILE_ERROR) {
       throw fmt::WindowsError(GetLastError(),
                               "cannot open file '{}'", filename);
     }
   \endrst
  */
  WindowsError(int error_code, CStringRef message) {
    init(error_code, message, ArgList());
  }
  FMT_VARIADIC_CTOR(WindowsError, init, int, CStringRef)
};

// Reports a Windows error without throwing an exception.
// Can be used to report errors from destructors.
FMT_API void report_windows_error(int error_code,
                                  StringRef message) FMT_NOEXCEPT;

#endif

enum Color { BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE };

/**
  Formats a string and prints it to stdout using ANSI escape sequences
  to specify color (experimental).
  Example:
    print_colored(fmt::RED, "Elapsed time: {0:.2f} seconds", 1.23);
 */
FMT_API void print_colored(Color c, CStringRef format, ArgList args);

/**
  \rst
  Formats arguments and returns the result as a string.

  **Example**::

    std::string message = format("The answer is {}", 42);
  \endrst
*/
inline std::string format(CStringRef format_str, ArgList args) {
  MemoryWriter w;
  w.write(format_str, args);
  return w.str();
}

inline std::wstring format(WCStringRef format_str, ArgList args) {
  WMemoryWriter w;
  w.write(format_str, args);
  return w.str();
}

/**
  \rst
  Prints formatted data to the file *f*.

  **Example**::

    print(stderr, "Don't {}!", "panic");
  \endrst
 */
FMT_API void print(std::FILE *f, CStringRef format_str, ArgList args);

/**
  \rst
  Prints formatted data to ``stdout``.

  **Example**::

    print("Elapsed time: {0:.2f} seconds", 1.23);
  \endrst
 */
FMT_API void print(CStringRef format_str, ArgList args);

/**
  Fast integer formatter.
 */
class FormatInt {
 private:
  // Buffer should be large enough to hold all digits (digits10 + 1),
  // a sign and a null character.
  enum {BUFFER_SIZE = std::numeric_limits<ULongLong>::digits10 + 3};
  mutable char buffer_[BUFFER_SIZE];
  char *str_;

  // Formats value in reverse and returns the number of digits.
  char *format_decimal(ULongLong value) {
    char *buffer_end = buffer_ + BUFFER_SIZE - 1;
    while (value >= 100) {
      // Integer division is slow so do it for a group of two digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      unsigned index = static_cast<unsigned>((value % 100) * 2);
      value /= 100;
      *--buffer_end = internal::Data::DIGITS[index + 1];
      *--buffer_end = internal::Data::DIGITS[index];
    }
    if (value < 10) {
      *--buffer_end = static_cast<char>('0' + value);
      return buffer_end;
    }
    unsigned index = static_cast<unsigned>(value * 2);
    *--buffer_end = internal::Data::DIGITS[index + 1];
    *--buffer_end = internal::Data::DIGITS[index];
    return buffer_end;
  }

  void FormatSigned(LongLong value) {
    ULongLong abs_value = static_cast<ULongLong>(value);
    bool negative = value < 0;
    if (negative)
      abs_value = 0 - abs_value;
    str_ = format_decimal(abs_value);
    if (negative)
      *--str_ = '-';
  }

 public:
  explicit FormatInt(int value) { FormatSigned(value); }
  explicit FormatInt(long value) { FormatSigned(value); }
  explicit FormatInt(LongLong value) { FormatSigned(value); }
  explicit FormatInt(unsigned value) : str_(format_decimal(value)) {}
  explicit FormatInt(unsigned long value) : str_(format_decimal(value)) {}
  explicit FormatInt(ULongLong value) : str_(format_decimal(value)) {}

  /** Returns the number of characters written to the output buffer. */
  std::size_t size() const {
    return internal::to_unsigned(buffer_ - str_ + BUFFER_SIZE - 1);
  }

  /**
    Returns a pointer to the output buffer content. No terminating null
    character is appended.
   */
  const char *data() const { return str_; }

  /**
    Returns a pointer to the output buffer content with terminating null
    character appended.
   */
  const char *c_str() const {
    buffer_[BUFFER_SIZE - 1] = '\0';
    return str_;
  }

  /**
    \rst
    Returns the content of the output buffer as an ``std::string``.
    \endrst
   */
  std::string str() const { return std::string(str_, size()); }
};

// Formats a decimal integer value writing into buffer and returns
// a pointer to the end of the formatted string. This function doesn't
// write a terminating null character.
template <typename T>
inline void format_decimal(char *&buffer, T value) {
  typedef typename internal::IntTraits<T>::MainType MainType;
  MainType abs_value = static_cast<MainType>(value);
  if (internal::is_negative(value)) {
    *buffer++ = '-';
    abs_value = 0 - abs_value;
  }
  if (abs_value < 100) {
    if (abs_value < 10) {
      *buffer++ = static_cast<char>('0' + abs_value);
      return;
    }
    unsigned index = static_cast<unsigned>(abs_value * 2);
    *buffer++ = internal::Data::DIGITS[index];
    *buffer++ = internal::Data::DIGITS[index + 1];
    return;
  }
  unsigned num_digits = internal::count_digits(abs_value);
  internal::format_decimal(buffer, abs_value, num_digits);
  buffer += num_digits;
}

/**
  \rst
  Returns a named argument for formatting functions.

  **Example**::

    print("Elapsed time: {s:.2f} seconds", arg("s", 1.23));

  \endrst
 */
template <typename T>
inline internal::NamedArgWithType<char, T> arg(StringRef name, const T &arg) {
  return internal::NamedArgWithType<char, T>(name, arg);
}

template <typename T>
inline internal::NamedArgWithType<wchar_t, T> arg(WStringRef name, const T &arg) {
  return internal::NamedArgWithType<wchar_t, T>(name, arg);
}

// The following two functions are deleted intentionally to disable
// nested named arguments as in ``format("{}", arg("a", arg("b", 42)))``.
template <typename Char>
void arg(StringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;
template <typename Char>
void arg(WStringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;
}

#if FMT_GCC_VERSION
// Use the system_header pragma to suppress warnings about variadic macros
// because suppressing -Wvariadic-macros with the diagnostic pragma doesn't
// work. It is used at the end because we want to suppress as little warnings
// as possible.
# pragma GCC system_header
#endif

// This is used to work around VC++ bugs in handling variadic macros.
#define FMT_EXPAND(args) args

// Returns the number of arguments.
// Based on https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s.
#define FMT_NARG(...) FMT_NARG_(__VA_ARGS__, FMT_RSEQ_N())
#define FMT_NARG_(...) FMT_EXPAND(FMT_ARG_N(__VA_ARGS__))
#define FMT_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
#define FMT_RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0

#define FMT_FOR_EACH_(N, f, ...) \
  FMT_EXPAND(FMT_CONCAT(FMT_FOR_EACH, N)(f, __VA_ARGS__))
#define FMT_FOR_EACH(f, ...) \
  FMT_EXPAND(FMT_FOR_EACH_(FMT_NARG(__VA_ARGS__), f, __VA_ARGS__))

#define FMT_ADD_ARG_NAME(type, index) type arg##index
#define FMT_GET_ARG_NAME(type, index) arg##index

#if FMT_USE_VARIADIC_TEMPLATES
# define FMT_VARIADIC_(Char, ReturnType, func, call, ...) \
  template <typename... Args> \
  ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \
      const Args & ... args) { \
    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \
    typename ArgArray::Type array{ \
      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \
    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), \
      fmt::ArgList(fmt::internal::make_type(args...), array)); \
  }
#else
// Defines a wrapper for a function taking __VA_ARGS__ arguments
// and n additional arguments of arbitrary types.
# define FMT_WRAP(Char, ReturnType, func, call, n, ...) \
  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \
  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \
      FMT_GEN(n, FMT_MAKE_ARG)) { \
    fmt::internal::ArgArray<n>::Type arr; \
    FMT_GEN(n, FMT_ASSIGN_##Char); \
    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList( \
      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), arr)); \
  }

# define FMT_VARIADIC_(Char, ReturnType, func, call, ...) \
  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__)) { \
    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList()); \
  } \
  FMT_WRAP(Char, ReturnType, func, call, 1, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 2, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 3, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 4, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 5, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 6, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 7, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 8, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 9, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 10, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 11, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 12, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 13, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 14, __VA_ARGS__) \
  FMT_WRAP(Char, ReturnType, func, call, 15, __VA_ARGS__)
#endif  // FMT_USE_VARIADIC_TEMPLATES

/**
  \rst
  Defines a variadic function with the specified return type, function name
  and argument types passed as variable arguments to this macro.

  **Example**::

    void print_error(const char *file, int line, const char *format,
                     fmt::ArgList args) {
      fmt::print("{}: {}: ", file, line);
      fmt::print(format, args);
    }
    FMT_VARIADIC(void, print_error, const char *, int, const char *)

  ``FMT_VARIADIC`` is used for compatibility with legacy C++ compilers that
  don't implement variadic templates. You don't have to use this macro if
  you don't need legacy compiler support and can use variadic templates
  directly::

    template <typename... Args>
    void print_error(const char *file, int line, const char *format,
                     const Args & ... args) {
      fmt::print("{}: {}: ", file, line);
      fmt::print(format, args...);
    }
  \endrst
 */
#define FMT_VARIADIC(ReturnType, func, ...) \
  FMT_VARIADIC_(char, ReturnType, func, return func, __VA_ARGS__)

#define FMT_VARIADIC_W(ReturnType, func, ...) \
  FMT_VARIADIC_(wchar_t, ReturnType, func, return func, __VA_ARGS__)

#define FMT_CAPTURE_ARG_(id, index) ::fmt::arg(#id, id)

#define FMT_CAPTURE_ARG_W_(id, index) ::fmt::arg(L###id, id)

/**
  \rst
  Convenient macro to capture the arguments' names and values into several
  ``fmt::arg(name, value)``.

  **Example**::

    int x = 1, y = 2;
    print("point: ({x}, {y})", FMT_CAPTURE(x, y));
    // same as:
    // print("point: ({x}, {y})", arg("x", x), arg("y", y));

  \endrst
 */
#define FMT_CAPTURE(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_, __VA_ARGS__)

#define FMT_CAPTURE_W(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_W_, __VA_ARGS__)

namespace fmt {
FMT_VARIADIC(std::string, format, CStringRef)
FMT_VARIADIC_W(std::wstring, format, WCStringRef)
FMT_VARIADIC(void, print, CStringRef)
FMT_VARIADIC(void, print, std::FILE *, CStringRef)
FMT_VARIADIC(void, print_colored, Color, CStringRef)

namespace internal {
template <typename Char>
inline bool is_name_start(Char c) {
  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;
}

// Parses an unsigned integer advancing s to the end of the parsed input.
// This function assumes that the first character of s is a digit.
template <typename Char>
unsigned parse_nonnegative_int(const Char *&s) {
  assert('0' <= *s && *s <= '9');
  unsigned value = 0;
  do {
    unsigned new_value = value * 10 + (*s++ - '0');
    // Check if value wrapped around.
    if (new_value < value) {
      value = (std::numeric_limits<unsigned>::max)();
      break;
    }
    value = new_value;
  } while ('0' <= *s && *s <= '9');
  // Convert to unsigned to prevent a warning.
  unsigned max_int = (std::numeric_limits<int>::max)();
  if (value > max_int)
    FMT_THROW(FormatError("number is too big"));
  return value;
}

inline void require_numeric_argument(const Arg &arg, char spec) {
  if (arg.type > Arg::LAST_NUMERIC_TYPE) {
    std::string message =
        fmt::format("format specifier '{}' requires numeric argument", spec);
    FMT_THROW(fmt::FormatError(message));
  }
}

template <typename Char>
void check_sign(const Char *&s, const Arg &arg) {
  char sign = static_cast<char>(*s);
  require_numeric_argument(arg, sign);
  if (arg.type == Arg::UINT || arg.type == Arg::ULONG_LONG) {
    FMT_THROW(FormatError(fmt::format(
      "format specifier '{}' requires signed argument", sign)));
  }
  ++s;
}
}  // namespace internal

template <typename Char, typename AF>
inline internal::Arg BasicFormatter<Char, AF>::get_arg(
    BasicStringRef<Char> arg_name, const char *&error) {
  if (check_no_auto_index(error)) {
    map_.init(args());
    const internal::Arg *arg = map_.find(arg_name);
    if (arg)
      return *arg;
    error = "argument not found";
  }
  return internal::Arg();
}

template <typename Char, typename AF>
inline internal::Arg BasicFormatter<Char, AF>::parse_arg_index(const Char *&s) {
  const char *error = FMT_NULL;
  internal::Arg arg = *s < '0' || *s > '9' ?
        next_arg(error) : get_arg(internal::parse_nonnegative_int(s), error);
  if (error) {
    FMT_THROW(FormatError(
                *s != '}' && *s != ':' ? "invalid format string" : error));
  }
  return arg;
}

template <typename Char, typename AF>
inline internal::Arg BasicFormatter<Char, AF>::parse_arg_name(const Char *&s) {
  assert(internal::is_name_start(*s));
  const Char *start = s;
  Char c;
  do {
    c = *++s;
  } while (internal::is_name_start(c) || ('0' <= c && c <= '9'));
  const char *error = FMT_NULL;
  internal::Arg arg = get_arg(BasicStringRef<Char>(start, s - start), error);
  if (error)
    FMT_THROW(FormatError(error));
  return arg;
}

template <typename Char, typename ArgFormatter>
const Char *BasicFormatter<Char, ArgFormatter>::format(
    const Char *&format_str, const internal::Arg &arg) {
  using internal::Arg;
  const Char *s = format_str;
  typename ArgFormatter::SpecType spec;
  if (*s == ':') {
    if (arg.type == Arg::CUSTOM) {
      arg.custom.format(this, arg.custom.value, &s);
      return s;
    }
    ++s;
    // Parse fill and alignment.
    if (Char c = *s) {
      const Char *p = s + 1;
      spec.align_ = ALIGN_DEFAULT;
      do {
        switch (*p) {
          case '<':
            spec.align_ = ALIGN_LEFT;
            break;
          case '>':
            spec.align_ = ALIGN_RIGHT;
            break;
          case '=':
            spec.align_ = ALIGN_NUMERIC;
            break;
          case '^':
            spec.align_ = ALIGN_CENTER;
            break;
        }
        if (spec.align_ != ALIGN_DEFAULT) {
          if (p != s) {
            if (c == '}') break;
            if (c == '{')
              FMT_THROW(FormatError("invalid fill character '{'"));
            s += 2;
            spec.fill_ = c;
          } else ++s;
          if (spec.align_ == ALIGN_NUMERIC)
            require_numeric_argument(arg, '=');
          break;
        }
      } while (--p >= s);
    }

    // Parse sign.
    switch (*s) {
      case '+':
        check_sign(s, arg);
        spec.flags_ |= SIGN_FLAG | PLUS_FLAG;
        break;
      case '-':
        check_sign(s, arg);
        spec.flags_ |= MINUS_FLAG;
        break;
      case ' ':
        check_sign(s, arg);
        spec.flags_ |= SIGN_FLAG;
        break;
    }

    if (*s == '#') {
      require_numeric_argument(arg, '#');
      spec.flags_ |= HASH_FLAG;
      ++s;
    }

    // Parse zero flag.
    if (*s == '0') {
      require_numeric_argument(arg, '0');
      spec.align_ = ALIGN_NUMERIC;
      spec.fill_ = '0';
      ++s;
    }

    // Parse width.
    if ('0' <= *s && *s <= '9') {
      spec.width_ = internal::parse_nonnegative_int(s);
    } else if (*s == '{') {
      ++s;
      Arg width_arg = internal::is_name_start(*s) ?
            parse_arg_name(s) : parse_arg_index(s);
      if (*s++ != '}')
        FMT_THROW(FormatError("invalid format string"));
      ULongLong value = 0;
      switch (width_arg.type) {
      case Arg::INT:
        if (width_arg.int_value < 0)
          FMT_THROW(FormatError("negative width"));
        value = width_arg.int_value;
        break;
      case Arg::UINT:
        value = width_arg.uint_value;
        break;
      case Arg::LONG_LONG:
        if (width_arg.long_long_value < 0)
          FMT_THROW(FormatError("negative width"));
        value = width_arg.long_long_value;
        break;
      case Arg::ULONG_LONG:
        value = width_arg.ulong_long_value;
        break;
      default:
        FMT_THROW(FormatError("width is not integer"));
      }
      if (value > (std::numeric_limits<int>::max)())
        FMT_THROW(FormatError("number is too big"));
      spec.width_ = static_cast<int>(value);
    }

    // Parse precision.
    if (*s == '.') {
      ++s;
      spec.precision_ = 0;
      if ('0' <= *s && *s <= '9') {
        spec.precision_ = internal::parse_nonnegative_int(s);
      } else if (*s == '{') {
        ++s;
        Arg precision_arg = internal::is_name_start(*s) ?
              parse_arg_name(s) : parse_arg_index(s);
        if (*s++ != '}')
          FMT_THROW(FormatError("invalid format string"));
        ULongLong value = 0;
        switch (precision_arg.type) {
          case Arg::INT:
            if (precision_arg.int_value < 0)
              FMT_THROW(FormatError("negative precision"));
            value = precision_arg.int_value;
            break;
          case Arg::UINT:
            value = precision_arg.uint_value;
            break;
          case Arg::LONG_LONG:
            if (precision_arg.long_long_value < 0)
              FMT_THROW(FormatError("negative precision"));
            value = precision_arg.long_long_value;
            break;
          case Arg::ULONG_LONG:
            value = precision_arg.ulong_long_value;
            break;
          default:
            FMT_THROW(FormatError("precision is not integer"));
        }
        if (value > (std::numeric_limits<int>::max)())
          FMT_THROW(FormatError("number is too big"));
        spec.precision_ = static_cast<int>(value);
      } else {
        FMT_THROW(FormatError("missing precision specifier"));
      }
      if (arg.type <= Arg::LAST_INTEGER_TYPE || arg.type == Arg::POINTER) {
        FMT_THROW(FormatError(
            fmt::format("precision not allowed in {} format specifier",
            arg.type == Arg::POINTER ? "pointer" : "integer")));
      }
    }

    // Parse type.
    if (*s != '}' && *s)
      spec.type_ = static_cast<char>(*s++);
  }

  if (*s++ != '}')
    FMT_THROW(FormatError("missing '}' in format string"));

  // Format argument.
  ArgFormatter(*this, spec, s - 1).visit(arg);
  return s;
}

template <typename Char, typename AF>
void BasicFormatter<Char, AF>::format(BasicCStringRef<Char> format_str) {
  const Char *s = format_str.c_str();
  const Char *start = s;
  while (*s) {
    Char c = *s++;
    if (c != '{' && c != '}') continue;
    if (*s == c) {
      write(writer_, start, s);
      start = ++s;
      continue;
    }
    if (c == '}')
      FMT_THROW(FormatError("unmatched '}' in format string"));
    write(writer_, start, s - 1);
    internal::Arg arg = internal::is_name_start(*s) ?
          parse_arg_name(s) : parse_arg_index(s);
    start = s = format(s, arg);
  }
  write(writer_, start, s);
}

template <typename Char, typename It>
struct ArgJoin {
  It first;
  It last;
  BasicCStringRef<Char> sep;

  ArgJoin(It first, It last, const BasicCStringRef<Char>& sep) :
    first(first),
    last(last),
    sep(sep) {}
};

template <typename It>
ArgJoin<char, It> join(It first, It last, const BasicCStringRef<char>& sep) {
  return ArgJoin<char, It>(first, last, sep);
}

template <typename It>
ArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {
  return ArgJoin<wchar_t, It>(first, last, sep);
}

#if FMT_HAS_GXX_CXX11
template <typename Range>
auto join(const Range& range, const BasicCStringRef<char>& sep)
    -> ArgJoin<char, decltype(std::begin(range))> {
  return join(std::begin(range), std::end(range), sep);
}

template <typename Range>
auto join(const Range& range, const BasicCStringRef<wchar_t>& sep)
    -> ArgJoin<wchar_t, decltype(std::begin(range))> {
  return join(std::begin(range), std::end(range), sep);
}
#endif

template <typename ArgFormatter, typename Char, typename It>
void format_arg(fmt::BasicFormatter<Char, ArgFormatter> &f,
    const Char *&format_str, const ArgJoin<Char, It>& e) {
  const Char* end = format_str;
  if (*end == ':')
    ++end;
  while (*end && *end != '}')
    ++end;
  if (*end != '}')
    FMT_THROW(FormatError("missing '}' in format string"));

  It it = e.first;
  if (it != e.last) {
    const Char* save = format_str;
    f.format(format_str, internal::MakeArg<fmt::BasicFormatter<Char, ArgFormatter> >(*it++));
    while (it != e.last) {
      f.writer().write(e.sep);
      format_str = save;
      f.format(format_str, internal::MakeArg<fmt::BasicFormatter<Char, ArgFormatter> >(*it++));
    }
  }
  format_str = end + 1;
}
}  // namespace fmt

#if FMT_USE_USER_DEFINED_LITERALS
namespace fmt {
namespace internal {

template <typename Char>
struct UdlFormat {
  const Char *str;

  template <typename... Args>
  auto operator()(Args && ... args) const
                  -> decltype(format(str, std::forward<Args>(args)...)) {
    return format(str, std::forward<Args>(args)...);
  }
};

template <typename Char>
struct UdlArg {
  const Char *str;

  template <typename T>
  NamedArgWithType<Char, T> operator=(T &&value) const {
    return {str, std::forward<T>(value)};
  }
};

} // namespace internal

inline namespace literals {

/**
  \rst
  C++11 literal equivalent of :func:`fmt::format`.

  **Example**::

    using namespace fmt::literals;
    std::string message = "The answer is {}"_format(42);
  \endrst
 */
inline internal::UdlFormat<char>
operator"" _format(const char *s, std::size_t) { return {s}; }
inline internal::UdlFormat<wchar_t>
operator"" _format(const wchar_t *s, std::size_t) { return {s}; }

/**
  \rst
  C++11 literal equivalent of :func:`fmt::arg`.

  **Example**::

    using namespace fmt::literals;
    print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
  \endrst
 */
inline internal::UdlArg<char>
operator"" _a(const char *s, std::size_t) { return {s}; }
inline internal::UdlArg<wchar_t>
operator"" _a(const wchar_t *s, std::size_t) { return {s}; }

} // inline namespace literals
} // namespace fmt
#endif // FMT_USE_USER_DEFINED_LITERALS

// Restore warnings.
#if FMT_GCC_VERSION >= 406
# pragma GCC diagnostic pop
#endif

#if defined(__clang__) && !defined(FMT_ICC_VERSION)
# pragma clang diagnostic pop
#endif

#ifdef FMT_HEADER_ONLY
# define FMT_FUNC inline
/*
 Formatting library for C++

 Copyright (c) 2012 - 2016, Victor Zverovich
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <string.h>

#include <cctype>
#include <cerrno>
#include <climits>
#include <cmath>
#include <cstdarg>
#include <cstddef>  // for std::ptrdiff_t

#if defined(_WIN32) && defined(__MINGW32__)
# include <cstring>
#endif

#if FMT_USE_WINDOWS_H
# if !defined(FMT_HEADER_ONLY) && !defined(WIN32_LEAN_AND_MEAN)
#  define WIN32_LEAN_AND_MEAN
# endif
# if defined(NOMINMAX) || defined(FMT_WIN_MINMAX)
#  include <windows.h>
# else
#  define NOMINMAX
#  include <windows.h>
#  undef NOMINMAX
# endif
#endif

#if FMT_EXCEPTIONS
# define FMT_TRY try
# define FMT_CATCH(x) catch (x)
#else
# define FMT_TRY if (true)
# define FMT_CATCH(x) if (false)
#endif

#ifdef _MSC_VER
# pragma warning(push)
# pragma warning(disable: 4127)  // conditional expression is constant
# pragma warning(disable: 4702)  // unreachable code
// Disable deprecation warning for strerror. The latter is not called but
// MSVC fails to detect it.
# pragma warning(disable: 4996)
#endif

// Dummy implementations of strerror_r and strerror_s called if corresponding
// system functions are not available.
static inline fmt::internal::Null<> strerror_r(int, char *, ...) {
  return fmt::internal::Null<>();
}
static inline fmt::internal::Null<> strerror_s(char *, std::size_t, ...) {
  return fmt::internal::Null<>();
}

namespace fmt {

FMT_FUNC internal::RuntimeError::~RuntimeError() FMT_DTOR_NOEXCEPT {}
FMT_FUNC FormatError::~FormatError() FMT_DTOR_NOEXCEPT {}
FMT_FUNC SystemError::~SystemError() FMT_DTOR_NOEXCEPT {}

namespace {

#ifndef _MSC_VER
# define FMT_SNPRINTF snprintf
#else  // _MSC_VER
inline int fmt_snprintf(char *buffer, size_t size, const char *format, ...) {
  va_list args;
  va_start(args, format);
  int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
  va_end(args);
  return result;
}
# define FMT_SNPRINTF fmt_snprintf
#endif  // _MSC_VER

#if defined(_WIN32) && defined(__MINGW32__) && !defined(__NO_ISOCEXT)
# define FMT_SWPRINTF snwprintf
#else
# define FMT_SWPRINTF swprintf
#endif // defined(_WIN32) && defined(__MINGW32__) && !defined(__NO_ISOCEXT)

const char RESET_COLOR[] = "\x1b[0m";

typedef void (*FormatFunc)(Writer &, int, StringRef);

// Portable thread-safe version of strerror.
// Sets buffer to point to a string describing the error code.
// This can be either a pointer to a string stored in buffer,
// or a pointer to some static immutable string.
// Returns one of the following values:
//   0      - success
//   ERANGE - buffer is not large enough to store the error message
//   other  - failure
// Buffer should be at least of size 1.
int safe_strerror(
    int error_code, char *&buffer, std::size_t buffer_size) FMT_NOEXCEPT {
  FMT_ASSERT(buffer != 0 && buffer_size != 0, "invalid buffer");

  class StrError {
   private:
    int error_code_;
    char *&buffer_;
    std::size_t buffer_size_;

    // A noop assignment operator to avoid bogus warnings.
    void operator=(const StrError &) {}

    // Handle the result of XSI-compliant version of strerror_r.
    int handle(int result) {
      // glibc versions before 2.13 return result in errno.
      return result == -1 ? errno : result;
    }

    // Handle the result of GNU-specific version of strerror_r.
    int handle(char *message) {
      // If the buffer is full then the message is probably truncated.
      if (message == buffer_ && strlen(buffer_) == buffer_size_ - 1)
        return ERANGE;
      buffer_ = message;
      return 0;
    }

    // Handle the case when strerror_r is not available.
    int handle(internal::Null<>) {
      return fallback(strerror_s(buffer_, buffer_size_, error_code_));
    }

    // Fallback to strerror_s when strerror_r is not available.
    int fallback(int result) {
      // If the buffer is full then the message is probably truncated.
      return result == 0 && strlen(buffer_) == buffer_size_ - 1 ?
            ERANGE : result;
    }

    // Fallback to strerror if strerror_r and strerror_s are not available.
    int fallback(internal::Null<>) {
      errno = 0;
      buffer_ = strerror(error_code_);
      return errno;
    }

   public:
    StrError(int err_code, char *&buf, std::size_t buf_size)
      : error_code_(err_code), buffer_(buf), buffer_size_(buf_size) {}

    int run() {
      // Suppress a warning about unused strerror_r.
      strerror_r(0, FMT_NULL, "");
      return handle(strerror_r(error_code_, buffer_, buffer_size_));
    }
  };
  return StrError(error_code, buffer, buffer_size).run();
}

void format_error_code(Writer &out, int error_code,
                       StringRef message) FMT_NOEXCEPT {
  // Report error code making sure that the output fits into
  // INLINE_BUFFER_SIZE to avoid dynamic memory allocation and potential
  // bad_alloc.
  out.clear();
  static const char SEP[] = ": ";
  static const char ERROR_STR[] = "error ";
  // Subtract 2 to account for terminating null characters in SEP and ERROR_STR.
  std::size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
  typedef internal::IntTraits<int>::MainType MainType;
  MainType abs_value = static_cast<MainType>(error_code);
  if (internal::is_negative(error_code)) {
    abs_value = 0 - abs_value;
    ++error_code_size;
  }
  error_code_size += internal::count_digits(abs_value);
  if (message.size() <= internal::INLINE_BUFFER_SIZE - error_code_size)
    out << message << SEP;
  out << ERROR_STR << error_code;
  assert(out.size() <= internal::INLINE_BUFFER_SIZE);
}

void report_error(FormatFunc func, int error_code,
                  StringRef message) FMT_NOEXCEPT {
  MemoryWriter full_message;
  func(full_message, error_code, message);
  // Use Writer::data instead of Writer::c_str to avoid potential memory
  // allocation.
  std::fwrite(full_message.data(), full_message.size(), 1, stderr);
  std::fputc('\n', stderr);
}
}  // namespace

FMT_FUNC void SystemError::init(
    int err_code, CStringRef format_str, ArgList args) {
  error_code_ = err_code;
  MemoryWriter w;
  format_system_error(w, err_code, format(format_str, args));
  std::runtime_error &base = *this;
  base = std::runtime_error(w.str());
}

template <typename T>
int internal::CharTraits<char>::format_float(
    char *buffer, std::size_t size, const char *format,
    unsigned width, int precision, T value) {
  if (width == 0) {
    return precision < 0 ?
        FMT_SNPRINTF(buffer, size, format, value) :
        FMT_SNPRINTF(buffer, size, format, precision, value);
  }
  return precision < 0 ?
      FMT_SNPRINTF(buffer, size, format, width, value) :
      FMT_SNPRINTF(buffer, size, format, width, precision, value);
}

template <typename T>
int internal::CharTraits<wchar_t>::format_float(
    wchar_t *buffer, std::size_t size, const wchar_t *format,
    unsigned width, int precision, T value) {
  if (width == 0) {
    return precision < 0 ?
        FMT_SWPRINTF(buffer, size, format, value) :
        FMT_SWPRINTF(buffer, size, format, precision, value);
  }
  return precision < 0 ?
      FMT_SWPRINTF(buffer, size, format, width, value) :
      FMT_SWPRINTF(buffer, size, format, width, precision, value);
}

template <typename T>
const char internal::BasicData<T>::DIGITS[] =
    "0001020304050607080910111213141516171819"
    "2021222324252627282930313233343536373839"
    "4041424344454647484950515253545556575859"
    "6061626364656667686970717273747576777879"
    "8081828384858687888990919293949596979899";

#define FMT_POWERS_OF_10(factor) \
  factor * 10, \
  factor * 100, \
  factor * 1000, \
  factor * 10000, \
  factor * 100000, \
  factor * 1000000, \
  factor * 10000000, \
  factor * 100000000, \
  factor * 1000000000

template <typename T>
const uint32_t internal::BasicData<T>::POWERS_OF_10_32[] = {
  0, FMT_POWERS_OF_10(1)
};

template <typename T>
const uint64_t internal::BasicData<T>::POWERS_OF_10_64[] = {
  0,
  FMT_POWERS_OF_10(1),
  FMT_POWERS_OF_10(ULongLong(1000000000)),
  // Multiply several constants instead of using a single long long constant
  // to avoid warnings about C++98 not supporting long long.
  ULongLong(1000000000) * ULongLong(1000000000) * 10
};

FMT_FUNC void internal::report_unknown_type(char code, const char *type) {
  (void)type;
  if (std::isprint(static_cast<unsigned char>(code))) {
    FMT_THROW(FormatError(
        format("unknown format code '{}' for {}", code, type)));
  }
  FMT_THROW(FormatError(
      format("unknown format code '\\x{:02x}' for {}",
        static_cast<unsigned>(code), type)));
}

#if FMT_USE_WINDOWS_H

FMT_FUNC internal::UTF8ToUTF16::UTF8ToUTF16(StringRef s) {
  static const char ERROR_MSG[] = "cannot convert string from UTF-8 to UTF-16";
  if (s.size() > INT_MAX)
    FMT_THROW(WindowsError(ERROR_INVALID_PARAMETER, ERROR_MSG));
  int s_size = static_cast<int>(s.size());
  int length = MultiByteToWideChar(
      CP_UTF8, MB_ERR_INVALID_CHARS, s.data(), s_size, FMT_NULL, 0);
  if (length == 0)
    FMT_THROW(WindowsError(GetLastError(), ERROR_MSG));
  buffer_.resize(length + 1);
  length = MultiByteToWideChar(
    CP_UTF8, MB_ERR_INVALID_CHARS, s.data(), s_size, &buffer_[0], length);
  if (length == 0)
    FMT_THROW(WindowsError(GetLastError(), ERROR_MSG));
  buffer_[length] = 0;
}

FMT_FUNC internal::UTF16ToUTF8::UTF16ToUTF8(WStringRef s) {
  if (int error_code = convert(s)) {
    FMT_THROW(WindowsError(error_code,
        "cannot convert string from UTF-16 to UTF-8"));
  }
}

FMT_FUNC int internal::UTF16ToUTF8::convert(WStringRef s) {
  if (s.size() > INT_MAX)
    return ERROR_INVALID_PARAMETER;
  int s_size = static_cast<int>(s.size());
  int length = WideCharToMultiByte(
    CP_UTF8, 0, s.data(), s_size, FMT_NULL, 0, FMT_NULL, FMT_NULL);
  if (length == 0)
    return GetLastError();
  buffer_.resize(length + 1);
  length = WideCharToMultiByte(
    CP_UTF8, 0, s.data(), s_size, &buffer_[0], length, FMT_NULL, FMT_NULL);
  if (length == 0)
    return GetLastError();
  buffer_[length] = 0;
  return 0;
}

FMT_FUNC void WindowsError::init(
    int err_code, CStringRef format_str, ArgList args) {
  error_code_ = err_code;
  MemoryWriter w;
  internal::format_windows_error(w, err_code, format(format_str, args));
  std::runtime_error &base = *this;
  base = std::runtime_error(w.str());
}

FMT_FUNC void internal::format_windows_error(
    Writer &out, int error_code, StringRef message) FMT_NOEXCEPT {
  FMT_TRY {
    MemoryBuffer<wchar_t, INLINE_BUFFER_SIZE> buffer;
    buffer.resize(INLINE_BUFFER_SIZE);
    for (;;) {
      wchar_t *system_message = &buffer[0];
      int result = FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        FMT_NULL, error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        system_message, static_cast<uint32_t>(buffer.size()), FMT_NULL);
      if (result != 0) {
        UTF16ToUTF8 utf8_message;
        if (utf8_message.convert(system_message) == ERROR_SUCCESS) {
          out << message << ": " << utf8_message;
          return;
        }
        break;
      }
      if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        break;  // Can't get error message, report error code instead.
      buffer.resize(buffer.size() * 2);
    }
  } FMT_CATCH(...) {}
  fmt::format_error_code(out, error_code, message);  // 'fmt::' is for bcc32.
}

#endif  // FMT_USE_WINDOWS_H

FMT_FUNC void format_system_error(
    Writer &out, int error_code, StringRef message) FMT_NOEXCEPT {
  FMT_TRY {
    internal::MemoryBuffer<char, internal::INLINE_BUFFER_SIZE> buffer;
    buffer.resize(internal::INLINE_BUFFER_SIZE);
    for (;;) {
      char *system_message = &buffer[0];
      int result = safe_strerror(error_code, system_message, buffer.size());
      if (result == 0) {
        out << message << ": " << system_message;
        return;
      }
      if (result != ERANGE)
        break;  // Can't get error message, report error code instead.
      buffer.resize(buffer.size() * 2);
    }
  } FMT_CATCH(...) {}
  fmt::format_error_code(out, error_code, message);  // 'fmt::' is for bcc32.
}

template <typename Char>
void internal::ArgMap<Char>::init(const ArgList &args) {
  if (!map_.empty())
    return;
  typedef internal::NamedArg<Char> NamedArg;
  const NamedArg *named_arg = FMT_NULL;
  bool use_values =
      args.type(ArgList::MAX_PACKED_ARGS - 1) == internal::Arg::NONE;
  if (use_values) {
    for (unsigned i = 0;/*nothing*/; ++i) {
      internal::Arg::Type arg_type = args.type(i);
      switch (arg_type) {
      case internal::Arg::NONE:
        return;
      case internal::Arg::NAMED_ARG:
        named_arg = static_cast<const NamedArg*>(args.values_[i].pointer);
        map_.push_back(Pair(named_arg->name, *named_arg));
        break;
      default:
        /*nothing*/;
      }
    }
    return;
  }
  for (unsigned i = 0; i != ArgList::MAX_PACKED_ARGS; ++i) {
    internal::Arg::Type arg_type = args.type(i);
    if (arg_type == internal::Arg::NAMED_ARG) {
      named_arg = static_cast<const NamedArg*>(args.args_[i].pointer);
      map_.push_back(Pair(named_arg->name, *named_arg));
    }
  }
  for (unsigned i = ArgList::MAX_PACKED_ARGS;/*nothing*/; ++i) {
    switch (args.args_[i].type) {
    case internal::Arg::NONE:
      return;
    case internal::Arg::NAMED_ARG:
      named_arg = static_cast<const NamedArg*>(args.args_[i].pointer);
      map_.push_back(Pair(named_arg->name, *named_arg));
      break;
    default:
      /*nothing*/;
    }
  }
}

template <typename Char>
void internal::FixedBuffer<Char>::grow(std::size_t) {
  FMT_THROW(std::runtime_error("buffer overflow"));
}

FMT_FUNC internal::Arg internal::FormatterBase::do_get_arg(
    unsigned arg_index, const char *&error) {
  internal::Arg arg = args_[arg_index];
  switch (arg.type) {
  case internal::Arg::NONE:
    error = "argument index out of range";
    break;
  case internal::Arg::NAMED_ARG:
    arg = *static_cast<const internal::Arg*>(arg.pointer);
    break;
  default:
    /*nothing*/;
  }
  return arg;
}

FMT_FUNC void report_system_error(
    int error_code, fmt::StringRef message) FMT_NOEXCEPT {
  // 'fmt::' is for bcc32.
  report_error(format_system_error, error_code, message);
}

#if FMT_USE_WINDOWS_H
FMT_FUNC void report_windows_error(
    int error_code, fmt::StringRef message) FMT_NOEXCEPT {
  // 'fmt::' is for bcc32.
  report_error(internal::format_windows_error, error_code, message);
}
#endif

FMT_FUNC void print(std::FILE *f, CStringRef format_str, ArgList args) {
  MemoryWriter w;
  w.write(format_str, args);
  std::fwrite(w.data(), 1, w.size(), f);
}

FMT_FUNC void print(CStringRef format_str, ArgList args) {
  print(stdout, format_str, args);
}

FMT_FUNC void print_colored(Color c, CStringRef format, ArgList args) {
  char escape[] = "\x1b[30m";
  escape[3] = static_cast<char>('0' + c);
  std::fputs(escape, stdout);
  print(format, args);
  std::fputs(RESET_COLOR, stdout);
}

#ifndef FMT_HEADER_ONLY

template struct internal::BasicData<void>;

// Explicit instantiations for char.

template void internal::FixedBuffer<char>::grow(std::size_t);

template void internal::ArgMap<char>::init(const ArgList &args);

template FMT_API int internal::CharTraits<char>::format_float(
    char *buffer, std::size_t size, const char *format,
    unsigned width, int precision, double value);

template FMT_API int internal::CharTraits<char>::format_float(
    char *buffer, std::size_t size, const char *format,
    unsigned width, int precision, long double value);

// Explicit instantiations for wchar_t.

template void internal::FixedBuffer<wchar_t>::grow(std::size_t);

template void internal::ArgMap<wchar_t>::init(const ArgList &args);

template FMT_API int internal::CharTraits<wchar_t>::format_float(
    wchar_t *buffer, std::size_t size, const wchar_t *format,
    unsigned width, int precision, double value);

template FMT_API int internal::CharTraits<wchar_t>::format_float(
    wchar_t *buffer, std::size_t size, const wchar_t *format,
    unsigned width, int precision, long double value);

#endif  // FMT_HEADER_ONLY

}  // namespace fmt

#ifdef _MSC_VER
# pragma warning(pop)
#endif
#else
# define FMT_FUNC
#endif

#endif  // FMT_FORMAT_H_

#else //external fmtlib

#include <fmt/format.h>

#endif

namespace spdlog {
class logger;
}

TC_NAMESPACE_BEGIN

#define SPD_AUGMENTED_LOG(X, ...)                                        \
  taichi::logger.X(                                                      \
      fmt::format("[{}:{}@{}] ", __FILENAME__, __FUNCTION__, __LINE__) + \
      fmt::format(__VA_ARGS__))

#define TC_TRACE(...) SPD_AUGMENTED_LOG(trace, __VA_ARGS__)
#define TC_DEBUG(...) SPD_AUGMENTED_LOG(debug, __VA_ARGS__)
#define TC_INFO(...) SPD_AUGMENTED_LOG(info, __VA_ARGS__)
#define TC_WARN(...) SPD_AUGMENTED_LOG(warn, __VA_ARGS__)
#define TC_ERROR(...) SPD_AUGMENTED_LOG(error, __VA_ARGS__)
#define TC_CRITICAL(...) SPD_AUGMENTED_LOG(critical, __VA_ARGS__)

#define TC_TRACE_IF(condition, ...) \
  if (condition) {                  \
    TC_TRACE(__VA_ARGS__);          \
  }
#define TC_TRACE_UNLESS(condition, ...) \
  if (!(condition)) {                   \
    TC_TRACE(__VA_ARGS__);              \
  }
#define TC_DEBUG_IF(condition, ...) \
  if (condition) {                  \
    TC_DEBUG(__VA_ARGS__);          \
  }
#define TC_DEBUG_UNLESS(condition, ...) \
  if (!(condition)) {                   \
    TC_DEBUG(__VA_ARGS__);              \
  }
#define TC_INFO_IF(condition, ...) \
  if (condition) {                 \
    TC_INFO(__VA_ARGS__);          \
  }
#define TC_INFO_UNLESS(condition, ...) \
  if (!(condition)) {                  \
    TC_INFO(__VA_ARGS__);              \
  }
#define TC_WARN_IF(condition, ...) \
  if (condition) {                 \
    TC_WARN(__VA_ARGS__);          \
  }
#define TC_WARN_UNLESS(condition, ...) \
  if (!(condition)) {                  \
    TC_WARN(__VA_ARGS__);              \
  }
#define TC_ERROR_IF(condition, ...) \
  if (condition) {                  \
    TC_ERROR(__VA_ARGS__);          \
  }
#define TC_ERROR_UNLESS(condition, ...) \
  if (!(condition)) {                   \
    TC_ERROR(__VA_ARGS__);              \
  }
#define TC_CRITICAL_IF(condition, ...) \
  if (condition) {                     \
    TC_CRITICAL(__VA_ARGS__);          \
  }
#define TC_CRITICAL_UNLESS(condition, ...) \
  if (!(condition)) {                      \
    TC_CRITICAL(__VA_ARGS__);              \
  }

#define TC_STOP TC_ERROR("Stopping here")
#define TC_TAG TC_TRACE("Tagging here")

#define TC_LOG_SET_PATTERN(x) spdlog::set_pattern(x);

#define TC_FLUSH_LOGGER \
  { taichi::logger.flush(); };

class Logger {
  std::shared_ptr<spdlog::logger> console;

 public:
  Logger();
  void trace(const std::string &s);
  void debug(const std::string &s);
  void info(const std::string &s);
  void warn(const std::string &s);
  void error(const std::string &s, bool raise_signal = true);
  void critical(const std::string &s, bool raise_signal = true);
  void flush();
  void set_level(const std::string &level);
};

extern Logger logger;

namespace zip {

void write(std::string fn, const uint8 *data, std::size_t len);
void write(const std::string &fn, const std::string &data);
std::vector<uint8> read(const std::string fn, bool verbose = false);

}  // namespace zip

//******************************************************************************
//                               String Utils
//******************************************************************************

inline std::vector<std::string> split_string(const std::string &s,
                                             const std::string &seperators) {
  std::vector<std::string> ret;
  bool is_seperator[256] = {false};
  for (auto &ch : seperators) {
    is_seperator[(unsigned int)ch] = true;
  }
  int begin = 0;
  for (int i = 0; i <= (int)s.size(); i++) {
    if (is_seperator[(uint8)s[i]] || i == (int)s.size()) {
      ret.push_back(std::string(s.begin() + begin, s.begin() + i));
      begin = i + 1;
    }
  }
  return ret;
}

inline std::string trim_string(const std::string &s) {
  int begin = 0, end = (int)s.size();
  while (begin < end && s[begin] == ' ') {
    begin++;
  }
  while (begin < end && s[end - 1] == ' ') {
    end--;
  }
  return std::string(s.begin() + begin, s.begin() + end);
}

inline bool ends_with(std::string const &str, std::string const &ending) {
  if (ending.size() > str.size())
    return false;
  else
    return std::equal(ending.begin(), ending.end(), str.end() - ending.size());
}

TC_NAMESPACE_END

//******************************************************************************
//                               Serialization
//******************************************************************************

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <map>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <vector>
#include <memory>
#include <cstring>
#include <cassert>
#include <iostream>
#include <type_traits>

#ifdef TC_INCLUDED
TC_NAMESPACE_BEGIN
#else
#define TC_NAMESPACE_BEGIN
#define TC_NAMESPACE_END
#define TC_EXPORT
#define TC_TRACE
#define TC_CRITICAL
#define TC_ASSERT assert
#endif

template <typename T>
TC_EXPORT std::unique_ptr<T> create_instance_unique(const std::string &alias);

////////////////////////////////////////////////////////////////////////////////
//                   A Minimalist Serializer for Taichi                       //
//                           (C++11 Compatible)                               //
////////////////////////////////////////////////////////////////////////////////

class Unit;

namespace type {

template <typename T>
using remove_cvref =
    typename std::remove_cv<typename std::remove_reference<T>::type>;

template <typename T>
using remove_cvref_t = typename remove_cvref<T>::type;

template <typename T>
using is_unit = typename std::is_base_of<Unit, remove_cvref_t<T>>;

template <typename T>
using is_unit_t = typename is_unit<T>::type;
}  // namespace type

#define TC_IO_DECL_INST                               \
  void binary_io(BinaryOutputSerializer &ser) const { \
    ser(*this);                                       \
  }                                                   \
  void binary_io(BinaryInputSerializer &ser) const {  \
    ser(*this);                                       \
  }

#define TC_IO_DECL_INST_VIRT                                  \
  virtual void binary_io(BinaryOutputSerializer &ser) const { \
    ser(*this);                                               \
  }                                                           \
  virtual void binary_io(BinaryInputSerializer &ser) const {  \
    ser(*this);                                               \
  }

#define TC_IO_DECL_INST_VIRT_OVERRIDE                                  \
  virtual void binary_io(BinaryOutputSerializer &ser) const override { \
    ser(*this);                                                        \
  }                                                                    \
  virtual void binary_io(BinaryInputSerializer &ser) const override {  \
    ser(*this);                                                        \
  }

#define TC_IO_DECL      \
  TC_IO_DECL_INST       \
  template <typename S> \
  void io(S &serializer) const

#define TC_IO_DECL_VIRT \
  TC_IO_DECL_INST_VIRT  \
  template <typename S> \
  void io(S &serializer) const

#define TC_IO_DECL_VIRT_OVERRIDE \
  TC_IO_DECL_INST_VIRT_OVERRIDE  \
  template <typename S>          \
  void io(S &serializer) const

#define TC_IO_DEF(...)           \
  TC_IO_DECL_INST                \
  template <typename S>          \
  void io(S &serializer) const { \
    TC_IO(__VA_ARGS__)           \
  }

#define TC_IO_DEF_VIRT(...)      \
  TC_IO_DECL_INST_VIRT           \
  template <typename S>          \
  void io(S &serializer) const { \
    TC_IO(__VA_ARGS__)           \
  }

#define TC_IO_DEF_WITH_BASE(...) \
  TC_IO_DECL_INST_VIRT_OVERRIDE  \
  template <typename S>          \
  void io(S &serializer) const { \
    Base::io(serializer);        \
    TC_IO(__VA_ARGS__)           \
  }

#define TC_IO(...) \
  { serializer(#__VA_ARGS__, __VA_ARGS__); }

#define TC_SERIALIZER_IS(T)                                                 \
  (std::is_same<typename std::remove_reference<decltype(serializer)>::type, \
                T>())

static_assert(
    sizeof(std::size_t) == sizeof(uint64_t),
    "sizeof(std::size_t) should be 8. Try compiling with 64bit mode.");

template <typename T, typename S>
struct IO {
  using implemented = std::false_type;
};

class Serializer {
 public:
  template <typename T, std::size_t n>
  using TArray = T[n];
  template <typename T, std::size_t n>
  using StdTArray = std::array<T, n>;

  std::unordered_map<std::size_t, void *> assets;

  template <typename T, typename T_ = typename type::remove_cvref_t<T>>
  static T_ &get_writable(T &&t) {
    return *const_cast<T_ *>(&t);
  }

  template <typename T>
  struct has_io {
    template <typename T_>
    static constexpr auto helper(T_ *) -> std::is_same<
        decltype((std::declval<T_>().io(std::declval<Serializer &>()))),
        void>;

    template <typename>
    static constexpr auto helper(...) -> std::false_type;

   public:
    using T__ = typename type::remove_cvref_t<T>;
    using type = decltype(helper<T__>(nullptr));
    static constexpr bool value = type::value;
  };

  template <typename T>
  struct has_free_io {
    template <typename T_>
    static constexpr auto helper(T_ *) ->
        typename IO<T_, Serializer>::implemented;

    template <typename>
    static constexpr auto helper(...) -> std::false_type;

   public:
    using T__ = typename type::remove_cvref_t<T>;
    using type = decltype(helper<T__>(nullptr));
    static constexpr bool value = type::value;
  };
};

inline std::vector<uint8> read_data_from_file(const std::string &fn) {
  std::vector<uint8_t> data;
  std::FILE *f = fopen(fn.c_str(), "rb");
  if (f == nullptr) {
    TC_ERROR("Cannot open file: {}", fn);
    return std::vector<uint8_t>();
  }
  if (ends_with(fn, ".zip")) {
    std::fclose(f);
    // Read zip file, e.g. particles.tcb.zip
    return zip::read(fn);
  } else {
    // Read uncompressed file, e.g. particles.tcb
    assert(f != nullptr);
    std::size_t length = 0;
    while (true) {
      size_t limit = 1 << 8;
      data.resize(data.size() + limit);
      void *ptr = reinterpret_cast<void *>(&data[length]);
      size_t length_tmp = fread(ptr, sizeof(uint8_t), limit, f);
      length += length_tmp;
      if (length_tmp < limit) {
        break;
      }
    }
    std::fclose(f);
    data.resize(length);
    return data;
  }
}

inline void write_data_to_file(const std::string &fn, uint8_t *data, std::size_t size) {
  std::FILE *f = fopen(fn.c_str(), "wb");
  if (f == nullptr) {
    TC_ERROR(
        "Can not open file [{}] for writing. (Does the directory exist?)",
        fn);
    assert(f != nullptr);
  }
  if (ends_with(fn, ".tcb.zip")) {
    std::fclose(f);
    zip::write(fn, data, size);
  } else if (ends_with(fn, ".tcb")) {
    fwrite(data, sizeof(uint8_t), size, f);
    std::fclose(f);
  } else {
    TC_ERROR("File must end with .tcb or .tcb.zip. [Filename = {}]", fn);
  }
}

template <bool writing>
class BinarySerializer : public Serializer {
 public:
  std::vector<uint8_t> data;
  uint8_t *c_data;

  std::size_t head;
  std::size_t preserved;

  using Base = Serializer;
  using Base::assets;

  template <bool writing_ = writing>
  typename std::enable_if<!writing_, void>::type initialize(
      const std::string &fn) {
    data = read_data_from_file(fn);
    c_data = reinterpret_cast<uint8_t *>(&data[0]);
    head = sizeof(std::size_t);
  }

  void write_to_file(const std::string &fn) {
    void *ptr = c_data;
    if (!ptr) {
      assert(!data.empty());
      ptr = &data[0];
    }
    write_data_to_file(fn, reinterpret_cast<uint8_t *>(ptr), head);
  }

  template <bool writing_ = writing>
  typename std::enable_if<writing_, void>::type initialize(
      std::size_t preserved_ = std::size_t(0),
      void *c_data = nullptr) {
    std::size_t n = 0;
    head = 0;
    if (preserved_ != 0) {
      TC_TRACE("perserved = {}", preserved_);
      // Preserved mode
      this->preserved = preserved_;
      assert(c_data != nullptr);
      this->c_data = (uint8_t *)c_data;
    } else {
      // otherwise use a std::vector<uint8_t>
      this->preserved = 0;
      this->c_data = nullptr;
    }
    this->operator()("", n);
  }

  template <bool writing_ = writing>
  typename std::enable_if<!writing_, void>::type initialize(
      void *raw_data,
      std::size_t preserved_ = std::size_t(0)) {
    if (preserved_ != 0) {
      assert(raw_data == nullptr);
      data.resize(preserved_);
      c_data = &data[0];
    } else {
      assert(raw_data != nullptr);
      c_data = reinterpret_cast<uint8_t *>(raw_data);
    }
    head = sizeof(std::size_t);
    preserved = 0;
  }

  void finalize() {
    if (writing) {
      if (c_data) {
        *reinterpret_cast<std::size_t *>(&c_data[0]) = head;
      } else {
        *reinterpret_cast<std::size_t *>(&data[0]) = head;
      }
    } else {
      assert(head == *reinterpret_cast<std::size_t *>(c_data));
    }
  }

  // std::string
  void operator()(const char *, const std::string &val_) {
    auto &val = get_writable(val_);
    if (writing) {
      std::vector<char> val_vector(val.begin(), val.end());
      this->operator()(nullptr, val_vector);
    } else {
      std::vector<char> val_vector;
      this->operator()(nullptr, val_vector);
      val = std::string(val_vector.begin(), val_vector.end());
    }
  }

  // C-array
  template <typename T, std::size_t n>
  void operator()(const char *, const TArray<T, n> &val) {
    if (writing) {
      for (std::size_t i = 0; i < n; i++) {
        this->operator()("", val[i]);
      }
    } else {
      // TODO: why do I have to let it write to tmp, otherwise I get Sig Fault?
      // Take care of std::vector<bool> ...
      using Traw = typename type::remove_cvref_t<T>;
      std::vector<
          std::conditional_t<std::is_same<Traw, bool>::value, uint8, Traw>>
          tmp(n);
      for (std::size_t i = 0; i < n; i++) {
        this->operator()("", tmp[i]);
      }
      std::memcpy(const_cast<typename std::remove_cv<T>::type *>(val), &tmp[0],
                  sizeof(tmp[0]) * tmp.size());
    }
  }

  // Elementary data types
  template <typename T>
  typename std::enable_if<!has_io<T>::value && !std::is_pointer<T>::value,
                          void>::type
  operator()(const char *, const T &val) {
    static_assert(!std::is_reference<T>::value, "T cannot be reference");
    static_assert(!std::is_const<T>::value, "T cannot be const");
    static_assert(!std::is_volatile<T>::value, "T cannot be volatile");
    static_assert(!std::is_pointer<T>::value, "T cannot be pointer");
    if (writing) {
      std::size_t new_size = head + sizeof(T);
      if (c_data) {
        if (new_size > preserved) {
          TC_CRITICAL("Preserved Buffer (size {}) Overflow.", preserved);
        }
        //*reinterpret_cast<typename type::remove_cvref_t<T> *>(&c_data[head]) =
        //    val;
        std::memcpy(&c_data[head], &val, sizeof(T));
      } else {
        data.resize(new_size);
        //*reinterpret_cast<typename type::remove_cvref_t<T> *>(&data[head]) =
        //    val;
        std::memcpy(&data[head], &val, sizeof(T));
      }
    } else {
      // get_writable(val) =
      //    *reinterpret_cast<typename std::remove_reference<T>::type *>(
      //        &c_data[head]);
      std::memcpy(&get_writable(val), &c_data[head], sizeof(T));
    }
    head += sizeof(T);
  }

  template <typename T>
  typename std::enable_if<has_io<T>::value, void>::type operator()(
      const char *,
      const T &val) {
    val.io(*this);
  }

  // Unique Pointers to non-taichi-unit Types
  template <typename T>
  typename std::enable_if<!type::is_unit<T>::value, void>::type operator()(
      const char *,
      const std::unique_ptr<T> &val_) {
    auto &val = get_writable(val_);
    if (writing) {
      this->operator()(ptr_to_int(val.get()));
      if (val.get() != nullptr) {
        this->operator()("", *val);
        // Just for checking future raw pointers
        assets.insert(std::make_pair(ptr_to_int(val.get()), val.get()));
      }
    } else {
      std::size_t original_addr;
      this->operator()("", original_addr);
      if (original_addr != 0) {
        val = std::make_unique<T>();
        assets.insert(std::make_pair(original_addr, val.get()));
        this->operator()("", *val);
      }
    }
  }

  template <typename T>
  std::size_t ptr_to_int(T *t) {
    return reinterpret_cast<std::size_t>(t);
  }

  // Unique Pointers to taichi-unit Types
  template <typename T>
  typename std::enable_if<type::is_unit<T>::value, void>::type operator()(
      const char *,
      const std::unique_ptr<T> &val_) {
    auto &val = get_writable(val_);
    if (writing) {
      this->operator()(val->get_name());
      this->operator()(ptr_to_int(val.get()));
      if (val.get() != nullptr) {
        val->binary_io(*this);
        // Just for checking future raw pointers
        assets.insert(std::make_pair(ptr_to_int(val.get()), val.get()));
      }
    } else {
      std::string name;
      std::size_t original_addr;
      this->operator()("", name);
      this->operator()("", original_addr);
      if (original_addr != 0) {
        val = create_instance_unique<T>(name);
        assets.insert(std::make_pair(original_addr, val.get()));
        val->binary_io(*this);
      }
    }
  }

  // Raw pointers (no ownership)
  template <typename T>
  typename std::enable_if<std::is_pointer<T>::value, void>::type operator()(
      const char *,
      const T &val_) {
    auto &val = get_writable(val_);
    if (writing) {
      this->operator()("", ptr_to_int(val));
      if (val != nullptr) {
        TC_ASSERT_INFO(assets.find(ptr_to_int(val)) != assets.end(),
                       "Cannot find the address with a smart pointer pointing "
                       "to. Make sure the smart pointer is serialized before "
                       "the raw pointer.");
      }
    } else {
      std::size_t val_ptr;
      this->operator()("", val_ptr);
      if (val_ptr != 0) {
        TC_ASSERT(assets.find(val_ptr) != assets.end());
        val = reinterpret_cast<typename std::remove_pointer<T>::type *>(
            assets[val_ptr]);
      }
    }
  }

  // std::vector
  template <typename T>
  void operator()(const char *, const std::vector<T> &val_) {
    auto &val = get_writable(val_);
    if (writing) {
      this->operator()("", val.size());
    } else {
      std::size_t n = 0;
      this->operator()("", n);
      val.resize(n);
    }
    /*
    for (std::size_t i = 0; i < val.size(); i++) {
      printf("i %d\n", i);
      printf("val %d\n", val[i]);
    }

     */
    for (std::size_t i = 0; i < val.size(); i++) {
      this->operator()("", val[i]);
    }
  }

  // std::pair
  template <typename T, typename G>
  void operator()(const char *, const std::pair<T, G> &val) {
    this->operator()(nullptr, val.first);
    this->operator()(nullptr, val.second);
  }

  // std::map
  template <typename T, typename G>
  void operator()(const char *, const std::map<T, G> &val_) {
    auto &val = get_writable(val_);
    if (writing) {
      this->operator()(nullptr, val.size());
      for (auto iter : val) {
        T first = iter.first;
        this->operator()(nullptr, first);
        this->operator()(nullptr, iter.second);
      }
    } else {
      val.clear();
      std::size_t n = 0;
      this->operator()(nullptr, n);
      for (std::size_t i = 0; i < n; i++) {
        std::pair<T, G> record;
        this->operator()(nullptr, record);
        val.insert(record);
      }
    }
  }

  template <typename T, typename... Args>
  void operator()(const char *, const T &t, Args &&... rest) {
    this->operator()(nullptr, t);
    this->operator()(nullptr, std::forward<Args>(rest)...);
  }

  template <typename T>
  void operator()(const T &val) {
    this->operator()(nullptr, val);
  }
};

using BinaryOutputSerializer = BinarySerializer<true>;
using BinaryInputSerializer = BinarySerializer<false>;

class TextSerializer : public Serializer {
 public:
  std::string data;
  void print() const {
    std::cout << data << std::endl;
  }

  void write_to_file(const std::string &file_name) {
    std::ofstream fs(file_name);
    fs << data;
    fs.close();
  }

 private:
  int indent;
  static constexpr int indent_width = 2;
  bool first_line;

 public:
  TextSerializer() {
    indent = 0;
    first_line = false;
  }

  void add_line(const std::string &str) {
    if (first_line) {
      first_line = false;
    } else {
      data += "\n";
    }
    data += std::string(indent_width * indent, ' ') + str;
  }

  void add_line(const std::string &key, const std::string &value) {
    add_line(key + ": " + value);
  }

  template <typename T>
  static std::string serialize(const char *key, const T &t) {
    TextSerializer ser;
    ser(key, t);
    return ser.data;
  }

  void operator()(const char *key, const std::string &val) {
    add_line(std::string(key) + ": " + val);
  }

  template <typename T, std::size_t n>
  using is_compact =
      typename std::integral_constant<bool,
                                      std::is_arithmetic<T>::value && (n < 7)>;

  // C-array
  template <typename T, std::size_t n>
  typename std::enable_if<is_compact<T, n>::value, void>::type operator()(
      const char *key,
      const TArray<T, n> &val) {
    std::stringstream ss;
    ss << "[";
    for (std::size_t i = 0; i < n; i++) {
      ss << val[i];
      if (i != n - 1) {
        ss << ", ";
      }
    }
    ss << "]";
    add_line(key, ss.str());
  }

  // C-array
  template <typename T, std::size_t n>
  typename std::enable_if<!is_compact<T, n>::value, void>::type operator()(
      const char *key,
      const TArray<T, n> &val) {
    add_line(key, "[");
    indent++;
    for (std::size_t i = 0; i < n; i++) {
      this->operator()(("[" + std::to_string(i) + "]").c_str(), val[i]);
    }
    indent--;
    add_line("]");
  }

  // std::array
  template <typename T, std::size_t n>
  typename std::enable_if<is_compact<T, n>::value, void>::type operator()(
      const char *key,
      const StdTArray<T, n> &val) {
    std::stringstream ss;
    ss << "[";
    for (std::size_t i = 0; i < n; i++) {
      ss << val[i];
      if (i != n - 1) {
        ss << ", ";
      }
    }
    ss << "]";
    add_line(key, ss.str());
  }

  // std::array
  template <typename T, std::size_t n>
  typename std::enable_if<!is_compact<T, n>::value, void>::type operator()(
      const char *key,
      const StdTArray<T, n> &val) {
    add_line(key, "[");
    indent++;
    for (std::size_t i = 0; i < n; i++) {
      this->operator()(("[" + std::to_string(i) + "]").c_str(), val[i]);
    }
    indent--;
    add_line("]");
  }

  // Elementary data types
  template <typename T>
  typename std::enable_if<!has_io<T>::value && !has_free_io<T>::value,
                          void>::type
  operator()(const char *key, const T &val) {
    static_assert(!has_io<T>::value, "");
    std::stringstream ss;
    ss << std::boolalpha << val;
    add_line(key, ss.str());
  }

  template <typename T>
  typename std::enable_if<has_io<T>::value, void>::type operator()(
      const char *key,
      const T &val) {
    add_line(key, "{");
    indent++;
    val.io(*this);
    indent--;
    add_line("}");
  }

  template <typename T>
  typename std::enable_if<has_free_io<T>::value, void>::type operator()(
      const char *key,
      const T &val) {
    add_line(key, "{");
    indent++;
    IO<typename type::remove_cvref_t<T>, decltype(*this)>()(*this, val);
    indent--;
    add_line("}");
  }

  template <typename T>
  void operator()(const char *key, const std::vector<T> &val) {
    add_line(key, "[");
    indent++;
    for (std::size_t i = 0; i < val.size(); i++) {
      this->operator()(("[" + std::to_string(i) + "]").c_str(), val[i]);
    }
    indent--;
    add_line("]");
  }

  template <typename T, typename G>
  void operator()(const char *key, const std::pair<T, G> &val) {
    add_line(key, "(");
    indent++;
    this->operator()("[0]", val.first);
    this->operator()("[1]", val.second);
    indent--;
    add_line(")");
  }

  template <typename T, typename G>
  void operator()(const char *key, const std::map<T, G> &val) {
    add_line(key, "{");
    indent++;
    for (auto iter : val) {
      T first = iter.first;
      this->operator()("key", first);
      this->operator()("value", iter.second);
    }
    indent--;
    add_line("}");
  }

  template <typename T, typename... Args>
  void operator()(const char *key_, const T &t, Args &&... rest) {
    std::string key(key_);
    size_t pos = key.find(",");
    std::string first_name = key.substr(0, pos);
    std::string rest_names =
        key.substr(pos + 2, int(key.size()) - (int)pos - 2);
    this->operator()(first_name.c_str(), t);
    this->operator()(rest_names.c_str(), std::forward<Args>(rest)...);
  }
};

template <typename T>
typename std::enable_if<Serializer::has_io<T>::value, std::ostream &>::type
operator<<(std::ostream &os, const T &t) {
  os << TextSerializer::serialize("value", t);
  return os;
}

template <typename T>
void read_from_binary_file(T &t, const std::string &file_name) {
  BinaryInputSerializer reader;
  reader.initialize(file_name);
  reader(t);
  reader.finalize();
}

template <typename T>
void write_to_binary_file(const T &t, const std::string &file_name) {
  BinaryOutputSerializer writer;
  writer.initialize();
  writer(t);
  writer.finalize();
  writer.write_to_file(file_name);
}

// Compile-Time Tests
static_assert(std::is_same<decltype(Serializer::get_writable(
                               std::declval<const std::vector<int> &>())),
                           std::vector<int> &>(),
              "");

static_assert(
    std::is_same<
        decltype(Serializer::get_writable(
            std::declval<const std::vector<std::unique_ptr<int>> &>())),
        std::vector<std::unique_ptr<int>> &>(),
    "");

TC_NAMESPACE_END

//******************************************************************************
//                                   Misc.
//******************************************************************************

TC_NAMESPACE_BEGIN

extern int __trash__;
template <typename T>
void trash(T &&t) {
  static_assert(!std::is_same<T, void>::value, "");
  __trash__ = *reinterpret_cast<uint8 *>(&t);
}

class DeferedExecution {
  std::function<void(void)> statement;

public:
  DeferedExecution(const std::function<void(void)> &statement)
      : statement(statement) {
  }

  ~DeferedExecution() {
    statement();
  }
};

#define TC_DEFER(x) taichi::DeferedExecution _defered([&]() {x;});

inline std::string absolute_path(std::string path) {
  if (path[0] != '.') {
    path = std::string(std::getenv("TAICHI_REPO_DIR")) + "/" + path;
  }
  return path;
}

TC_NAMESPACE_END

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <cstring>
#include <string>
#include <map>
#include <functional>
#include <memory>
#include <iostream>

TC_NAMESPACE_BEGIN

class AssetManager {
 public:
  // Note: this is not thread safe!
  template <typename T>
  std::shared_ptr<T> get_asset_(int id) {
    assert_info(id_to_asset.find(id) != id_to_asset.end(), "Asset not found");
    auto ptr = id_to_asset[id];
    assert_info(!ptr.expired(), "Asset has been expired");
    return std::static_pointer_cast<T>(ptr.lock());
  }

  template <typename T>
  int insert_asset_(const std::shared_ptr<T> &ptr) {
    if (asset_to_id.find(ptr.get()) != asset_to_id.end()) {
      int existing_id = asset_to_id.find(ptr.get())->second;
      assert_info(id_to_asset[existing_id].expired(), "Asset already exists");
      asset_to_id.erase(ptr.get());
      id_to_asset.erase(existing_id);
    }
    int id = counter++;
    id_to_asset[id] = static_cast<std::weak_ptr<void>>(std::weak_ptr<T>(ptr));
    asset_to_id[ptr.get()] = id;
    return id;
  }

  template <typename T>
  static auto get_asset(int id) {
    return get_instance().get_asset_<T>(id);
  }

  template <typename T>
  static int insert_asset(std::shared_ptr<T> &ptr) {
    return get_instance().insert_asset_<T>(ptr);
  }

  int counter = 0;
  std::map<void *, int> asset_to_id;
  std::map<int, std::weak_ptr<void>> id_to_asset;

  static AssetManager &get_instance() {
    static AssetManager manager;
    return manager;
  }
};

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/



#include <string>
#include <cstdio>
#include <map>
#if defined(TC_PLATFORM_UNIX)
#include <sys/time.h>
#else
#pragma warning(push)
#pragma warning(disable : 4005)
#include <windows.h>
#pragma warning(pop)
#endif

TC_NAMESPACE_BEGIN

#define TIME(x)                                                      \
  {                                                                  \
    char timer_name[1000];                                           \
    sprintf_s(timer_name, "%s[%d]: %s", __FILENAME__, __LINE__, #x); \
    taichi::Time::Timer _(timer_name);                               \
    x;                                                               \
  }
#define TC_TIME(x) TIME(x)

#include <stdint.h>

class Time {
 public:
  static double get_time();

  static uint64 get_cycles();

  static void usleep(double us);
  static void sleep(double s);

  class Timer {
    static std::map<std::string, std::pair<double, int>> memo;

   protected:
    std::string name;
    double start_time;

    virtual double get_time();

    virtual void print_record(const char *left, double elapsed, double average);

    void output();

    bool have_output;

   public:
    Timer(std::string name);

    Timer() {
    }

    virtual ~Timer() {
      output();
    }
  };

  class TickTimer : public Timer {
   protected:
    double get_time();

    void print_record(const char *left, double elapsed, double average);

   public:
    TickTimer(std::string name);

    ~TickTimer() {
      output();
    }
  };

  class FPSCounter {
   public:
    static void count(std::string name) {
      if (last_refresh.find(name) == last_refresh.end()) {
        last_refresh[name] = get_time();
        counter[name] = 0;
      }
      counter[name]++;
      double current_time = get_time();
      if (current_time > 1 + last_refresh[name]) {
        last_refresh[name] = last_refresh[name] + 1;
        printf("FPS [%s]: %d\n", name.c_str(), counter[name]);
        counter[name] = 0;
      }
    }

   private:
    static std::map<std::string, double> last_refresh;
    static std::map<std::string, int> counter;
  };
};

TC_NAMESPACE_END

#ifndef _WIN64

#include <unistd.h>

#endif

TC_NAMESPACE_BEGIN

using namespace std;

std::map<std::string, std::pair<double, int>> Time::Timer::memo;

std::map<std::string, double> Time::FPSCounter::last_refresh;
std::map<std::string, int> Time::FPSCounter::counter;

#if defined(TC_PLATFORM_UNIX)

double Time::get_time() {
  struct timeval tv;
  gettimeofday(&tv, nullptr);
  return tv.tv_sec + 1e-6 * tv.tv_usec;
}

#else
#include <intrin.h>
#pragma intrinsic(__rdtsc)
double Time::get_time() {
  // https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx
  LARGE_INTEGER EndingTime, ElapsedMicroseconds;
  LARGE_INTEGER Frequency;

  QueryPerformanceFrequency(&Frequency);

  // Activity to be timed

  QueryPerformanceCounter(&EndingTime);
  ElapsedMicroseconds.QuadPart = EndingTime.QuadPart;

  ElapsedMicroseconds.QuadPart *= 1000000;
  ElapsedMicroseconds.QuadPart /= Frequency.QuadPart;
  return (double)ElapsedMicroseconds.QuadPart / 1000000.0;

  /*
  FILETIME tm;
  GetSystemTimeAsFileTime(&tm);
  unsigned long long t = ((ULONGLONG)tm.dwHighDateTime << 32) |
  (ULONGLONG)tm.dwLowDateTime;
  return (double)t / 10000000.0;
*/
}
#endif

void Time::usleep(double us) {
#ifdef _WIN64
  Sleep(DWORD(us * 1e-3));
#else
  ::usleep(us);
#endif
}

void Time::sleep(double s) {
  Time::usleep(s * 1e6_f64);
}

double Time::Timer::get_time() {
  return Time::get_time();
}

void Time::Timer::print_record(const char *left,
                               double elapsed,
                               double average) {
  printf("%s ==> %6.2f ms ~ %6.2f ms\n", left, elapsed * 1e3, average * 1e3);
}

void Time::Timer::output() {
  if (have_output) {
    return;
  } else {
    have_output = true;
  }
  double elapsed = get_time() - this->start_time;
  std::string left = this->name;
  if (left.size() < 60) {
    left += std::string(60 - left.size(), '-');
  }
  if (memo.find(name) == memo.end()) {
    memo.insert(make_pair(name, make_pair(0.0, 0)));
  }
  pair<double, int> memo_record = memo[name];
  memo_record.first += elapsed;
  memo_record.second += 1;
  memo[name] = memo_record;
  double avg = memo_record.first / memo_record.second;
  this->print_record(left.c_str(), elapsed, avg);
}

double Time::TickTimer::get_time() {
  return Time::get_time();
}

void Time::TickTimer::print_record(const char *left,
                                   double elapsed,
                                   double average) {
  string unit;
  double measurement;
  if (elapsed < 1e3) {
    measurement = 1.0;
    unit = "cycles";
  } else if (elapsed < 1e6) {
    measurement = 1e3;
    unit = "K cycles";
  } else if (elapsed < 1e9) {
    measurement = 1e6;
    unit = "M cycles";
  } else {
    measurement = 1e9;
    unit = "G cycles";
  }
  printf("%s ==> %4.2f %s ~ %4.2f %s\n", left, elapsed / measurement,
         unit.c_str(), average / measurement, unit.c_str());
}

Time::Timer::Timer(std::string name) {
  this->name = name;
  this->start_time = get_time();
  this->have_output = false;
}

Time::TickTimer::TickTimer(std::string name) {
  this->name = name;
  this->start_time = get_time();
  this->have_output = false;
}

//  Windows
#ifdef _WIN32

#include <intrin.h>
uint64 Time::get_cycles() {
  return __rdtsc();
}

//  Linux/GCC
#else

uint64 Time::get_cycles() {
  unsigned int lo, hi;
  __asm__ __volatile__("rdtsc" : "=a"(lo), "=d"(hi));
  return ((uint64)hi << 32) | lo;
}

#endif

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


TC_NAMESPACE_BEGIN

CoreState &CoreState::get_instance() {
  static CoreState state;
  return state;
}

int __trash__;

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <map>
#include <string>
#include <cstdio>
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <typeinfo>

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <vector>

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <cmath>
#include <type_traits>
#include <functional>
#include <vector>
#include <array>
#include <immintrin.h>
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <cmath>

TC_NAMESPACE_BEGIN

#undef max
#undef min

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::cos;
using std::floor;
using std::max;
using std::min;
using std::sin;
using std::tan;

const real pi{acosf(-1.0_f)};
const real eps = 1e-6_f;

template <int I, typename T>
constexpr TC_FORCE_INLINE T pow(T a) noexcept {
  T ret(1);
  for (int i = 0; i < I; i++) {
    ret *= a;
  }
  return ret;
};

TC_FORCE_INLINE float32 fract(float32 a) noexcept {
  return a - (int)floor(a);
}

TC_FORCE_INLINE float64 fract(float64 a) noexcept {
  return a - (int)floor(a);
}

template <typename T>
TC_FORCE_INLINE T clamp(const T &a, const T &min, const T &max) noexcept {
  if (a < min)
    return min;
  if (a > max)
    return max;
  return a;
}

template <typename T>
TC_FORCE_INLINE T clamp(const T &a) noexcept {
  if (a < T(0))
    return T(0);
  if (a > T(1))
    return T(1);
  return a;
}

template <typename T, typename V>
TC_FORCE_INLINE V lerp(T a, V x_0, V x_1) noexcept {
  return (T(1) - a) * x_0 + a * x_1;
}

template <typename T>
TC_FORCE_INLINE T sqr(const T &a) noexcept {
  return pow<2>(a);
}

TC_FORCE_INLINE int sgn(float a) noexcept {
  if (a < -eps)
    return -1;
  else if (a > eps)
    return 1;
  return 0;
}

TC_FORCE_INLINE int sgn(double a) noexcept {
  if (a < -eps)
    return -1;
  else if (a > eps)
    return 1;
  return 0;
}

TC_FORCE_INLINE uint32 rand_int() noexcept {
  static unsigned int x = 123456789, y = 362436069, z = 521288629, w = 88675123;
  unsigned int t = x ^ (x << 11);
  x = y;
  y = z;
  z = w;
  return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
}

TC_FORCE_INLINE uint64 rand_int64() noexcept {
  return ((uint64)rand_int() << 32) + rand_int();
}

// inline float frand() { return (float)rand() / (RAND_MAX + 1); }
TC_FORCE_INLINE float32 rand() noexcept {
  return rand_int() * (1.0_f / 4294967296.0f);
}

template <typename T>
TC_FORCE_INLINE T rand() noexcept;

template <>
TC_FORCE_INLINE float rand<float>() noexcept {
  return rand_int() * (1.0_f / 4294967296.0f);
}

template <>
TC_FORCE_INLINE double rand<double>() noexcept {
  return rand_int() * (1.0 / 4294967296.0);
}

template <>
TC_FORCE_INLINE int rand<int>() noexcept {
  return rand_int();
}

inline int is_prime(int a) noexcept {
  assert(a >= 2);
  for (int i = 2; i * i <= a; i++) {
    if (a % i == 0)
      return false;
  }
  return true;
}

template <typename T>
TC_FORCE_INLINE T hypot2(const T &x, const T &y) noexcept {
  return x * x + y * y;
}

TC_FORCE_INLINE float32 pow(const float32 &a, const float32 &b) noexcept {
  return ::pow(a, b);
}

TC_FORCE_INLINE float64 pow(const float64 &a, const float64 &b) noexcept {
  return ::pow(a, b);
}

template <typename T>
TC_FORCE_INLINE bool is_normal(T m) noexcept {
  return std::isfinite(m);
}

template <typename T>
TC_FORCE_INLINE bool abnormal(T m) noexcept {
  return !is_normal(m);
}

inline int64 get_largest_pot(int64 a) noexcept {
  assert_info(a > 0, "a should be positive, instead of " + std::to_string(a));
  // TODO: optimize
  int64 i = 1;
  while (i <= a / 2) {
    i *= 2;
  }
  return i;
}

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/



TC_NAMESPACE_BEGIN

template <int dim>
class IndexND;

template <int dim>
using TIndex = IndexND<dim>;

template <int dim>
class RegionND;

template <int dim>
using TRegion = RegionND<dim>;

template <int dim, typename T>
class ArrayND;

template <typename T, int dim>
using TArray = ArrayND<dim, T>;

TC_NAMESPACE_END

TC_NAMESPACE_BEGIN

// Instruction Set Extension

enum class InstSetExt { None, SSE, AVX, AVX2 };

#ifdef TC_ISE_NONE
constexpr InstSetExt default_instruction_set = InstSetExt::None;
#elif TC_ISE_SSE
constexpr InstSetExt default_instruction_set = InstSetExt::SSE;
#elif TC_ISE_AVX
constexpr InstSetExt default_instruction_set = InstSetExt::AVX;
#elif TC_ISE_AVX2
constexpr InstSetExt default_instruction_set = InstSetExt::AVX2;
#else
#define TC_ISE_ISE_NONE
constexpr InstSetExt default_instruction_set = InstSetExt::None;
#endif

/////////////////////////////////////////////////////////////////
/////              N dimensional Vector
/////////////////////////////////////////////////////////////////

template <int dim, typename T, InstSetExt ISE, class Enable = void>
struct VectorNDBase {
  static constexpr bool simd = false;
  static constexpr int storage_elements = dim;
  T d[dim];
};

template <typename T, InstSetExt ISE>
struct VectorNDBase<1, T, ISE, void> {
  static constexpr bool simd = false;
  static constexpr int storage_elements = 1;
  union {
    T d[1];
    struct {
      T x;
    };
  };
};

template <typename T, InstSetExt ISE>
struct VectorNDBase<2, T, ISE, void> {
  static constexpr bool simd = false;
  static constexpr int storage_elements = 2;
  union {
    T d[2];
    struct {
      T x, y;
    };
  };
};

template <typename T, InstSetExt ISE>
struct VectorNDBase<
    3,
    T,
    ISE,
    typename std::enable_if_t<(!std::is_same<T, float32>::value ||
                               ISE < InstSetExt::SSE)>> {
  static constexpr bool simd = false;
  static constexpr int storage_elements = 3;
  union {
    T d[3];
    struct {
      T x, y, z;
    };
  };
};

template <InstSetExt ISE>
struct TC_ALIGNED(16)
    VectorNDBase<3,
                 float32,
                 ISE,
                 typename std::enable_if_t<ISE >= InstSetExt::SSE>> {
  static constexpr bool simd = true;
  static constexpr int storage_elements = 4;
  union {
    __m128 v;
    struct {
      float32 x, y, z, _w;
    };
    float32 d[4];
  };

  TC_FORCE_INLINE VectorNDBase(float32 x = 0.0_f) : v(_mm_set_ps1(x)) {
  }

  explicit VectorNDBase(__m128 v) : v(v) {
  }
};

template <typename T, InstSetExt ISE>
struct VectorNDBase<
    4,
    T,
    ISE,
    typename std::enable_if_t<(!std::is_same<T, float32>::value ||
                               ISE < InstSetExt::SSE)>> {
  static constexpr int storage_elements = 4;
  static constexpr bool simd = false;
  union {
    T d[4];
    struct {
      T x, y, z, w;
    };
  };
};

template <InstSetExt ISE>
struct TC_ALIGNED(16)
    VectorNDBase<4, float32, ISE, std::enable_if_t<(ISE >= InstSetExt::SSE)>> {
  static constexpr bool simd = true;
  static constexpr int storage_elements = 4;
  union {
    __m128 v;
    struct {
      float32 x, y, z, w;
    };
    float32 d[4];
  };

  TC_FORCE_INLINE VectorNDBase(float32 x = 0.0_f) : v(_mm_set_ps1(x)) {
  }

  TC_FORCE_INLINE explicit VectorNDBase(__m128 v) : v(v) {
  }
};

template <int dim__, typename T, InstSetExt ISE = default_instruction_set>
struct VectorND : public VectorNDBase<dim__, T, ISE> {
  static constexpr int dim = dim__;
  using ScalarType = T;

  template <int dim_, typename T_, InstSetExt ISE_>
  static constexpr bool SIMD_4_32F =
      (dim_ == 3 || dim_ == 4) && std::is_same<T_, float32>::value &&ISE_
                                      >= InstSetExt::SSE;

  template <int dim_, typename T_, InstSetExt ISE_>
  static constexpr bool SIMD_NONE = !SIMD_4_32F<dim_, T_, ISE_>;

  static constexpr InstSetExt ise = ISE;
  using type = T;

  using VectorBase = VectorNDBase<dim, T, ISE>;
  using VectorBase::d;
  static constexpr int storage_elements = VectorBase::storage_elements;

  TC_FORCE_INLINE VectorND() {
    for (int i = 0; i < dim; i++) {
      this->d[i] = T(0);
    }
  }

  static TC_FORCE_INLINE VectorND from_array(const T new_val[dim]) {
    VectorND ret;
    for (int i = 0; i < dim; i++) {
      ret.d[i] = new_val[i];
    }
    return ret;
  }

  template <int dim_, typename T_, InstSetExt ISE_>
  explicit TC_FORCE_INLINE VectorND(const VectorND<dim_, T_, ISE_> &o)
      : VectorND() {
    for (int i = 0; i < std::min(dim_, dim__); i++) {
      d[i] = o[i];
    }
  }

  explicit TC_FORCE_INLINE VectorND(const std::array<T, dim> &o) {
    for (int i = 0; i < dim; i++) {
      d[i] = o[i];
    }
  }

  template <typename T_ = T,
            typename std::enable_if_t<std::is_same<T_, int>::value, int> = 0>
  VectorND(const TIndex<dim> &ind);

  // Vector3f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 3,
                                      int> = 0>
  explicit TC_FORCE_INLINE VectorND(float32 x) : VectorNDBase<dim, T, ISE>(x) {
  }

  // Vector4f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 4,
                                      int> = 0>
  explicit TC_FORCE_INLINE VectorND(float32 x) : VectorNDBase<dim, T, ISE>(x) {
  }

  // Vector3f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 3,
                                      int> = 0>
  explicit TC_FORCE_INLINE VectorND(real x, real y, real z, real w = 0.0_f)
      : VectorBase(_mm_set_ps(w, z, y, x)) {
  }

  // Vector4f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 4,
                                      int> = 0>
  explicit TC_FORCE_INLINE VectorND(real x, real y, real z, real w)
      : VectorBase(_mm_set_ps(w, z, y, x)) {
  }

  // Vector initialization
  template <typename F,
            std::enable_if_t<std::is_same<F, VectorND>::value, int> = 0>
  explicit TC_FORCE_INLINE VectorND(const F &f) {
    for (int i = 0; i < dim; i++)
      this->d[i] = f[i];
  }

  // Scalar initialization
  template <typename F, std::enable_if_t<std::is_same<F, T>::value, int> = 0>
  explicit TC_FORCE_INLINE VectorND(const F &f) {
    for (int i = 0; i < dim; i++)
      this->d[i] = f;
  }

  // Function intialization
  template <
      typename F,
      std::enable_if_t<std::is_convertible<F, std::function<T(int)>>::value,
                       int> = 0>
  explicit TC_FORCE_INLINE VectorND(const F &f) {
    for (int i = 0; i < dim; i++)
      this->d[i] = f(i);
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_NONE<dim_, T_, ISE_>, int> = 0>
  explicit TC_FORCE_INLINE VectorND(T v) {
    for (int i = 0; i < dim; i++) {
      this->d[i] = v;
    }
  }

  explicit TC_FORCE_INLINE VectorND(T v0, T v1) {
    static_assert(dim == 2, "Vector dim must be 2");
    this->d[0] = v0;
    this->d[1] = v1;
  }

  // All except Vector3f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<!SIMD_4_32F<dim_, T_, ISE_> || dim != 3,
                                      int> = 0>
  explicit TC_FORCE_INLINE VectorND(T v0, T v1, T v2) {
    static_assert(dim == 3, "Vector dim must be 3");
    this->d[0] = v0;
    this->d[1] = v1;
    this->d[2] = v2;
  }

  // All except Vector3f, Vector4f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_NONE<dim_, T_, ISE_>, int> = 0>
  explicit TC_FORCE_INLINE VectorND(T v0, T v1, T v2, T v3) {
    static_assert(dim == 4, "Vector dim must be 4");
    this->d[0] = v0;
    this->d[1] = v1;
    this->d[2] = v2;
    this->d[3] = v3;
  }

  // Vector extension
  template <int dim_ = dim, std::enable_if_t<(dim_ > 1), int> = 0>
  explicit TC_FORCE_INLINE VectorND(const VectorND<dim - 1, T, ISE> &o,
                                    T extra) {
    for (int i = 0; i < dim_ - 1; i++) {
      this->d[i] = o[i];
    }
    this->d[dim - 1] = extra;
  }

  template <typename T_>
  explicit TC_FORCE_INLINE VectorND(const std::vector<T_> &o) {
    if (o.size() != dim) {
      TC_ERROR("Dimension mismatch: " + std::to_string(dim) + " v.s. " +
               std::to_string((int)o.size()));
    }
    for (int i = 0; i < dim; i++)
      this->d[i] = T(o[i]);
  }

  TC_FORCE_INLINE T &operator[](int i) {
    return this->d[i];
  }

  TC_FORCE_INLINE const T &operator[](int i) const {
    return this->d[i];
  }

  TC_FORCE_INLINE T &operator()(int i) {
    return d[i];
  }

  TC_FORCE_INLINE const T &operator()(int i) const {
    return d[i];
  }

  TC_FORCE_INLINE T dot(VectorND<dim, T, ISE> o) const {
    T ret = T(0);
    for (int i = 0; i < dim; i++)
      ret += this->d[i] * o[i];
    return ret;
  }

  template <
      typename F,
      std::enable_if_t<std::is_convertible<F, std::function<T(int)>>::value,
                       int> = 0>
  TC_FORCE_INLINE VectorND &set(const F &f) {
    for (int i = 0; i < dim; i++)
      this->d[i] = f(i);
    return *this;
  }

  TC_FORCE_INLINE auto map(T(f)(T)) const
      -> VectorND<dim, decltype(f(T(0))), ISE> {
    VectorND<dim, decltype(f(T(0))), ISE> ret;
    for (int i = 0; i < dim; i++)
      ret[i] = f(this->d[i]);
    return ret;
  }

  TC_FORCE_INLINE VectorND &operator=(const VectorND &o) {
    memcpy(this, &o, sizeof(*this));
    return *this;
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND &operator=(__m128 v) {
    this->v = v;
    return *this;
  }

  // SIMD: Vector3f & Vector4f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND operator+(const VectorND &o) const {
    return VectorND(_mm_add_ps(this->v, o.v));
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND operator-(const VectorND &o) const {
    return VectorND(_mm_sub_ps(this->v, o.v));
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND operator*(const VectorND &o) const {
    return VectorND(_mm_mul_ps(this->v, o.v));
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND operator/(const VectorND &o) const {
    return VectorND(_mm_div_ps(this->v, o.v));
  }

  // Non-SIMD cases
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_NONE<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND operator+(const VectorND &o) const {
    return VectorND([=](int i) { return this->d[i] + o[i]; });
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_NONE<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND operator-(const VectorND &o) const {
    return VectorND([=](int i) { return this->d[i] - o[i]; });
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_NONE<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND operator*(const VectorND &o) const {
    return VectorND([=](int i) { return this->d[i] * o[i]; });
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_NONE<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND operator/(const VectorND &o) const {
    return VectorND([=](int i) { return this->d[i] / o[i]; });
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<std::is_integral<T_>::value, int> = 0>
  TC_FORCE_INLINE VectorND operator%(const VectorND &o) const {
    return VectorND([=](int i) { return this->d[i] % o[i]; });
  }

  // Inplace operations
  TC_FORCE_INLINE VectorND &operator+=(const VectorND &o) {
    (*this) = (*this) + o;
    return *this;
  }

  TC_FORCE_INLINE VectorND &operator-=(const VectorND &o) {
    (*this) = (*this) - o;
    return *this;
  }

  TC_FORCE_INLINE VectorND &operator*=(const VectorND &o) {
    (*this) = (*this) * o;
    return *this;
  }

  TC_FORCE_INLINE VectorND &operator*=(const T &o) {
    (*this) = (*this) * o;
    return *this;
  }

  TC_FORCE_INLINE VectorND &operator/=(const VectorND &o) {
    (*this) = (*this) / o;
    return *this;
  }

  TC_FORCE_INLINE VectorND &operator/=(const T &o) {
    (*this) = (*this) / o;
    return *this;
  }

  TC_FORCE_INLINE VectorND operator-() const {
    return VectorND([=](int i) { return -this->d[i]; });
  }

  TC_FORCE_INLINE bool operator==(const VectorND &o) const {
    for (int i = 0; i < dim; i++)
      if (this->d[i] != o[i])
        return false;
    return true;
  }

  TC_FORCE_INLINE bool operator<(const VectorND &o) const {
    for (int i = 0; i < dim; i++)
      if (this->d[i] >= o[i])
        return false;
    return true;
  }

  TC_FORCE_INLINE bool operator<=(const VectorND &o) const {
    for (int i = 0; i < dim; i++)
      if (this->d[i] > o[i])
        return false;
    return true;
  }

  TC_FORCE_INLINE bool operator>(const VectorND &o) const {
    for (int i = 0; i < dim; i++)
      if (this->d[i] <= o[i])
        return false;
    return true;
  }

  TC_FORCE_INLINE bool operator>=(const VectorND &o) const {
    for (int i = 0; i < dim; i++)
      if (this->d[i] < o[i])
        return false;
    return true;
  }

  TC_FORCE_INLINE bool operator==(const std::vector<T> &o) const {
    if (o.size() != dim)
      return false;
    for (int i = 0; i < dim; i++)
      if (this->d[i] != o[i])
        return false;
    return true;
  }

  TC_FORCE_INLINE bool operator!=(const VectorND &o) const {
    for (int i = 0; i < dim; i++)
      if (this->d[i] != o[i])
        return true;
    return false;
  }

  TC_FORCE_INLINE VectorND abs() const {
    return VectorND([&](int i) { return std::abs(d[i]); });
  }

  TC_FORCE_INLINE VectorND floor() const {
    return VectorND([&](int i) { return std::floor(d[i]); });
  }

  TC_FORCE_INLINE VectorND sin() const {
    return VectorND([&](int i) { return std::sin(d[i]); });
  }

  TC_FORCE_INLINE VectorND cos() const {
    return VectorND([&](int i) { return std::cos(d[i]); });
  }

  TC_FORCE_INLINE VectorND fract() const {
    return VectorND([&](int i) { return taichi::fract(d[i]); });
  }

  TC_FORCE_INLINE VectorND clamp() const {
    return VectorND([&](int i) { return taichi::clamp(d[i]); });
  }

  TC_FORCE_INLINE VectorND clamp(const T &a, T &b) const {
    return VectorND([&](int i) { return taichi::clamp(d[i], a, b); });
  }

  TC_FORCE_INLINE VectorND clamp(const VectorND &a, const VectorND &b) const {
    return VectorND([&](int i) { return taichi::clamp(d[i], a[i], b[i]); });
  }

  TC_FORCE_INLINE T min() const {
    T ret = this->d[0];
    for (int i = 1; i < dim; i++) {
      ret = std::min(ret, this->d[i]);
    }
    return ret;
  }

  TC_FORCE_INLINE T max() const {
    T ret = this->d[0];
    for (int i = 1; i < dim; i++) {
      ret = std::max(ret, this->d[i]);
    }
    return ret;
  }

  TC_FORCE_INLINE T abs_max() const {
    T ret = std::abs(this->d[0]);
    for (int i = 1; i < dim; i++) {
      ret = std::max(ret, std::abs(this->d[i]));
    }
    return ret;
  }

  template <typename G>
  TC_FORCE_INLINE VectorND<dim, G, ISE> cast() const {
    return VectorND<dim, G, ISE>(
        [this](int i) { return static_cast<G>(this->d[i]); });
  }

  void print() const {
    for (int i = 0; i < dim; i++) {
      std::cout << this->d[i] << " ";
    }
    std::cout << std::endl;
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE operator __m128() const {
    return this->v;
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE operator __m128i() const {
    return _mm_castps_si128(this->v);
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE operator __m128d() const {
    return _mm_castps_pd(this->v);
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE explicit VectorND(__m128 v) {
    this->v = v;
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>

  TC_FORCE_INLINE VectorND operator-() const {
    return VectorND(_mm_sub_ps(VectorND(0.0_f), this->v));
  }

  template <int a,
            int b,
            int c,
            int d,
            int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND permute() const {
    return VectorND(_mm_permute_ps(this->v, _MM_SHUFFLE(a, b, c, d)));
  }

  template <int a,
            int b,
            int c,
            int d,
            int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<!SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND permute() const {
    return VectorND(this->d[a], this->d[b], this->d[c], this->d[d]);
  }

  template <int a, int dim_ = dim, typename T_ = T, InstSetExt ISE_ = ISE>
  TC_FORCE_INLINE VectorND broadcast() const {
    return permute<a, a, a, a>();
  }

  // member function: length
  // Vector3f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 3,
                                      int> = 0>
  TC_FORCE_INLINE float32 length2() const {
    return _mm_cvtss_f32(_mm_dp_ps(this->v, this->v, 0x71));
  }

  // Vector4f
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 4,
                                      int> = 0>
  TC_FORCE_INLINE float32 length2() const {
    return _mm_cvtss_f32(_mm_dp_ps(this->v, this->v, 0xf1));
  }

  // Others
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_NONE<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE T length2() const {
    T ret = 0;
    for (int i = 0; i < dim; i++) {
      ret += this->d[i] * this->d[i];
    }
    return ret;
  }

  TC_FORCE_INLINE auto length() const {
    return std::sqrt(length2());
  }

  bool is_normal() const {
    for (int i = 0; i < dim; i++) {
      if (!taichi::is_normal(this->d[i]))
        return false;
    }
    return true;
  }

  bool abnormal() const {
    return !this->is_normal();
  }

  static VectorND rand() {
    VectorND ret;
    for (int i = 0; i < dim; i++) {
      ret[i] = taichi::rand();
    }
    return ret;
  }

  TC_FORCE_INLINE T sum() const {
    T ret = this->d[0];
    for (int i = 1; i < dim; i++) {
      ret += this->d[i];
    }
    return ret;
  }

  TC_FORCE_INLINE T average() const {
    return (T(1.0) / dim) * sum();
  }

  TC_FORCE_INLINE T prod() const {
    T ret = this->d[0];
    for (int i = 1; i < dim; i++) {
      ret *= this->d[i];
    }
    return ret;
  }

  TC_FORCE_INLINE VectorND pow(T index) const {
    VectorND ret;
    for (int i = 0; i < dim; i++) {
      ret[i] = std::pow(this->d[i], index);
    }
    return ret;
  }

  TC_FORCE_INLINE static VectorND axis(int i) {
    VectorND ret(0);
    ret[i] = 1;
    return ret;
  }

  TC_IO_DECL {
    if (TC_SERIALIZER_IS(TextSerializer)) {
      std::string ret = "(";
      for (int i = 0; i < dim - 1; i++) {
        ret += fmt::format("{}, ", d[i]);
      }
      ret += fmt::format("{}", d[dim - 1]);
      ret += ")";
      serializer("vec", ret);
    } else {
      TC_IO(d);
    }
  }

  TC_FORCE_INLINE operator std::array<T, dim>() const {
    std::array<T, dim> arr;
    for (int i = 0; i < dim; i++) {
      arr[i] = d[i];
    }
    return arr;
  }
};

template <typename T, int dim, InstSetExt ISE = default_instruction_set>
using TVector = VectorND<dim, T, ISE>;

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE VectorND<dim, T, ISE> operator
    *(T a, const VectorND<dim, T, ISE> &v) {
  return VectorND<dim, T, ISE>(a) * v;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE VectorND<dim, T, ISE> operator*(const VectorND<dim, T, ISE> &v,
                                                T a) {
  return a * v;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE VectorND<dim, T, ISE> operator/(
    T a,
    const VectorND<dim, T, ISE> &v) {
  return VectorND<dim, T, ISE>(a) / v;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE VectorND<dim, T, ISE> operator/(const VectorND<dim, T, ISE> &v,
                                                T a) {
  return v / VectorND<dim, T, ISE>(a);
}

template <typename T>
TC_FORCE_INLINE std::array<T, 1> to_std_array(const TVector<T, 1> &v) {
  return std::array<T, 1>{v[0]};
}

template <typename T>
TC_FORCE_INLINE std::array<T, 2> to_std_array(const TVector<T, 2> &v) {
  return std::array<T, 2>{v[0], v[1]};
}

template <typename T>
TC_FORCE_INLINE std::array<T, 3> to_std_array(const TVector<T, 3> &v) {
  return std::array<T, 3>{v[0], v[1], v[2]};
}

template <typename T>
TC_FORCE_INLINE std::array<T, 4> to_std_array(const TVector<T, 4> &v) {
  return std::array<T, 4>{v[0], v[1], v[2], v[3]};
}

using Vector1 = VectorND<1, real, default_instruction_set>;
using Vector2 = VectorND<2, real, default_instruction_set>;
using Vector3 = VectorND<3, real, default_instruction_set>;
using Vector4 = VectorND<4, real, default_instruction_set>;

using Vector1f = VectorND<1, float32, default_instruction_set>;
using Vector2f = VectorND<2, float32, default_instruction_set>;
using Vector3f = VectorND<3, float32, default_instruction_set>;
using Vector4f = VectorND<4, float32, default_instruction_set>;

using Vector1d = VectorND<1, float64, default_instruction_set>;
using Vector2d = VectorND<2, float64, default_instruction_set>;
using Vector3d = VectorND<3, float64, default_instruction_set>;
using Vector4d = VectorND<4, float64, default_instruction_set>;

using Vector1i = VectorND<1, int, default_instruction_set>;
using Vector2i = VectorND<2, int, default_instruction_set>;
using Vector3i = VectorND<3, int, default_instruction_set>;
using Vector4i = VectorND<4, int, default_instruction_set>;

// FMA: a * b + c
template <typename T>
TC_FORCE_INLINE typename std::
    enable_if<T::simd && (default_instruction_set >= InstSetExt::AVX), T>::type
    fused_mul_add(const T &a, const T &b, const T &c) {
  return T(_mm_fmadd_ps(a, b, c));
}

template <typename T>
TC_FORCE_INLINE typename std::
    enable_if<!T::simd || (default_instruction_set < InstSetExt::AVX), T>::type
    fused_mul_add(const T &a, const T &b, const T &c) {
  return a * b + c;
}

/////////////////////////////////////////////////////////////////
/////              N dimensional Matrix
/////////////////////////////////////////////////////////////////

template <int dim__, typename T, InstSetExt ISE = default_instruction_set>
struct MatrixND {
  static constexpr int dim = dim__;

  template <int dim_, typename T_, InstSetExt ISE_>
  static constexpr bool SIMD_4_32F =
      (dim_ == 3 || dim_ == 4) && std::is_same<T_, float32>::value &&
      (ISE_ >= InstSetExt::SSE);

  using ScalarType = T;

  template <int dim_, typename T_, InstSetExt ISE_>
  static constexpr bool SIMD_NONE = !SIMD_4_32F<dim_, T_, ISE_>;
  using Vector = VectorND<dim, T, ISE>;
  Vector d[dim];

  static constexpr InstSetExt ise = ISE;
  using type = T;

  TC_FORCE_INLINE MatrixND() {
    for (int i = 0; i < dim; i++) {
      d[i] = VectorND<dim, T, ISE>();
    }
  }

  template <int dim_, typename T_, InstSetExt ISE_>
  TC_FORCE_INLINE explicit MatrixND(const MatrixND<dim_, T_, ISE_> &o)
      : MatrixND() {
    for (int i = 0; i < std::min(dim_, dim__); i++) {
      for (int j = 0; j < std::min(dim_, dim__); j++) {
        d[i][j] = o[i][j];
      }
    }
  }

  TC_FORCE_INLINE MatrixND(T v) : MatrixND() {
    for (int i = 0; i < dim; i++) {
      d[i][i] = v;
    }
  }

  TC_FORCE_INLINE MatrixND(const MatrixND &o) {
    *this = o;
  }

  // Diag
  TC_FORCE_INLINE explicit MatrixND(Vector v) : MatrixND() {
    for (int i = 0; i < dim; i++)
      this->d[i][i] = v[i];
  }

  TC_FORCE_INLINE explicit MatrixND(Vector v0, Vector v1) {
    static_assert(dim == 2, "Matrix dim must be 2");
    this->d[0] = v0;
    this->d[1] = v1;
  }

  TC_FORCE_INLINE explicit MatrixND(Vector v0, Vector v1, Vector v2) {
    static_assert(dim == 3, "Matrix dim must be 3");
    this->d[0] = v0;
    this->d[1] = v1;
    this->d[2] = v2;
  }

  TC_FORCE_INLINE explicit MatrixND(Vector v0,
                                    Vector v1,
                                    Vector v2,
                                    Vector v3) {
    static_assert(dim == 4, "Matrix dim must be 4");
    this->d[0] = v0;
    this->d[1] = v1;
    this->d[2] = v2;
    this->d[3] = v3;
  }

  // Function intialization
  template <typename F,
            std::enable_if_t<
                std::is_convertible<F, std::function<VectorND<dim__, T, ISE>(int)>>::value,
                int> = 0>
  TC_FORCE_INLINE explicit MatrixND(const F &f) {
    for (int i = 0; i < dim; i++)
      this->d[i] = f(i);
  }

  template <typename F,
            std::enable_if_t<
                std::is_convertible<F, std::function<VectorND<dim__, T, ISE>(int)>>::value,
                int> = 0>
  TC_FORCE_INLINE MatrixND &set(const F &f) {
    for (int i = 0; i < dim; i++)
      this->d[i] = f(i);
    return *this;
  }

  TC_FORCE_INLINE MatrixND &operator=(const MatrixND &o) {
    for (int i = 0; i < dim; i++) {
      this->d[i] = o[i];
    }
    return *this;
  }

  TC_FORCE_INLINE VectorND<dim, T, ISE> &operator[](int i) {
    return d[i];
  }

  TC_FORCE_INLINE T &operator()(int i, int j) {
    return d[j][i];
  }

  TC_FORCE_INLINE const T &operator()(int i, int j) const {
    return d[j][i];
  }

  TC_FORCE_INLINE const VectorND<dim, T, ISE> &operator[](int i) const {
    return d[i];
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<!SIMD_4_32F<dim_, T_, ISE_>, int> = 0>
  TC_FORCE_INLINE VectorND<dim, T, ISE> operator*(
      const VectorND<dim, T, ISE> &o) const {
    VectorND<dim, T, ISE> ret = d[0] * o[0];
    for (int i = 1; i < dim; i++)
      ret += d[i] * o[i];
    return ret;
  }

  // Matrix3
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 3,
                                      int> = 0>
  TC_FORCE_INLINE VectorND<dim, T, ISE> operator*(
      const VectorND<dim, T, ISE> &o) const {
    VectorND<dim, T, ISE> ret = o.template broadcast<2>() * d[2];
    ret = fused_mul_add(d[1], o.template broadcast<1>(), ret);
    ret = fused_mul_add(d[0], o.template broadcast<0>(), ret);
    return ret;
  }

  // Matrix4
  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 4,
                                      int> = 0>
  TC_FORCE_INLINE Vector operator*(const Vector &o) const {
    Vector ret = o.template broadcast<3>() * d[3];
    ret = fused_mul_add(d[2], o.template broadcast<2>(), ret);
    ret = fused_mul_add(d[1], o.template broadcast<1>(), ret);
    ret = fused_mul_add(d[0], o.template broadcast<0>(), ret);
    return ret;
  }

  template <int dim_ = dim,
            typename T_ = T,
            InstSetExt ISE_ = ISE,
            typename std::enable_if_t<SIMD_4_32F<dim_, T_, ISE_> && dim_ == 4,
                                      int> = 0>
  TC_FORCE_INLINE Vector4 multiply_vec3(const Vector4 &o) const {
    Vector4 ret = o.broadcast<2>() * d[2];
    ret = fused_mul_add(d[1], o.template broadcast<1>(), ret);
    ret = fused_mul_add(d[0], o.template broadcast<0>(), ret);
    return ret;
  }

  TC_FORCE_INLINE MatrixND operator*(const MatrixND &o) const {
    return MatrixND([&](int i) { return (*this) * o[i]; });
  }

  TC_FORCE_INLINE static MatrixND outer_product(Vector column, Vector row) {
    return MatrixND([&](int i) { return column * row[i]; });
  }

  TC_FORCE_INLINE MatrixND operator+(const MatrixND &o) const {
    return MatrixND([=](int i) { return this->d[i] + o[i]; });
  }

  TC_FORCE_INLINE MatrixND operator-(const MatrixND &o) const {
    return MatrixND([=](int i) { return this->d[i] - o[i]; });
  }

  TC_FORCE_INLINE MatrixND &operator+=(const MatrixND &o) {
    return this->set([&](int i) { return this->d[i] + o[i]; });
  }

  TC_FORCE_INLINE MatrixND &operator-=(const MatrixND &o) {
    return this->set([&](int i) { return this->d[i] - o[i]; });
  }

  TC_FORCE_INLINE MatrixND operator-() const {
    return MatrixND([=](int i) { return -this->d[i]; });
  }

  TC_FORCE_INLINE bool operator==(const MatrixND &o) const {
    for (int i = 0; i < dim; i++)
      for (int j = 0; j < dim; j++)
        if (d[i][j] != o[i][j])
          return false;
    return true;
  }

  TC_FORCE_INLINE bool operator!=(const MatrixND &o) const {
    for (int i = 0; i < dim; i++)
      for (int j = 0; j < dim; j++)
        if (d[i][j] != o[i][j])
          return true;
    return false;
  }

  TC_FORCE_INLINE T frobenius_norm2() const {
    T sum = d[0].length2();
    for (int i = 1; i < dim; i++) {
      sum += d[i].length2();
    }
    return sum;
  }

  TC_FORCE_INLINE auto frobenius_norm() const {
    return std::sqrt(frobenius_norm2());
  }

  // Matrix4
  TC_FORCE_INLINE MatrixND transposed() const {
    MatrixND ret;
    // TC_STATIC_IF((SIMD_4_32F<dim, T, ISE> && dim == 4)) {
    // TC_STATIC_IF((std::is_same<T, float32>::value && dim == 4)) {
    /*
    TC_STATIC_IF((true)) {
      static_assert(std::is_same<T, float32>(), "123");
      static_assert(std::is_same<T, float64>(), "456");
      Vector4 t0(_mm_unpacklo_ps(this->d[0], this->d[1]));
      Vector4 t2(_mm_unpacklo_ps(this->d[2], this->d[3]));
      Vector4 t1(_mm_unpackhi_ps(this->d[0], this->d[1]));
      Vector4 t3(_mm_unpackhi_ps(this->d[2], this->d[3]));
      ret[0] = Vector4(_mm_movelh_ps(t0, t2));
      ret[1] = Vector4(_mm_movehl_ps(t2, t0));
      ret[2] = Vector4(_mm_movelh_ps(t1, t3));
      ret[3] = Vector4(_mm_movehl_ps(t3, t1));
    }
    TC_STATIC_ELSE {
       */
    for (int i = 0; i < dim; i++) {
      for (int j = 0; j < dim; j++) {
        ret[i][j] = d[j][i];
      }
    }
    //}
    // TC_STATIC_END_IF
    return ret;
  }

  template <typename G>
  TC_FORCE_INLINE MatrixND<dim, G, ISE> cast() const {
    return MatrixND<dim, G, ISE>(
        [=](int i) { return d[i].template cast<G>(); });
  }

  bool is_normal() const {
    for (int i = 0; i < dim; i++) {
      if (!this->d[i].is_normal())
        return false;
    }
    return true;
  }

  bool abnormal() const {
    return !this->is_normal();
  }

  static MatrixND rand() {
    MatrixND ret;
    for (int i = 0; i < dim; i++) {
      ret[i] = Vector::rand();
    }
    return ret;
  }

  TC_FORCE_INLINE Vector diag() const {
    Vector ret;
    for (int i = 0; i < dim; i++) {
      ret[i] = this->d[i][i];
    }
    return ret;
  }

  TC_FORCE_INLINE T sum() const {
    T ret(0);
    for (int i = 0; i < dim; i++) {
      ret += this->d[i].sum();
    }
    return ret;
  }

  TC_FORCE_INLINE T trace() const {
    return this->diag().sum();
  }

  TC_FORCE_INLINE T tr() const {
    return this->trace();
  }

  TC_FORCE_INLINE MatrixND
  elementwise_product(const MatrixND<dim, T> &o) const {
    MatrixND ret;
    for (int i = 0; i < dim; i++) {
      ret[i] = this->d[i] * o[i];
    }
    return ret;
  }

  TC_FORCE_INLINE static MatrixND identidy() {
    return MatrixND(1.0_f);
  }

  TC_IO_DECL {
    TC_STATIC_IF(TC_SERIALIZER_IS(TextSerializer)) {
      for (int i = 0; i < dim; i++) {
        std::string line = "[";
        for (int j = 0; j < dim; j++) {
          line += fmt::format("{}   ", d[j][i]);
        }
        line += "]";
        serializer.add_line(line);
      }
    }
    TC_STATIC_ELSE {
      TC_IO(d);
    }
    TC_STATIC_END_IF
  }
};

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE MatrixND<dim, T, ISE> operator
    *(const T a, const MatrixND<dim, T, ISE> &M) {
  MatrixND<dim, T, ISE> ret;
  for (int i = 0; i < dim; i++) {
    ret[i] = a * M[i];
  }
  return ret;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE MatrixND<dim, T, ISE> operator*(const MatrixND<dim, T, ISE> &M,
                                                const T a) {
  return a * M;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE MatrixND<dim, T, ISE> transpose(
    const MatrixND<dim, T, ISE> &mat) {
  return mat.transposed();
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE MatrixND<dim, T, ISE> transposed(
    const MatrixND<dim, T, ISE> &mat) {
  return transpose(mat);
}

template <typename T, int dim, InstSetExt ISE = default_instruction_set>
using TMatrix = MatrixND<dim, T, ISE>;

using Matrix2 = MatrixND<2, real, default_instruction_set>;
using Matrix3 = MatrixND<3, real, default_instruction_set>;
using Matrix4 = MatrixND<4, real, default_instruction_set>;

using Matrix2f = MatrixND<2, float32, default_instruction_set>;
using Matrix3f = MatrixND<3, float32, default_instruction_set>;
using Matrix4f = MatrixND<4, float32, default_instruction_set>;

using Matrix2d = MatrixND<2, float64, default_instruction_set>;
using Matrix3d = MatrixND<3, float64, default_instruction_set>;
using Matrix4d = MatrixND<4, float64, default_instruction_set>;

template <typename T, InstSetExt ISE>
TC_FORCE_INLINE real determinant(const MatrixND<2, T, ISE> &mat) {
  return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];
}

template <typename T, InstSetExt ISE>
TC_FORCE_INLINE T determinant(const MatrixND<3, T, ISE> &mat) {
  return mat[0][0] * (mat[1][1] * mat[2][2] - mat[2][1] * mat[1][2]) -
         mat[1][0] * (mat[0][1] * mat[2][2] - mat[2][1] * mat[0][2]) +
         mat[2][0] * (mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2]);
}

template <typename T, InstSetExt ISE>
TC_FORCE_INLINE T cross(const VectorND<2, T, ISE> &a,
                        const VectorND<2, T, ISE> &b) {
  return a.x * b.y - a.y * b.x;
}

template <typename T, InstSetExt ISE>
TC_FORCE_INLINE VectorND<3, T, ISE> cross(const VectorND<3, T, ISE> &a,
                                          const VectorND<3, T, ISE> &b) {
  return VectorND<3, T, ISE>(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z,
                             a.x * b.y - a.y * b.x);
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE T dot(const VectorND<dim, T, ISE> &a,
                      const VectorND<dim, T, ISE> &b) {
  return a.dot(b);
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE VectorND<dim, T, ISE> normalize(
    const VectorND<dim, T, ISE> &a) {
  return (T(1) / a.length()) * a;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE VectorND<dim, T, ISE> normalized(
    const VectorND<dim, T, ISE> &a) {
  return normalize(a);
}

TC_FORCE_INLINE float32 length(const float32 &a) {
  return a;
}

TC_FORCE_INLINE float64 length(const float64 &a) {
  return a;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE T length(const VectorND<dim, T, ISE> &a) {
  return a.length();
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE T length2(const VectorND<dim, T, ISE> &a) {
  return dot(a, a);
}

TC_FORCE_INLINE float32 length2(const float32 &a) {
  return a * a;
}

TC_FORCE_INLINE float64 length2(const float64 &a) {
  return a * a;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE VectorND<dim, T, ISE> fract(const VectorND<dim, T, ISE> &a) {
  return a.fract();
}

TC_FORCE_INLINE float32 inversed(const float32 &a) {
  return 1.0_f32 / a;
}

TC_FORCE_INLINE float64 inversed(const float64 &a) {
  return 1.0_f64 / a;
}

template <InstSetExt ISE, typename T>
TC_FORCE_INLINE MatrixND<2, T, ISE> inversed(const MatrixND<2, T, ISE> &mat) {
  T det = determinant(mat);
  return static_cast<T>(1) / det *
         MatrixND<2, T, ISE>(VectorND<2, T, ISE>(mat[1][1], -mat[0][1]),
                             VectorND<2, T, ISE>(-mat[1][0], mat[0][0]));
}

template <InstSetExt ISE, typename T>
MatrixND<3, T, ISE> inversed(const MatrixND<3, T, ISE> &mat) {
  T det = determinant(mat);
  return T(1.0) / det *
         MatrixND<3, T, ISE>(
             VectorND<3, T, ISE>(mat[1][1] * mat[2][2] - mat[2][1] * mat[1][2],
                                 mat[2][1] * mat[0][2] - mat[0][1] * mat[2][2],
                                 mat[0][1] * mat[1][2] - mat[1][1] * mat[0][2]),
             VectorND<3, T, ISE>(mat[2][0] * mat[1][2] - mat[1][0] * mat[2][2],
                                 mat[0][0] * mat[2][2] - mat[2][0] * mat[0][2],
                                 mat[1][0] * mat[0][2] - mat[0][0] * mat[1][2]),
             VectorND<3, T, ISE>(
                 mat[1][0] * mat[2][1] - mat[2][0] * mat[1][1],
                 mat[2][0] * mat[0][1] - mat[0][0] * mat[2][1],
                 mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1]));
}

template <typename T, InstSetExt ISE>
T determinant(const MatrixND<4, T, ISE> &m) {
  // This function is adopted from GLM
  /*
  ================================================================================
  OpenGL Mathematics (GLM)
  --------------------------------------------------------------------------------
  GLM is licensed under The Happy Bunny License and MIT License

  ================================================================================
  The Happy Bunny License (Modified MIT License)
  --------------------------------------------------------------------------------
  Copyright (c) 2005 - 2014 G-Truc Creation

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  Restrictions:
   By making use of the Software for military purposes, you choose to make a
   Bunny unhappy.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.

  ================================================================================
  The MIT License
  --------------------------------------------------------------------------------
  Copyright (c) 2005 - 2014 G-Truc Creation

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
   */

  T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
  T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

  T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

  T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
  T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

  T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
  T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

  T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
  T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

  T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
  T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
  T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

  using Vector = VectorND<4, T, ISE>;

  Vector Fac0(Coef00, Coef00, Coef02, Coef03);
  Vector Fac1(Coef04, Coef04, Coef06, Coef07);
  Vector Fac2(Coef08, Coef08, Coef10, Coef11);
  Vector Fac3(Coef12, Coef12, Coef14, Coef15);
  Vector Fac4(Coef16, Coef16, Coef18, Coef19);
  Vector Fac5(Coef20, Coef20, Coef22, Coef23);

  Vector Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
  Vector Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
  Vector Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
  Vector Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

  Vector Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
  Vector Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
  Vector Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
  Vector Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

  Vector SignA(+1, -1, +1, -1);
  Vector SignB(-1, +1, -1, +1);
  MatrixND<4, T, ISE> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA,
                              Inv3 * SignB);

  Vector Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

  Vector Dot0(m[0] * Row0);
  T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

  return Dot1;
}

template <typename T, InstSetExt ISE>
MatrixND<4, T, ISE> inversed(const MatrixND<4, T, ISE> &m) {
  // This function is copied from GLM
  /*
  ================================================================================
  OpenGL Mathematics (GLM)
  --------------------------------------------------------------------------------
  GLM is licensed under The Happy Bunny License and MIT License

  ================================================================================
  The Happy Bunny License (Modified MIT License)
  --------------------------------------------------------------------------------
  Copyright (c) 2005 - 2014 G-Truc Creation

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  Restrictions:
   By making use of the Software for military purposes, you choose to make a
   Bunny unhappy.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.

  ================================================================================
  The MIT License
  --------------------------------------------------------------------------------
  Copyright (c) 2005 - 2014 G-Truc Creation

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
   */

  T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
  T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

  T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

  T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
  T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

  T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
  T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

  T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
  T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

  T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
  T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
  T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

  using Vector = VectorND<4, T, ISE>;

  Vector Fac0(Coef00, Coef00, Coef02, Coef03);
  Vector Fac1(Coef04, Coef04, Coef06, Coef07);
  Vector Fac2(Coef08, Coef08, Coef10, Coef11);
  Vector Fac3(Coef12, Coef12, Coef14, Coef15);
  Vector Fac4(Coef16, Coef16, Coef18, Coef19);
  Vector Fac5(Coef20, Coef20, Coef22, Coef23);

  Vector Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
  Vector Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
  Vector Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
  Vector Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

  Vector Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
  Vector Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
  Vector Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
  Vector Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

  Vector SignA(+1, -1, +1, -1);
  Vector SignB(-1, +1, -1, +1);
  MatrixND<4, T, ISE> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA,
                              Inv3 * SignB);

  Vector Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

  Vector Dot0(m[0] * Row0);
  T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

  T OneOverDeterminant = static_cast<T>(1) / Dot1;

  return Inverse * OneOverDeterminant;
}

template <int dim, typename T, InstSetExt ISE>
TC_FORCE_INLINE MatrixND<dim, T, ISE> inverse(const MatrixND<dim, T, ISE> &m) {
  return inversed(m);
}

TC_FORCE_INLINE Vector3 multiply_matrix4(const Matrix4 &m,
                                         const Vector3 &v,
                                         real w) {
  return Vector3(m * Vector4(v, w));
}

template <int dim>
TC_FORCE_INLINE VectorND<dim, real> transform(const MatrixND<dim + 1, real> &m,
                                              const VectorND<dim, real> &v,
                                              real w = 1.0_f) {
  return VectorND<dim, real>(m * VectorND<dim + 1, real>(v, w));
}

// Type traits

template <typename T>
struct is_vector {
  static constexpr bool value = false;
};

template <int dim, typename T, InstSetExt ISE>
struct is_vector<VectorND<dim, T, ISE>> {
  static constexpr bool value = true;
};

template <typename T>
struct is_matrix {
  static constexpr bool value = false;
};

template <int dim, typename T, InstSetExt ISE>
struct is_matrix<MatrixND<dim, T, ISE>> {
  static constexpr bool value = true;
};

template <int dim, typename T>
TC_FORCE_INLINE VectorND<dim, T> min(const VectorND<dim, T> &a,
                                     const VectorND<dim, T> &b) {
  VectorND<dim, T> ret;
  for (int i = 0; i < dim; i++) {
    ret[i] = std::min(a[i], b[i]);
  }
  return ret;
}

template <int dim, typename T>
TC_FORCE_INLINE VectorND<dim, T> max(const VectorND<dim, T> &a,
                                     const VectorND<dim, T> &b) {
  VectorND<dim, T> ret;
  for (int i = 0; i < dim; i++) {
    ret[i] = std::max(a[i], b[i]);
  }
  return ret;
}

inline Matrix4 matrix4_translate(Matrix4 *transform, const Vector3 &offset) {
  return Matrix4(Vector4(1, 0, 0, 0), Vector4(0, 1, 0, 0), Vector4(0, 0, 1, 0),
                 Vector4(offset, 1.0_f)) *
         *transform;
}

inline Matrix4 matrix_translate(Matrix4 *transform, const Vector3 &offset) {
  return matrix4_translate(transform, offset);
}

inline Matrix3 matrix_translate(Matrix3 *transform, const Vector2 &offset) {
  return Matrix3(Vector3(1, 0, 0), Vector3(0, 1, 0), Vector3(offset, 1.0_f)) *
         *transform;
}

inline Matrix3 matrix_scale(Matrix3 *transform, const Vector2 &scales) {
  return Matrix3(Vector3(scales, 1.0_f)) * *transform;
}

inline Matrix4 matrix4_scale(Matrix4 *transform, const Vector3 &scales) {
  return Matrix4(Vector4(scales, 1.0_f)) * *transform;
}

inline Matrix4 matrix_scale(Matrix4 *transform, const Vector3 &scales) {
  return Matrix4(Vector4(scales, 1.0_f)) * *transform;
}

inline Matrix4 matrix4_scale_s(Matrix4 *transform, real s) {
  return matrix4_scale(transform, Vector3(s));
}

// Reference: https://en.wikipedia.org/wiki/Rotation_matrix
inline Matrix4 get_rotation_matrix(Vector3 u, real angle) {
  u = normalized(u);
  real c = cos(angle), s = sin(angle);
  real d = 1 - c;

  auto col0 = Vector4(c + u.x * u.x * d, u.x * u.y * d - u.z * s,
                      u.x * u.z * d + u.y * s, 0.0_f);
  auto col1 = Vector4(u.x * u.y * d + u.z * s, c + u.y * u.y * d,
                      u.y * u.z * d - u.x * s, 0.0_f);
  auto col2 = Vector4(u.x * u.z * d - u.y * s, u.y * u.z * d + u.x * s,
                      c + u.z * u.z * d, 0.0_f);
  auto col3 = Vector4(0.0_f, 0.0_f, 0.0_f, 1.0_f);

  return Matrix4(col0, col1, col2, col3).transposed();
}

inline Matrix4 matrix4_rotate_angle_axis(Matrix4 *transform,
                                         real angle,
                                         const Vector3 &axis) {
  return get_rotation_matrix(axis, angle * (pi / 180.0_f)) * *transform;
}

inline Matrix4 matrix4_rotate_euler(Matrix4 *transform,
                                    const Vector3 &euler_angles) {
  Matrix4 ret = *transform;
  ret = matrix4_rotate_angle_axis(&ret, euler_angles.x,
                                  Vector3(1.0_f, 0.0_f, 0.0_f));
  ret = matrix4_rotate_angle_axis(&ret, euler_angles.y,
                                  Vector3(0.0_f, 1.0_f, 0.0_f));
  ret = matrix4_rotate_angle_axis(&ret, euler_angles.z,
                                  Vector3(0.0_f, 0.0_f, 1.0_f));
  return ret;
}

template <typename T>
inline MatrixND<3, T> cross_product_matrix(const VectorND<3, T> &a) {
  return MatrixND<3, T>(VectorND<3, T>(0, a[2], -a[1]),
                        VectorND<3, T>(-a[2], 0, a[0]),
                        VectorND<3, T>(a[1], -a[0], 0));
};

static_assert(Serializer::has_io<Matrix4>::value, "");
static_assert(Serializer::has_io<const Matrix4>::value, "");
static_assert(Serializer::has_io<const Matrix4 &>::value, "");
static_assert(Serializer::has_io<Matrix4 &>::value, "");
static_assert(
    TextSerializer::has_io<
        const taichi::MatrixND<4, double, (taichi::InstSetExt)3>>::value,
    "");

namespace type {
template <typename T, typename = void>
struct element_;

template <typename T>
struct element_<T, typename std::enable_if_t<std::is_arithmetic<T>::value>> {
  using type = T;
};

template <typename T>
struct element_<T, typename std::enable_if_t<!std::is_arithmetic<T>::value>> {
  using type = typename T::ScalarType;
};

template <typename T>
using element = typename element_<std::decay_t<T>>::type;

template <typename>
struct is_VectorND : public std::false_type {};

template <int N, typename T, InstSetExt ISE>
struct is_VectorND<VectorND<N, T, ISE>> : public std::true_type {};

template <typename>
struct is_MatrixND : public std::false_type {};

template <int N, typename T, InstSetExt ISE>
struct is_MatrixND<MatrixND<N, T, ISE>> : public std::true_type {};
}  // namespace type

// Intrinsics
template <int i1>
TC_FORCE_INLINE float32 extract_float32(const __m128 &s) {
  int ret = _mm_extract_ps(s, i1);
  return reinterpret_cast<float32 *>(&ret)[0];
}

template <int i1>
TC_FORCE_INLINE __m128 broadcast(const __m128 &s) {
  return _mm_shuffle_ps(s, s, 0x55 * i1);
}

#if defined(TC_AMALGAMATED)
TC_FORCE_INLINE void polar_decomp(Matrix2 m, Matrix2 &R, Matrix2 &S) {
  auto x = m(0, 0) + m(1, 1);
  auto y = m(1, 0) - m(0, 1);
  auto scale = 1.0_f / std::sqrt(x * x + y * y);
  auto c = x * scale, s = y * scale;
  R(0, 0) = c;
  R(0, 1) = -s;
  R(1, 0) = s;
  R(1, 1) = c;
  S = transposed(R) * m;
}

// Based on http://www.seas.upenn.edu/~cffjiang/research/svd/svd.pdf
// Algorithm 4
inline void svd(Matrix2 m, Matrix2 &U, Matrix2 &sig, Matrix2 &V) {
  Matrix2 S;
  polar_decomp(m, U, S);
  real c, s;
  if (std::abs(S(0, 1)) < 1e-6_f) {
    sig = S;
    c = 1;
    s = 0;
  } else {
    auto tao = 0.5_f * (S(0, 0) - S(1, 1));
    auto w = std::sqrt(tao * tao + S(0, 1) * S(0, 1));
    auto t = tao > 0 ? S(0, 1) / (tao + w) : S(0, 1) / (tao - w);
    c = 1.0_f / std::sqrt(t * t + 1);
    s = -t * c;
    sig(0, 0) = pow<2>(c) * S(0, 0) - 2 * c * s * S(0, 1) + pow<2>(s) * S(1, 1);
    sig(1, 1) = pow<2>(s) * S(0, 0) + 2 * c * s * S(0, 1) + pow<2>(c) * S(1, 1);
  }
  if (sig(0, 0) < sig(1, 1)) {
    std::swap(sig(0, 0), sig(1, 1));
    V(0, 0) = -s;
    V(0, 1) = -c;
    V(1, 0) = c;
    V(1, 1) = -s;
  } else {
    V(0, 0) = c;
    V(0, 1) = -s;
    V(1, 0) = s;
    V(1, 1) = c;
  }
  V = transposed(V);
  U = U * V;
}

template <int dim, typename T>
inline void test_simple_decompositions() {
  using Matrix = MatrixND<dim, T>;
  T tolerance = std::is_same<T, float32>() ? 3e-5_f32 : 1e-12_f32;
  for (int i = 0; i < 10000; i++) {
    Matrix m = Matrix::rand();
    Matrix U, sig, V, Q, R, S;

    polar_decomp(m, R, S);
    TC_CHECK_EQUAL(m, R * S, tolerance);
    TC_CHECK_EQUAL(Matrix(1), R * transposed(R), tolerance);
    TC_CHECK_EQUAL(1.0_f, determinant(R), tolerance);
    TC_CHECK_EQUAL(S, transposed(S), tolerance);

    svd(m, U, sig, V);
    if (dim == 2) {
      CHECK(tolerance + sig(0, 0) > std::abs(sig(1, 1)));
    }
    TC_CHECK_EQUAL(m, U * sig * transposed(V), tolerance);
    TC_CHECK_EQUAL(Matrix(1), U * transposed(U), tolerance);
    TC_CHECK_EQUAL(Matrix(1), V * transposed(V), tolerance);
    TC_CHECK_EQUAL(1.0_f, determinant(U), tolerance);
    TC_CHECK_EQUAL(1.0_f, determinant(V), tolerance);
    TC_CHECK_EQUAL(sig, Matrix(sig.diag()), tolerance);
  }
};

/*
TC_TEST("SVD") {
  test_simple_decompositions<2, float32>();
}
*/
#endif

TC_NAMESPACE_END

TC_NAMESPACE_BEGIN

inline bool intersect(const Vector2 &a,
                      const Vector2 &b,
                      const Vector2 &c,
                      const Vector2 &d) {
  if (cross(c - a, b - a) * cross(b - a, d - a) > 0 &&
      cross(a - d, c - d) * cross(c - d, b - d) > 0) {
    return true;
  } else {
    return false;
  }
}

inline real nearest_distance(const Vector2 &p,
                             const Vector2 &a,
                             const Vector2 &b) {
  real ab = length(a - b);
  Vector2 dir = normalized(b - a);
  real pos = clamp(dot(p - a, dir), 0.0_f, ab);
  return length(a + pos * dir - p);
}

inline real nearest_distance(const Vector2 &p,
                             const std::vector<Vector2> &polygon) {
  real dist = std::numeric_limits<float>::infinity();
  for (int i = 0; i < (int)polygon.size(); i++) {
    dist = std::min(dist, nearest_distance(p, polygon[i],
                                           polygon[(i + 1) % polygon.size()]));
  }
  return dist;
}

inline bool inside_polygon(const Vector2 &p,
                           const std::vector<Vector2> &polygon) {
  int count = 0;
  static const Vector2 q(123532_f, 532421123_f);
  for (int i = 0; i < (int)polygon.size(); i++) {
    count += intersect(p, q, polygon[i], polygon[(i + 1) % polygon.size()]);
  }
  return count % 2 == 1;
}

inline std::vector<Vector2> points_inside_polygon(
    std::vector<float> x_range,
    std::vector<float> y_range,
    const std::vector<Vector2> &polygon) {
  std::vector<Vector2> ret;
  for (float x = x_range[0]; x < x_range[1]; x += x_range[2]) {
    for (float y = y_range[0]; y < y_range[1]; y += y_range[2]) {
      Vector2 p(x, y);
      if (inside_polygon(p, polygon)) {
        ret.push_back(p);
      }
    }
  }
  return ret;
}

inline std::vector<Vector2> points_inside_sphere(std::vector<float> x_range,
                                                 std::vector<float> y_range,
                                                 const Vector2 &center,
                                                 float radius) {
  std::vector<Vector2> ret;
  for (float x = x_range[0]; x < x_range[1]; x += x_range[2]) {
    for (float y = y_range[0]; y < y_range[1]; y += y_range[2]) {
      Vector2 p(x, y);
      if (length(p - center) < radius) {
        ret.push_back(p);
      }
    }
  }
  return ret;
}

inline Vector3 set_up(const Vector3 &a, const Vector3 &y) {
  Vector3 x, z;
  if (std::abs(y.y) > 1.0_f - eps) {
    x = Vector3(1, 0, 0);
  } else {
    x = normalize(cross(y, Vector3(0, 1, 0)));
  }
  z = cross(x, y);
  return a.x * x + a.y * y + a.z * z;
}

inline Vector3 random_diffuse(const Vector3 &normal, real u, real v) {
  if (u > v) {
    std::swap(u, v);
  }
  if (v < eps) {
    v = eps;
  }
  u /= v;
  real xz = v, y = sqrt(1 - v * v);
  real phi = u * pi * 2;
  return set_up(Vector3(xz * cos(phi), y, xz * sin(phi)), normal);
}

inline Vector3 random_diffuse(const Vector3 &normal) {
  return random_diffuse(normal, rand(), rand());
}

inline bool inside_unit_cube(const Vector3 &p) {
  return 0 <= p[0] && p[0] < 1 && 0 <= p[1] && p[1] < 1 && 0 <= p[2] &&
         p[2] < 1;
}

inline Vector3 sample_sphere(float u, float v) {
  float x = u * 2 - 1;
  float phi = v * 2 * pi;
  float yz = sqrt(1 - x * x);
  return Vector3(x, yz * cos(phi), yz * sin(phi));
}

inline Vector3 reflect(const Vector3 &d, const Vector3 &n) {
  return d - dot(d, n) * 2.0f * n;
}

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/



TC_NAMESPACE_BEGIN

template <typename T>
class Array1D {
 private:
 public:
  int size;
  std::vector<T> data;

  Array1D(int size);

  Array1D(int size, T init);

  Array1D(const Array1D<T> &arr);

  Array1D &operator=(const Array1D<T> &);

  Array1D();

  ~Array1D();

  void reset(T a);

  bool same_dim(const Array1D<T> &arr);

  real dot(const Array1D<T> &b);

  Array1D<T> add(real alpha, const Array1D<T> &b);

  Array1D<T> operator-(const Array1D<T> &b);

  T &operator[](int i) {
    return data[i];
  }

  const T &operator[](int i) const {
    return data[i];
  }

  T abs_sum();

  T abs_max();

  void print(std::string name = "");

  size_t get_data_size() const {
    return size * sizeof(T);
  }

  const std::vector<T> &get_data() const {
    return this->data;
  }

  int get_dim() const {
    return 1;
  }

  TC_IO_DECL {
    TC_IO(size);
    TC_IO(data);
  }
};

template <typename T>
Array1D<T>::Array1D(int size) : size(size) {
  data = std::vector<T>(size);
  // memcpy(&data[0], this->data, this->get_data_size());
}

template <typename T>
real Array1D<T>::dot(const Array1D<T> &b) {
  real sum(0);
  assert(same_dim(b));
  for (int i = 0; i < size; i++) {
    sum += dot(this->data[i], b.data[i]);
  }
  return sum;
}

template <typename T>
Array1D<T> Array1D<T>::add(real alpha, const Array1D<T> &b) {
  Array1D o(size);
  assert(same_dim(b));
  for (int i = 0; i < size; i++) {
    o.data[i] = data[i] + alpha * b.data[i];
  }
  return o;
}

template <typename T>
Array1D<T> Array1D<T>::operator-(const Array1D<T> &b) {
  Array1D o(size);
  assert(same_dim(b));
  for (int i = 0; i < size; i++) {
    o.data[i] = data[i] - b.data[i];
  }
  return o;
}

template <typename T>
T Array1D<T>::abs_sum() {
  T ret(0);
  for (int i = 0; i < size; i++) {
    ret += abs(data[i]);
  }
  return ret;
}

template <typename T>
T Array1D<T>::abs_max() {
  T ret(0);
  for (int i = 0; i < size; i++) {
    for (int k = 0; k < 2; k++) {
      ret[k] = max(ret[k], abs(data[i][k]));
    }
  }
  return ret;
}

template <typename T>
void Array1D<T>::print(std::string name) {
  TC_NOT_IMPLEMENTED
}

template <typename T>
void Array1D<T>::reset(T a) {
  for (int i = 0; i < size; i++) {
    data[i] = a;
  }
}

template <typename T>
Array1D<T>::~Array1D() {
}

template <typename T>
Array1D<T>::Array1D(const Array1D<T> &arr) : Array1D(arr.size) {
  data = arr.data;
}

template <typename T>
Array1D<T>::Array1D() {
  size = 0;
}

template <typename T>
Array1D<T>::Array1D(int size, T init) : Array1D<T>(size) {
  if (init == T(0.0_f)) {
    memset(&data[0], 0, get_data_size());
  } else {
    for (int i = 0; i < size; i++)
      data[i] = init;
  }
}

template <typename T>
bool Array1D<T>::same_dim(const Array1D<T> &arr) {
  return size == arr.size;
}

template <typename T>
Array1D<T> &Array1D<T>::operator=(const Array1D<T> &arr) {
  this->size = arr.size;
  data = arr.data;
  return *this;
}

typedef Array1D<Vector2> ArrayVec2;

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <cstring>
#include <cstdio>
#include <string>
#include <vector>
#include <iterator>


TC_NAMESPACE_BEGIN

template <>
class IndexND<2> {
 private:
  int x[2], y[2];

 public:
  using Index = IndexND<2>;

  int i, j;
  // int offset;
  int stride;
  Vector2 storage_offset;

  IndexND() {
  }

  IndexND(int x0,
          int x1,
          int y0,
          int y1,
          Vector2 storage_offset = Vector2(0.5f, 0.5f)) {
    x[0] = x0;
    x[1] = x1;
    y[0] = y0;
    y[1] = y1;
    i = x[0];
    j = y[0];
    // offset = 0;
    stride = y[1] - y[0];
    this->storage_offset = storage_offset;
  }

  IndexND(Vector2i start,
          Vector2i end,
          Vector2 storage_offset = Vector2(0.5f, 0.5f)) {
    x[0] = start[0];
    x[1] = end[0];
    y[0] = start[1];
    y[1] = end[1];
    i = x[0];
    j = y[0];
    // offset = 0;
    stride = y[1] - y[0];
    this->storage_offset = storage_offset;
  }

  IndexND(int i, int j) {
    this->i = i;
    this->j = j;
  }

  void next() {
    j++;
    // offset++;
    if (j == y[1]) {
      j = y[0];
      i++;
      if (i == x[1]) {
      }
    }
  }

  Index operator++() {
    this->next();
    return *this;
  }

  bool operator==(const IndexND<2> &o) const {
    return (i == o.i && j == o.j);
  }

  bool operator!=(const IndexND<2> &o) const {
    return !(i == o.i && j == o.j);
  }

  Index &to_end() {
    i = x[1];
    j = y[0];
    // offset = (x[1] - x[0]) * (y[1] - y[0]);
    return *this;
  }

  const Index &operator*() const {
    return *this;
  }

  Index &operator*() {
    return *this;
  }

  int operator[](int c) {
    return *(&i + c);
  }

  int operator[](int c) const {
    return *(&i + c);
  }

  Index neighbour(int di, int dj) const {
    Index i = *this;
    i.i += di;
    i.j += dj;
    return i;
  }

  Index neighbour(Vector2i d) const {
    Index i = *this;
    i.i += d.x;
    i.j += d.y;
    return i;
  }

  Index operator+(Vector2i d) const {
    return neighbour(d);
  }

  Vector2 get_pos() const {
    return Vector2((real)i + storage_offset.x, (real)j + storage_offset.y);
  }

  Vector2i get_ipos() const {
    return Vector2i(i, j);
  }
};

typedef IndexND<2> Index2D;

template <>
class RegionND<2> {
 private:
  int x[2], y[2];
  Index2D index_begin;
  Index2D index_end;
  Vector2 storage_offset;

 public:
  using Region = RegionND<2>;

  RegionND() {
  }

  RegionND(int x0,
           int x1,
           int y0,
           int y1,
           Vector2 storage_offset = Vector2(0.5f, 0.5f)) {
    x[0] = x0;
    x[1] = x1;
    y[0] = y0;
    y[1] = y1;
    index_begin = Index2D(x0, x1, y0, y1, storage_offset);
    index_end = Index2D(x0, x1, y0, y1, storage_offset).to_end();
    this->storage_offset = storage_offset;
  }

  RegionND(Vector2i start,
           Vector2i end,
           Vector2 storage_offset = Vector2(0.5f, 0.5f)) {
    x[0] = start[0];
    x[1] = end[0];
    y[0] = start[1];
    y[1] = end[1];
    index_begin = Index2D(start, end, storage_offset);
    index_end = Index2D(start, end, storage_offset).to_end();
    this->storage_offset = storage_offset;
  }

  const Index2D begin() const {
    return index_begin;
  }

  Index2D begin() {
    return index_begin;
  }

  const Index2D end() const {
    return index_end;
  }

  Index2D end() {
    return index_end;
  }
};

typedef RegionND<2> Region2D;

template <typename T>
class ArrayND<2, T> {
 protected:
  Region2D region;
  typedef typename std::vector<T>::iterator iterator;
  int size;
  Vector2i res;
  Vector2 storage_offset = Vector2(0.5f, 0.5f);  // defualt : center storage
 public:
  std::vector<T> data;
  template <typename S>
  using Array2D = ArrayND<2, S>;

  template <typename P>
  friend Array2D<T> operator*(const P &b, const Array2D<T> &a);

  int get_size() const {
    return size;
  }

  const Region2D &get_region() const {
    return region;
  }

  ArrayND(const Vector2i &res,
          T init = T(0),
          Vector2 storage_offset = Vector2(0.5f)) {
    initialize(res, init, storage_offset);
  }

  void initialize(const Vector2i &res,
                  T init = T(0),
                  Vector2 storage_offset = Vector2(0.5f)) {
    this->res = res;
    region = Region2D(0, res[0], 0, res[1], storage_offset);
    size = res[0] * res[1];
    data = std::vector<T>(size, init);
    this->storage_offset = storage_offset;
  }

  Array2D<T> same_shape(T init) const {
    return ArrayND<2, T>(res, init, storage_offset);
  }

  Array2D<T> same_shape() const {
    return ArrayND<2, T>(res);
  }

  ArrayND(const Array2D<T> &arr) : ArrayND(arr.res) {
    this->data = arr.data;
    this->storage_offset = arr.storage_offset;
  }

  template <typename P>
  Array2D<T> operator*(const P &b) const {
    Array2D<T> o(res);
    for (int i = 0; i < size; i++) {
      o.data[i] = b * data[i];
    }
    return o;
  }

  template <typename P>
  Array2D<T> operator/(const P &b) const {
    b = T(1) / b;
    return b * (*this);
  }

  Array2D<T> operator+(const Array2D<T> &b) const {
    Array2D<T> o(res);
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      o.data[i] = data[i] + b.data[i];
    }
    return o;
  }

  Array2D<T> operator-(const Array2D<T> &b) const {
    Array2D<T> o(res);
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      o.data[i] = data[i] - b.data[i];
    }
    return o;
  }

  void operator+=(const Array2D<T> &b) {
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      data[i] = data[i] + b.data[i];
    }
  }

  void operator-=(const Array2D<T> &b) {
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      data[i] = data[i] - b.data[i];
    }
  }

  Array2D<T> &operator=(const Array2D<T> &arr) {
    this->res = arr.res;
    this->size = arr.size;
    this->data = arr.data;
    this->region = arr.region;
    this->storage_offset = arr.storage_offset;
    return *this;
  }

  Array2D<T> &operator=(const T &a) {
    for (int i = 0; i < size; i++) {
      data[i] = a;
    }
    return *this;
  }

  ArrayND() {
    res = Vector2i(0);
    size = 0;
    data.resize(0);
  }

  ~ArrayND() {
  }

  void reset(T a) {
    for (int i = 0; i < size; i++) {
      data[i] = a;
    }
  }

  void reset_zero() {
    memset(&data[0], 0, sizeof(T) * data.size());
  }

  bool same_dim(const Array2D<T> &arr) const {
    return res == arr.res;
  }

  T dot(const Array2D<T> &b) const {
    T sum = 0;
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      sum += this->data[i] * b.data[i];
    }
    return sum;
  }

  double dot_double(const Array2D<T> &b) const {
    double sum = 0;
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      sum += this->data[i] * b.data[i];
    }
    return sum;
  }

  Array2D<T> add(T alpha, const Array2D<T> &b) const {
    Array2D<T> o(res);
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      o.data[i] = data[i] + alpha * b.data[i];
    }
    return o;
  }

  void add_in_place(T alpha, const Array2D<T> &b) {
    for (int i = 0; i < size; i++) {
      data[i] += alpha * b.data[i];
    }
  }

  T *operator[](int i) {
    return &data[0] + i * res[1];
  }

  const T *operator[](int i) const {
    return &data[0] + i * res[1];
  }

  const T &get(int i, int j) const {
    return (*this)[i][j];
  }

  const T &get(const Index2D &ind) const {
    return get(ind.i, ind.j);
  }

  T get_copy(int i, int j) const {
    return (*this)[i][j];
  }

  void set(int i, int j, const T &t) {
    (*this)[i][j] = t;
  }

  void set(const Index2D &ind, const T &t) {
    (*this)[ind] = t;
  }

  T abs_sum() const {
    T ret = 0;
    for (int i = 0; i < size; i++) {
      ret += std::abs(data[i]);
    }
    return ret;
  }

  T sum() const {
    T ret = 0;
    for (int i = 0; i < size; i++) {
      ret += data[i];
    }
    return ret;
  }

  template <typename TT = T,
            typename std::enable_if_t<!std::is_class<TT>::value, int> = 0>
  T abs_max() const {
    T ret(0);
    for (int i = 0; i < size; i++) {
      ret = std::max(ret, abs(data[i]));
    }
    return ret;
  }

  template <typename TT = T, typename TS = typename TT::ScalarType>
  TS abs_max() const {
    TS ret(0);
    for (int i = 0; i < size; i++) {
      ret = std::max(ret, data[i].abs().max());
    }
    return ret;
  }

  T min() const {
    T ret = std::numeric_limits<T>::max();
    for (int i = 0; i < size; i++) {
      ret = std::min(ret, data[i]);
    }
    return ret;
  }

  T max() const {
    T ret = std::numeric_limits<T>::min();
    for (int i = 0; i < size; i++) {
      ret = std::max(ret, data[i]);
    }
    return ret;
  }

  void print_abs_max_pos() const {
    T ret = abs_max();
    for (auto &ind : get_region()) {
      if (abs(this->operator[](ind)) == ret) {
        printf("  [%d, %d]\n", ind.i, ind.j);
      }
    }
  }

  template <typename TT = T,
            typename std::enable_if_t<!std::is_class<TT>::value, int> = 0>
  void print(std::string name = "", const char *temp = "%f") const {
    if (name.size())
      printf("%s[%dx%d]=", name.c_str(), res[0], res[1]);
    printf("\n");
    for (int j = res[1] - 1; j >= 0; j--) {
      for (int i = 0; i < res[0]; i++) {
        printf(temp, (*this)[i][j]);
        printf(" ");
      }
      printf("\n");
    }
    printf("\n");
  }

  template <typename TT = T, typename TS = typename TT::ScalarType>
  void print(std::string name = "", const char *temp = "%f") const {
    if (name.size())
      printf("%s[%dx%d]=", name.c_str(), res[0], res[1]);
    printf("\n");
    for (int j = res[1] - 1; j >= 0; j--) {
      for (int i = 0; i < res[0]; i++) {
        printf("(");
        for (int k = 0; k < TT::D; k++) {
          printf(temp, (*this)[i][j][k]);
          if (k != TT::D - 1) {
            printf(", ");
          }
        }
        printf(") ");
      }
      printf("\n");
    }
    printf("\n");
  }

  size_t get_data_size() const {
    return size * sizeof(T);
  }

  void set_pattern(int s) {
    for (int i = 0; i < size; i++) {
      data[i] = sinf(s * i + 231.0_f);
    }
  }

  bool inside(int i, int j) const {
    return 0 <= i && i < res[0] && 0 <= j && j < res[1];
  }

  bool inside(const Vector2i &pos) const {
    return inside(pos[0], pos[1]);
  }

  bool inside(const Index2D &index) const {
    return inside(index.i, index.j);
  }

  T sample(real x, real y) const {
    x = clamp(x - storage_offset.x, 0.0_f, res[0] - 1.0_f - eps);
    y = clamp(y - storage_offset.y, 0.0_f, res[1] - 1.0_f - eps);
    int x_i = clamp(int(x), 0, res[0] - 2);
    int y_i = clamp(int(y), 0, res[1] - 2);
    real x_r = x - x_i;
    real y_r = y - y_i;
    return lerp(x_r, lerp(y_r, get(x_i, y_i), get(x_i, y_i + 1)),
                lerp(y_r, get(x_i + 1, y_i), get(x_i + 1, y_i + 1)));
  }

  T sample(const Vector2 &v) const {
    return sample(v.x, v.y);
  }

  T sample(const Index2D &v) const {
    return sample(v.get_pos());
  }

  Vector2 get_storage_offset() const {
    return storage_offset;
  }

  T sample_relative_coord(real x, real y) const {
    x = x * res[0];
    y = y * res[1];
    return sample(x, y);
  }

  T sample_relative_coord(const Vector2 &vec) const {
    real x = vec.x * res[0];
    real y = vec.y * res[1];
    return sample(x, y);
  }

  auto begin() const {
    return data.cbegin();
  }

  auto end() const {
    return data.cend();
  }

  auto begin() {
    return data.begin();
  }

  auto end() {
    return data.end();
  }

  T &operator[](const Vector2i &pos) {
    return (*this)[pos.x][pos.y];
  }

  const T &operator[](const Vector2i &pos) const {
    return (*this)[pos.x][pos.y];
  }

  T &operator[](const Index2D &index) {
    return (*this)[index.i][index.j];
  }

  const T &operator[](const Index2D &index) const {
    return (*this)[index.i][index.j];
  }

  Vector2i get_res() const {
    return res;
  }

  int get_width() const {
    return res[0];
  }

  int get_height() const {
    return res[1];
  }

  bool empty() const {
    return !(res[0] > 0 && res[1] > 0);
  }

  T get_average() const {
    T sum(0);
    for (int i = 0; i < res[0]; i++) {
      for (int j = 0; j < res[1]; j++) {
        sum += get(i, j);
      }
    }
    return 1.0_f / size * sum;
  }

  bool inside(const Vector2 &pos, real tolerance = 1e-4f) const {
    return (-tolerance <= pos.x && pos.x <= res[0] + tolerance &&
            -tolerance <= pos.y && pos.y < res[1] + tolerance);
  }

  Region2D get_rasterization_region(Vector2 pos, int half_extent) const {
    int x = (int)floor(pos.x - storage_offset.x);
    int y = (int)floor(pos.y - storage_offset.y);
    return Region2D(std::max(0, x - half_extent + 1),
                    std::min(res[0], x + half_extent + 1),
                    std::max(0, y - half_extent + 1),
                    std::min(res[1], y + half_extent + 1), storage_offset);
  }

  bool is_normal() const {
    for (auto v : (*this)) {
      if (!taichi::is_normal(v)) {
        return false;
      }
    }
    return true;
  }

  Array2D<T> rasterize(int width, int height) {
    Array2D<T> out(Vector2i(width, height));
    Vector2 actual_size;
    if (storage_offset == Vector2(0.0_f, 0.0_f)) {
      actual_size = Vector2(this->res[0] - 1, this->res[1] - 1);
    } else {
      actual_size = Vector2(this->res[0], this->res[1]);
    }

    Vector2 scale_factor = actual_size / res.cast<real>();

    for (auto &ind : Region2D(0, res[0], 0, res[1], Vector2(0.5f, 0.5f))) {
      Vector2 p = scale_factor * ind.get_pos();
      out[ind] = sample(p);
    }
    return out;
  }

  Array2D<T> rasterize_scale(int width, int height, int scale) {
    Array2D<T> out(Vector2i(width, height));
    for (auto &ind : out.get_region()) {
      out[ind] = (*this)[ind.i / scale][ind.j / scale];
    }
    return out;
  }

  const std::vector<T> &get_data() const {
    return this->data;
  }

  static constexpr int get_dim() {
    return 2;
  }

  void flip(int axis) {
    if (axis == 0) {
      for (int i = 0; i < res[0] / 2; i++) {
        for (int j = 0; j < res[1]; j++) {
          std::swap((*this)[i][j], (*this)[res[0] - 1 - i][j]);
        }
      }
    } else {
      for (int i = 0; i < res[0]; i++) {
        for (int j = 0; j < res[1] / 2; j++) {
          std::swap((*this)[i][j], (*this)[i][res[1] - 1 - j]);
        }
      }
    }
  }

  // TODO: finally we are going to need a binary serializer

  void write_to_disk(const std::string &fn) {
    FILE *f = fopen(fn.c_str(), "wb");
    fwrite(&res[0], sizeof(res[0]), 1, f);
    fwrite(&res[1], sizeof(res[1]), 1, f);
    fwrite(&storage_offset, sizeof(storage_offset), 1, f);
    fwrite(&region, sizeof(region), 1, f);
    fwrite(&data[0], sizeof(data[0]), size, f);
    fclose(f);
  }

  bool read_from_disk(const std::string &fn) {
    FILE *f = fopen(fn.c_str(), "rb");
    if (f == nullptr) {
      return false;
    }
    size_t ret;
    ret = fread(&res[0], sizeof(res[0]), 1, f);
    if (ret != 1) {
      return false;
    }
    ret = fread(&res[1], sizeof(res[1]), 1, f);
    if (ret != 1) {
      return false;
    }
    ret = fread(&storage_offset, sizeof(storage_offset), 1, f);
    if (ret != 1) {
      return false;
    }
    ret = fread(&region, sizeof(region), 1, f);
    if (ret != 1) {
      return false;
    }
    initialize(res, T(0), storage_offset);
    ret = (int)std::fread(&data[0], sizeof(data[0]), size, f);
    if (ret != (std::size_t)size) {
      return false;
    }
    fclose(f);
    return true;
  }

  ArrayND(const std::string &filename) {
    load_image(filename);
  }

  void load_image(const std::string &filename, bool linearize = true);

  void set_pixel(real x, real y, const T &pixel) {
    x *= this->res[0];
    y *= this->res[1];
    x -= 0.5f;
    y -= 0.5f;
    int int_x = (int)x;
    int int_y = (int)y;
    if (int_x < 0 || int_x >= this->res[0] || int_y < 0 ||
        int_y >= this->res[1])
      return;
    this->operator[](int_x)[int_y] = pixel;
  }

  T sample_as_texture(real x, real y, bool interp = true) {
    x *= this->res[0];
    y *= this->res[1];
    x -= 0.5f;
    y -= 0.5f;
    x = clamp(x, 0.0_f, this->res[0] - 1.0_f);
    y = clamp(y, 0.0_f, this->res[1] - 1.0_f);
    int ix = clamp(int(x), 0, this->res[0] - 2);
    int iy = clamp(int(y), 0, this->res[1] - 2);
    if (!interp) {
      x = real(ix);
      y = real(iy);
    }
    T x_0 = lerp(y - iy, (*this)[ix][iy], (*this)[ix][iy + 1]);
    T x_1 = lerp(y - iy, (*this)[ix + 1][iy], (*this)[ix + 1][iy + 1]);
    return lerp(x - ix, x_0, x_1);
  }

  void write_as_image(const std::string &filename);

  void write_text(const std::string &font_fn,
                  const std::string &content,
                  real size,
                  int dx,
                  int dy,
                  T color = T(1.0_f));
};

template <typename T>
using Array2D = ArrayND<2, T>;

template <typename T, typename P>
inline Array2D<T> operator*(const P &b, const Array2D<T> &a) {
  Array2D<T> o(a.res);
  for (int i = 0; i < a.size; i++) {
    o.data[i] = b * a.data[i];
  }
  return o;
}

template <typename T>
inline void print(const Array2D<T> &arr) {
  arr.print("");
}

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <cstring>
#include <cstdio>
#include <string>
#include <vector>
#include <iterator>


TC_NAMESPACE_BEGIN

template <>
class IndexND<3> {
 private:
  int x[2], y[2], z[2];

 public:
  int i, j, k;
  Vector3 storage_offset;

  TC_IO_DEF(i, j, k, x, y, z, storage_offset);
  using Index3D = IndexND<3>;

  IndexND() {
  }

  IndexND(int x0,
          int x1,
          int y0,
          int y1,
          int z0,
          int z1,
          Vector3 storage_offset = Vector3(0.5f, 0.5f, 0.5f)) {
    x[0] = x0;
    x[1] = x1;
    y[0] = y0;
    y[1] = y1;
    z[0] = z0;
    z[1] = z1;
    i = x[0];
    j = y[0];
    k = z[0];
    this->storage_offset = storage_offset;
  }

  IndexND(Vector3i start,
          Vector3i end,
          Vector3 storage_offset = Vector3(0.5f, 0.5f, 0.5f)) {
    x[0] = start[0];
    x[1] = end[0];
    y[0] = start[1];
    y[1] = end[1];
    z[0] = start[2];
    z[1] = end[2];
    i = x[0];
    j = y[0];
    k = z[0];
    this->storage_offset = storage_offset;
  }

  IndexND(int i, int j, int k) {
    this->i = i;
    this->j = j;
    this->k = k;
  }

  IndexND(Vector3i p) {
    this->i = p[0];
    this->j = p[1];
    this->k = p[2];
  }

  void next() {
    k++;
    if (k == z[1]) {
      k = z[0];
      j++;
      if (j == y[1]) {
        j = y[0];
        i++;
        if (i == x[1]) {
        }
      }
    }
  }

  Index3D operator++() {
    this->next();
    return *this;
  }

  bool operator==(const Index3D &o) const {
    return (i == o.i && j == o.j && k == o.k);
  }

  bool operator<(const Index3D &o) const {
    return i < o.i || (i == o.i && (j < o.j)) ||
           (i == o.i && j == o.j && k < o.k);
  }

  bool operator!=(const Index3D &o) const {
    return !(i == o.i && j == o.j && k == o.k);
  }

  Index3D &to_end() {
    if (x[0] >= x[1] || y[0] >= y[1] || z[0] >= z[1])
      i = x[0];
    else
      i = x[1];
    j = y[0];
    k = z[0];
    return *this;
  }

  const Index3D &operator*() const {
    return *this;
  }

  Index3D &operator*() {
    return *this;
  }

  TC_FORCE_INLINE int operator[](int c) {
    return *(&i + c);
  }

  TC_FORCE_INLINE int operator[](int c) const {
    return *(&i + c);
  }

  Index3D neighbour(int di, int dj, int dk) const {
    Index3D i = *this;
    i.i += di;
    i.j += dj;
    i.k += dk;
    return i;
  }

  Index3D neighbour(Vector3i d) const {
    Index3D i = *this;
    i.i += d.x;
    i.j += d.y;
    i.k += d.z;
    return i;
  }

  Index3D operator+(Vector3i d) const {
    return neighbour(d);
  }

  Vector3 get_pos() const {
    return Vector3((real)i + storage_offset.x, (real)j + storage_offset.y,
                   (real)k + storage_offset.z);
  }

  Vector3i get_ipos() const {
    return Vector3i(i, j, k);
  }
};

using Index3D = IndexND<3>;

template <>
class RegionND<3> {
 private:
  int x[2], y[2], z[2];
  Index3D index_begin;
  Index3D index_end;
  Vector3 storage_offset;

 public:
  using Region3D = RegionND<3>;

  RegionND() {
  }

  RegionND(int x0,
           int x1,
           int y0,
           int y1,
           int z0,
           int z1,
           Vector3 storage_offset = Vector3(0.5f, 0.5f, 0.5f)) {
    x[0] = x0;
    x[1] = x1;
    y[0] = y0;
    y[1] = y1;
    z[0] = z0;
    z[1] = z1;
    index_begin = Index3D(x0, x1, y0, y1, z0, z1, storage_offset);
    index_end = Index3D(x0, x1, y0, y1, z0, z1, storage_offset).to_end();
    this->storage_offset = storage_offset;
  }

  RegionND(Vector3i start,
           Vector3i end,
           Vector3 storage_offset = Vector3(0.5f, 0.5f, 0.5f)) {
    x[0] = start[0];
    x[1] = end[0];
    y[0] = start[1];
    y[1] = end[1];
    z[0] = start[2];
    z[1] = end[2];
    index_begin = Index3D(start, end, storage_offset);
    index_end = Index3D(start, end, storage_offset).to_end();
    this->storage_offset = storage_offset;
  }

  const Index3D begin() const {
    return index_begin;
  }

  Index3D begin() {
    return index_begin;
  }

  const Index3D end() const {
    return index_end;
  }

  Index3D end() {
    return index_end;
  }

  TC_IO_DECL {
    TC_IO(x);
    TC_IO(y);
    TC_IO(z);
    TC_IO(index_begin);
    TC_IO(index_end);
    TC_IO(storage_offset);
  }
};

using Region3D = RegionND<3>;

template <typename T>
class ArrayND<3, T> {
 protected:
  Region3D region;
  typedef typename std::vector<T>::iterator iterator;
  int size;
  Vector3i res;
  int stride;
  Vector3 storage_offset =
      Vector3(0.5f, 0.5f, 0.5f);  // defualt : center storage
  struct Accessor2D {
    T *data;
    int offset;

    TC_FORCE_INLINE Accessor2D(T *data, int offset)
        : data(data), offset(offset) {
    }

    TC_FORCE_INLINE T *operator[](int i) const {
      return data + offset * i;
    }
  };

  struct ConstAccessor2D {
    const T *data;
    int offset;

    TC_FORCE_INLINE ConstAccessor2D(const T *data, int offset)
        : data(data), offset(offset) {
    }

    TC_FORCE_INLINE const T *operator[](int i) const {
      return data + offset * i;
    }
  };

 public:
  std::vector<T> data;
  template <typename S>
  using Array3D = ArrayND<3, S>;

  TC_FORCE_INLINE int get_size() const {
    return size;
  }

  TC_FORCE_INLINE const Region3D &get_region() const {
    return region;
  }

  TC_FORCE_INLINE ArrayND(const Vector3i &resolution,
                          T init = T(0),
                          Vector3 storage_offset = Vector3(0.5f)) {
    initialize(resolution, init, storage_offset);
  }

  void initialize(const Vector3i &res,
                  T init = T(0),
                  Vector3 storage_offset = Vector3(0.5f)) {
    this->res = res;
    region = Region3D(0, res[0], 0, res[1], 0, res[2], storage_offset);
    size = res[0] * res[1] * res[2];
    stride = res[1] * res[2];
    data = std::vector<T>(size, init);
    this->storage_offset = storage_offset;
  }

  Array3D<T> same_shape(T init = T(0)) const {
    return Array3D<T>(res, init, storage_offset);
  }

  ArrayND(const Array3D<T> &arr) : ArrayND(arr.res) {
    this->data = arr.data;
    this->storage_offset = arr.storage_offset;
  }

  Array3D<T> operator+(const Array3D<T> &b) const {
    Array3D<T> o(res);
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      o.data[i] = data[i] + b.data[i];
    }
    return o;
  }

  Array3D<T> operator-(const Array3D<T> &b) const {
    Array3D<T> o(res);
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      o.data[i] = data[i] - b.data[i];
    }
    return o;
  }

  void operator+=(const Array3D<T> &b) {
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      data[i] = data[i] + b.data[i];
    }
  }

  void operator-=(const Array3D<T> &b) {
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      data[i] = data[i] - b.data[i];
    }
  }

  Array3D<T> &operator=(const Array3D<T> &arr) {
    this->res = arr.res;
    this->size = arr.size;
    this->stride = arr.stride;
    this->data = arr.data;
    this->region = arr.region;
    this->storage_offset = arr.storage_offset;
    return *this;
  }

  Array3D<T> &operator=(const T &a) {
    for (int i = 0; i < size; i++) {
      data[i] = a;
    }
    return *this;
  }

  ArrayND() {
    res = Vector3i(0);
    size = 0;
    stride = 0;
    data.resize(0);
  }

  ~ArrayND() {
  }

  void reset(T a) {
    for (int i = 0; i < size; i++) {
      data[i] = a;
    }
  }

  void reset_zero() {
    memset(&data[0], 0, sizeof(T) * data.size());
  }

  bool same_dim(const Array3D<T> &arr) const {
    return res == arr.res;
  }

  T dot(const Array3D<T> &b) const {
    T sum = 0;
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      sum += this->data[i] * b.data[i];
    }
    return sum;
  }

  double dot_double(const Array3D<T> &b) const {
    double sum = 0;
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      sum += this->data[i] * b.data[i];
    }
    return sum;
  }

  Array3D<T> add(T alpha, const Array3D<T> &b) const {
    Array3D<T> o(res);
    assert(same_dim(b));
    for (int i = 0; i < size; i++) {
      o.data[i] = data[i] + alpha * b.data[i];
    }
    return o;
  }

  void add_in_place(T alpha, const Array3D<T> &b) {
    for (int i = 0; i < size; i++) {
      data[i] += alpha * b.data[i];
    }
  }

  TC_FORCE_INLINE const Accessor2D operator[](int i) {
    return Accessor2D(&data[0] + i * stride, res[2]);
  }

  TC_FORCE_INLINE const ConstAccessor2D operator[](int i) const {
    return ConstAccessor2D(&data[0] + i * stride, res[2]);
  }

  const T &get(int i, int j, int k) const {
    return (*this)[i][j][k];
  }

  const T &get(const Index3D &ind) const {
    return get(ind.i, ind.j, ind.k);
  }

  T &set_if_inside(const Index3D &ind, const T &val) {
    if (inside(ind))
      (*this)[ind] = val;
  }

  T &add_if_inside(const Index3D &ind, const T &val) {
    if (inside(ind))
      (*this)[ind] += val;
  }

  T get_copy(int i, int j, int k) const {
    return (*this)[i][j][k];
  }

  void set(int i, int j, int k, const T &t) {
    (*this)[i][j][k] = t;
  }

  void set(const Index3D &ind, const T &t) {
    (*this)[ind] = t;
  }

  T abs_sum() const {
    T ret = 0;
    for (int i = 0; i < size; i++) {
      ret += abs(data[i]);
    }
    return ret;
  }

  T sum() const {
    T ret = 0;
    for (int i = 0; i < size; i++) {
      ret += data[i];
    }
    return ret;
  }

  T min() const {
    T ret = std::numeric_limits<T>::max();
    for (int i = 0; i < size; i++) {
      ret = std::min(ret, data[i]);
    }
    return ret;
  }

  T max() const {
    T ret = std::numeric_limits<T>::min();
    for (int i = 0; i < size; i++) {
      ret = std::max(ret, data[i]);
    }
    return ret;
  }

  void print_abs_max_pos() const {
    T ret = abs_max();
    for (auto &ind : get_region()) {
      if (abs(this->operator[](ind)) == ret) {
        printf("  [%d, %d, %d]\n", ind.i, ind.j, ind.k);
      }
    }
  }

  void print(std::string name = "", const char *temp = "%f") const {
    if (name.size())
      printf("%s[%dx%d]=", name.c_str(), res[0], res[1]);
    printf("\n");
    for (int k = 0; k < res[2]; k++) {
      for (int j = res[1] - 1; j >= 0; j--) {
        for (int i = 0; i < res[0]; i++) {
          printf(temp, (*this)[i][j][k]);
          printf(" ");
        }
        printf("\n");
      }
      printf("\n");
    }
    printf("\n");
  }

  size_t get_data_size() const {
    return size * sizeof(T);
  }

  void set_pattern(int s) {
    for (int i = 0; i < size; i++) {
      data[i] = sinf(s * i + 231.0_f);
    }
  }

  bool inside(int i, int j, int k) const {
    return 0 <= i && i < res[0] && 0 <= j && j < res[1] && 0 <= k && k < res[2];
  }

  bool inside(const Vector3i &pos) const {
    return inside(pos[0], pos[1], pos[2]);
  }

  bool inside(const Index3D &index) const {
    return inside(index.i, index.j, index.k);
  }

  T sample(real x, real y, real z) const {
    x = clamp(x - storage_offset.x, 0.0_f, res[0] - 1.0_f - eps);
    y = clamp(y - storage_offset.y, 0.0_f, res[1] - 1.0_f - eps);
    z = clamp(z - storage_offset.z, 0.0_f, res[2] - 1.0_f - eps);
    int x_i = clamp(int(x), 0, res[0] - 2);
    int y_i = clamp(int(y), 0, res[1] - 2);
    int z_i = clamp(int(z), 0, res[2] - 2);
    real x_r = x - x_i;
    real y_r = y - y_i;
    real z_r = z - z_i;
    return lerp(
        z_r,
        lerp(x_r, lerp(y_r, get(x_i, y_i, z_i), get(x_i, y_i + 1, z_i)),
             lerp(y_r, get(x_i + 1, y_i, z_i), get(x_i + 1, y_i + 1, z_i))),
        lerp(x_r, lerp(y_r, get(x_i, y_i, z_i + 1), get(x_i, y_i + 1, z_i + 1)),
             lerp(y_r, get(x_i + 1, y_i, z_i + 1),
                  get(x_i + 1, y_i + 1, z_i + 1))));
  }

  T sample(const Vector3 &v) const {
    return sample(v.x, v.y, v.z);
  }

  T sample(const Index3D &v) const {
    return sample(v.get_pos());
  }

  Vector3 get_storage_offset() const {
    return storage_offset;
  }

  T sample_relative_coord(const Vector3 &vec) const {
    real x = vec.x * res[0];
    real y = vec.y * res[1];
    real z = vec.z * res[2];
    return sample(x, y, z);
  }

  T sample_relative_coord(real x, real y, real z) const {
    x = x * res[0];
    y = y * res[1];
    z = z * res[2];
    return sample(x, y, z);
  }

  template <typename TT = T,
            typename std::enable_if_t<!std::is_class<TT>::value, int> = 0>
  T abs_max() const {
    T ret(0);
    for (int i = 0; i < size; i++) {
      ret = std::max(ret, abs(data[i]));
    }
    return ret;
  }

  template <typename TT = T, typename TS = typename TT::ScalarType>
  TS abs_max() const {
    TS ret(0);
    for (int i = 0; i < size; i++) {
      ret = std::max(ret, data[i].abs().max());
    }
    return ret;
  }

  auto begin() const {
    return data.cbegin();
  }

  auto end() const {
    return data.cend();
  }

  TC_FORCE_INLINE T &operator[](const Vector3i &pos) {
    return data[(pos.x * res[1] + pos.y) * res[2] + pos.z];
  }

  TC_FORCE_INLINE const T &operator[](const Vector3i &pos) const {
    return (*this)[pos.x][pos.y][pos.z];
  }

  TC_FORCE_INLINE T &operator[](const Index3D &index) {
    return (*this)[index.i][index.j][index.k];
  }

  TC_FORCE_INLINE const T &operator[](const Index3D &index) const {
    return (*this)[index.i][index.j][index.k];
  }

  Vector3i get_res() const {
    return res;
  }

  int get_width() const {
    return res[0];
  }

  int get_height() const {
    return res[1];
  }

  int get_depth() const {
    return res[2];
  }

  bool empty() const {
    return size == 0;
  }

  T get_average() const {
    T sum(0);
    for (int i = 0; i < res[0]; i++) {
      for (int j = 0; j < res[1]; j++) {
        for (int k = 0; k < res[2]; k++) {
          sum += get(i, j, k);
        }
      }
    }
    return 1.0_f / size * sum;
  }

  bool inside(const Vector3 &pos, real tolerance = 1e-4f) const {
    return (-tolerance < pos.x && pos.x < res[0] + tolerance &&
            -tolerance < pos.y && pos.y < res[1] + tolerance &&
            -tolerance < pos.z && pos.z < res[2] + tolerance);
  }

  Region3D get_rasterization_region(Vector3 pos, int half_extent) const {
    int x = (int)floor(pos.x - storage_offset.x);
    int y = (int)floor(pos.y - storage_offset.y);
    int z = (int)floor(pos.z - storage_offset.z);
    return Region3D(
        std::max(0, x - half_extent + 1), std::min(res[0], x + half_extent + 1),
        std::max(0, y - half_extent + 1), std::min(res[1], y + half_extent + 1),
        std::max(0, z - half_extent + 1), std::min(res[2], z + half_extent + 1),
        storage_offset);
  }

  bool is_normal() const {
    for (auto v : (*this)) {
      if (!taichi::is_normal(v)) {
        return false;
      }
    }
    return true;
  }

  const std::vector<T> &get_data() const {
    return this->data;
  }

  std::vector<T> &get_data() {
    return this->data;
  }

  static constexpr int get_dim() {
    return 3;
  }
};

template <typename T>
using Array3D = ArrayND<3, T>;

template <typename T>
void print(const Array3D<T> &arr) {
  arr.print("");
}

void test_array_3d();
TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/



TC_NAMESPACE_BEGIN

template <int N, typename T>
ArrayND<N, T> symmetric_convolution(const ArrayND<N, T> &arr,
                                    std::vector<real> kernel,
                                    int axis,
                                    bool normalize = true) {
  ArrayND<N, T> ret = arr.same_shape(T(0.0_f));
  const int radius = kernel.size() - 1;
  if (normalize) {
    real tot(0.0);
    for (int i = 0; i <= radius; i++) {
      tot += kernel[i] * (1 + (i != 0));
    }
    for (int i = 0; i <= radius; i++) {
      kernel[i] /= tot;
    }
  }
  for (auto &ind : arr.get_region()) {
    T tot(0);
    for (int k = -radius; k <= radius; k++) {
      VectorND<N, int> acc = ind.get_ipos();
      acc[axis] = clamp(acc[axis] + k, 0, arr.get_res()[axis] - 1);
      tot += kernel[std::abs(k)] * arr[acc];
    }
    ret[ind] = tot;
  }
  return ret;
}

template <typename T>
Array2D<T> box_blur(const Array2D<T> &arr, real radius, int axis = -1) {
  auto kernel = std::vector<real>(radius, 1.0_f);
  if (axis == -1) {
    return box_blur(box_blur(arr, radius, 0), radius, 1);
  } else {
    return symmetric_convolution(arr, kernel, axis);
  }
}

template <int N, typename T>
ArrayND<N, T> gaussian_blur(const ArrayND<N, T> &arr,
                            real sigma,
                            int axis = -1) {
  if (sigma < 1e-5f) {
    return arr;
  }

  if (axis == -1) {
    auto output = arr;
    for (int i = 0; i < N; i++) {
      output = gaussian_blur(output, sigma, i);
    }
    return output;
  } else {
    int radius = int(std::ceil(sigma * 3.0f));
    std::vector<real> stencil(radius + 1);
    for (int i = 0; i <= radius; i++)
      stencil[i] = std::exp(-0.5f * i * i / sigma / sigma);
    return symmetric_convolution(arr, stencil, axis);
  }
}

template <typename T>
Array2D<T> take_downsampled(const Array2D<T> &arr, int step) {
  Array2D<T> ret(Vector2i(arr.get_width() / step, arr.get_height() / step));
  for (auto &ind : ret.get_region()) {
    ret[ind] = arr[ind.i * step][ind.j * step];
  }
  return ret;
}

TC_NAMESPACE_END

TC_NAMESPACE_BEGIN
template <int dim>
class IndexND;

template <int dim>
class RegionND;

template <int dim, typename T>
class ArrayND;

TC_NAMESPACE_END

TC_NAMESPACE_BEGIN

namespace math {
template <typename T>
TC_FORCE_INLINE T degrees(T rad) {
  return rad * (type::element<T>(180) / pi);
}

template <typename T>
TC_FORCE_INLINE T radians(T deg) {
  return deg * (pi / type::element<T>(180));
}

// clang-format off
template <typename F, typename T>
inline T map(const T &t, const F &f) {
  T ret;
  TC_STATIC_IF(type::is_VectorND<T>()) {
    for (int i = 0; i < std::decay_t<decltype(id(t))>::dim; i++) {
      id(ret)[i] = f(id(t)[i]);
    }
  }
  TC_STATIC_ELSE{
    TC_STATIC_IF(type::is_MatrixND<T>()){
      for (int i = 0; i < std::decay_t<decltype(id(t))>::dim; i++){
        for (int j = 0; j < std::decay_t<decltype(id(t))>::dim; j++){
          id(ret)[i][j] = f(id(t)(i, j));
        }
      }
    }
    TC_STATIC_ELSE {
      id(ret) = f(id(t));
    }
    TC_STATIC_END_IF
  }
  TC_STATIC_END_IF
  return ret;
}
// clang-format on

// clang-format off
template <typename T>
inline type::element<T> maximum(const T &t) {
  typename type::element<T> ret;
  TC_STATIC_IF(type::is_VectorND<T>()) {
    ret = id(t)(0);
    for (int i = 1; i < T::dim; i++) {
      ret = std::max(ret, id(t)(i));
    }
  }
  TC_STATIC_ELSE {
    TC_STATIC_IF(type::is_MatrixND<T>()) {
      ret = t(0, 0);
      for (int i = 0; i < T::dim; i++){
        for (int j = 0; j < T::dim; j++){
          ret = std::max(ret, id(t)(i, j));
        }
      }
    }
    TC_STATIC_ELSE {
      ret = id(t);
    }
    TC_STATIC_END_IF
  }
  TC_STATIC_END_IF
  return ret;
}
// clang-format on

// clang-format off
template <typename T>
inline type::element<T> minimum(const T &t) {
  typename type::element<T> ret;
  TC_STATIC_IF(type::is_VectorND<T>()) {
    ret = t(0);
    for (int i = 1; i < T::dim; i++) {
      ret = std::min(ret, id(t)(i));
    }
  }
  TC_STATIC_ELSE {
    TC_STATIC_IF(type::is_MatrixND<T>()) {
      ret = id(t)(0, 0);
      for (int i = 0; i < T::dim; i++){
        for (int j = 0; j < T::dim; j++){
          ret = std::min(ret, id(t)(i, j));
        }
      }
    }
    TC_STATIC_ELSE {
      ret = id(t);
    }
    TC_STATIC_END_IF
  }
  TC_STATIC_END_IF
  return ret;
}
// clang-format on

// clang-format off
template <typename T>
inline type::element<T> sum(const T &t) {
  typename type::element<T> ret = 0;
  TC_STATIC_IF(type::is_VectorND<T>()) {
    for (int i = 0; i < std::decay_t<decltype(id(t))>::dim; i++) {
      ret += id(t)(i);
    }
  }
  TC_STATIC_ELSE {
    TC_STATIC_IF(type::is_MatrixND<T>()) {
      for (int i = 0; i < std::decay_t<decltype(id(t))>::dim; i++){
        for (int j = 0; j < std::decay_t<decltype(id(t))>::dim; j++){
          ret += id(t)(i, j);
        }
      }
    }
    TC_STATIC_ELSE {
      ret = id(t);
    }
    TC_STATIC_END_IF
  }
  TC_STATIC_END_IF
  return ret;
}

template <typename T>
inline type::element<T> prod(const T &t) {
  typename type::element<T> ret = 1;
  TC_STATIC_IF(type::is_VectorND<T>()) {
    for (int i = 0; i < T::dim; i++) {
      ret *= id(t)(i);
    }
  } TC_STATIC_ELSE {
    TC_STATIC_IF(type::is_MatrixND<T>()) {
      for (int i = 0; i < T::dim; i++) {
        for (int j = 0; j < T::dim; j++) {
          ret *= id(t)(i, j);
        }
      }
    } TC_STATIC_ELSE {
      ret = id(t);
    } TC_STATIC_END_IF
  } TC_STATIC_END_IF
  return ret;
}
// clang-format on

#define TC_MAKE_VECTORIZED_FROM_STD(op)                  \
  template <typename T>                                  \
  inline T op(const T &t) {                              \
    using Elem = typename type::element<decltype(t)>;    \
    return map(t, static_cast<Elem (*)(Elem)>(std::op)); \
  }

TC_MAKE_VECTORIZED_FROM_STD(abs);
TC_MAKE_VECTORIZED_FROM_STD(log);
TC_MAKE_VECTORIZED_FROM_STD(exp);
TC_MAKE_VECTORIZED_FROM_STD(sin);
TC_MAKE_VECTORIZED_FROM_STD(cos);
TC_MAKE_VECTORIZED_FROM_STD(tan);
TC_MAKE_VECTORIZED_FROM_STD(asin);
TC_MAKE_VECTORIZED_FROM_STD(acos);
TC_MAKE_VECTORIZED_FROM_STD(atan);
TC_MAKE_VECTORIZED_FROM_STD(tanh);
TC_MAKE_VECTORIZED_FROM_STD(ceil);
TC_MAKE_VECTORIZED_FROM_STD(floor);
TC_MAKE_VECTORIZED_FROM_STD(sqrt);

template <typename T>
TC_FORCE_INLINE
    typename std::enable_if_t<!std::is_floating_point<T>::value, bool>
    equal(const T &A, const T &B, float64 tolerance) {
  return maximum(abs(A - B)) < tolerance;
}

template <typename T>
TC_FORCE_INLINE
    typename std::enable_if_t<std::is_floating_point<T>::value, bool>
    equal(const T &A, const T &B, float64 tolerance) {
  return std::abs(A - B) < tolerance;
}

}  // namespace math

template <int dim, typename T, InstSetExt ISE>
template <typename T_,
          typename std::enable_if_t<std::is_same<T_, int>::value, int>>
VectorND<dim, T, ISE>::VectorND(const TIndex<dim> &ind) {
  TC_STATIC_ASSERT(2 <= dim && dim <= 3);
  d[0] = ind.i;
  d[1] = ind.j;
  TC_STATIC_IF(dim == 3) {
    this->d[2] = ind.k;
  }
  TC_STATIC_END_IF
};

TC_NAMESPACE_END

TC_NAMESPACE_BEGIN

// Declare and then load
// Load to `this`
#define TC_LOAD_CONFIG(name, default_val) \
  this->name = config.get(#name, default_val)

class Dict {
 private:
  std::map<std::string, std::string> data;

 public:
  TC_IO_DEF(data);

  Dict() = default;

  template <typename T>
  Dict(const std::string &key, const T &value) {
    this->set(key, value);
  }

  std::vector<std::string> get_keys() const {
    std::vector<std::string> keys;
    for (auto it = data.begin(); it != data.end(); ++it) {
      keys.push_back(it->first);
    }
    return keys;
  }

  void clear() {
    data.clear();
  }

  template <typename V>
  typename std::enable_if_t<(!type::is_VectorND<V>() &&
                             !std::is_reference<V>::value &&
                             !std::is_pointer<V>::value),
                            V>
  get(std::string key) const;

  static bool is_string_integral(const std::string &str) {
    // TODO: make it correct
    if (str.find('.') != std::string::npos) {
      return false;
    }
    if (str.find('e') != std::string::npos) {
      return false;
    }
    if (str.find('E') != std::string::npos) {
      return false;
    }
    return true;
  }

  void check_string_integral(const std::string &str) const {
    if (!is_string_integral(str)) {
      TC_ERROR(
          "Getting integral value out of non-integral string '{}' is not "
          "allowed.",
          str);
    }
  }

  void check_value_integral(const std::string &key) const {
    auto str = get_string(key);
    check_string_integral(str);
  }

  template <
      typename V,
      typename std::enable_if<(type::is_VectorND<V>()), V>::type * = nullptr>
  V get(std::string key) const {
    constexpr int N = V::dim;
    using T = typename V::ScalarType;

    std::string str = this->get_string(key);
    std::string temp;
    if (str[0] == '(') {
      temp = "(";
    } else if (str[0] == '[') {
      temp = "[";
    }
    if (std::is_integral<T>()) {
      check_string_integral(str);
    }
    for (int i = 0; i < N; i++) {
      std::string placeholder;
      if (std::is_same<T, float32>()) {
        placeholder = "%f";
      } else if (std::is_same<T, float64>()) {
        placeholder = "%lf";
      } else if (std::is_same<T, int32>()) {
        placeholder = "%d";
      } else if (std::is_same<T, uint32>()) {
        placeholder = "%u";
      } else if (std::is_same<T, int64>()) {
#ifdef WIN32
        placeholder = "%I64d";
#else
        placeholder = "%lld";
#endif
      } else if (std::is_same<T, uint64>()) {
#ifdef WIN32
        placeholder = "%I64u";
#else
        placeholder = "%llu";
#endif
      } else {
        assert(false);
      }
      temp += placeholder;
      if (i != N - 1) {
        temp += ",";
      }
    }
    if (str[0] == '(') {
      temp += ")";
    } else if (str[0] == '[') {
      temp += "]";
    }
    VectorND<N, T> ret;
    if (N == 1) {
      sscanf(str.c_str(), temp.c_str(), &ret[0]);
    } else if (N == 2) {
      sscanf(str.c_str(), temp.c_str(), &ret[0], &ret[1]);
    } else if (N == 3) {
      sscanf(str.c_str(), temp.c_str(), &ret[0], &ret[1], &ret[2]);
    } else if (N == 4) {
      sscanf(str.c_str(), temp.c_str(), &ret[0], &ret[1], &ret[2], &ret[3]);
    }
    return ret;
  }

  std::string get(std::string key, const char *default_val) const;

  template <typename T>
  T get(std::string key, const T &default_val) const;

  bool has_key(std::string key) const {
    return data.find(key) != data.end();
  }

  std::vector<std::string> get_string_arr(std::string key) const {
    std::string str = get_string(key);
    std::vector<std::string> strs = split_string(str, ",");
    for (auto &s : strs) {
      s = trim_string(s);
    }
    return strs;
  }

  template <typename T>
  T *get_ptr(std::string key) const {
    std::string val = get_string(key);
    std::stringstream ss(val);
    std::string t;
    int64 ptr_ll;
    std::getline(ss, t, '\t');
    ss >> ptr_ll;
    assert_info(t == typeid(T).name(),
                "Pointer type mismatch: " + t + " and " + typeid(T).name());
    return reinterpret_cast<T *>(ptr_ll);
  }

  template <typename T>
  std::enable_if_t<std::is_pointer<T>::value, std::remove_pointer_t<T>> get(
      std::string key) const {
    return get_ptr<std::remove_pointer_t<T>>(key);
  }

  template <typename T>
  std::enable_if_t<std::is_reference<T>::value, std::remove_reference_t<T>>
      &get(std::string key) const {
    return *get_ptr<std::remove_reference_t<T>>(key);
  }

  template <typename T>
  T *get_ptr(std::string key, T *default_value) const {
    if (has_key(key)) {
      return get_ptr<T>(key);
    } else {
      return default_value;
    }
  }

  template <typename T>
  std::shared_ptr<T> get_asset(std::string key) const {
    int id = get<int>(key);
    return AssetManager::get_asset<T>(id);
  }

  template <typename T>
  Dict &set(std::string name, T val) {
    std::stringstream ss;
    ss << val;
    data[name] = ss.str();
    return *this;
  }

  Dict &set(std::string name, const char *val) {
    std::stringstream ss;
    ss << val;
    data[name] = ss.str();
    return *this;
  }

  Dict &set(std::string name, const Vector2 &val) {
    std::stringstream ss;
    ss << "(" << val.x << "," << val.y << ")";
    data[name] = ss.str();
    return *this;
  }

  Dict &set(std::string name, const Vector3 &val) {
    std::stringstream ss;
    ss << "(" << val.x << "," << val.y << "," << val.z << ")";
    data[name] = ss.str();
    return *this;
  }

  Dict &set(std::string name, const Vector4 &val) {
    std::stringstream ss;
    ss << "(" << val.x << "," << val.y << "," << val.z << "," << val.w << ")";
    data[name] = ss.str();
    return *this;
  }

  Dict &set(std::string name, const Vector2i &val) {
    std::stringstream ss;
    ss << "(" << val.x << "," << val.y << ")";
    data[name] = ss.str();
    return *this;
  }

  Dict &set(std::string name, const Vector3i &val) {
    std::stringstream ss;
    ss << "(" << val.x << "," << val.y << "," << val.z << ")";
    data[name] = ss.str();
    return *this;
  }

  Dict &set(std::string name, const Vector4i &val) {
    std::stringstream ss;
    ss << "(" << val.x << "," << val.y << "," << val.z << "," << val.w << ")";
    data[name] = ss.str();
    return *this;
  }

  template <typename T>
  static std::string get_ptr_string(T *ptr) {
    std::stringstream ss;
    ss << typeid(T).name() << "\t" << reinterpret_cast<uint64>(ptr);
    return ss.str();
  }

  template <typename T>
  Dict &set(std::string name, T *const ptr) {
    data[name] = get_ptr_string(ptr);
    return *this;
  }

  std::string get_string(std::string key) const {
    if (data.find(key) == data.end()) {
      TC_ERROR("No key named '{}' found.", key);
    }
    return data.find(key)->second;
  }

  template <typename T>
  Dict &operator()(const std::string &key, const T &value) {
    this->set(key, value);
    return *this;
  }
};

template <>
inline std::string Dict::get<std::string>(std::string key) const {
  return get_string(key);
}

template <typename T>
inline T Dict::get(std::string key, const T &default_val) const {
  if (data.find(key) == data.end()) {
    return default_val;
  } else
    return get<T>(key);
}

inline std::string Dict::get(std::string key, const char *default_val) const {
  if (data.find(key) == data.end()) {
    return default_val;
  } else
    return get<std::string>(key);
}

template <>
inline float32 Dict::get<float32>(std::string key) const {
  return (float32)std::atof(get_string(key).c_str());
}

template <>
inline float64 Dict::get<float64>(std::string key) const {
  return (float64)std::atof(get_string(key).c_str());
}

template <>
inline int32 Dict::get<int32>(std::string key) const {
  check_value_integral(key);
  return std::atoi(get_string(key).c_str());
}

template <>
inline uint32 Dict::get<uint32>(std::string key) const {
  check_value_integral(key);
  return uint32(std::atoll(get_string(key).c_str()));
}

template <>
inline int64 Dict::get<int64>(std::string key) const {
  check_value_integral(key);
  return std::atoll(get_string(key).c_str());
}

template <>
inline uint64 Dict::get<uint64>(std::string key) const {
  check_value_integral(key);
  return std::stoull(get_string(key));
}

template <>
inline bool Dict::get<bool>(std::string key) const {
  std::string s = get_string(key);
  static std::map<std::string, bool> dict{
      {"true", true},   {"True", true},   {"t", true},  {"1", true},
      {"false", false}, {"False", false}, {"f", false}, {"0", false},
  };
  assert_info(dict.find(s) != dict.end(), "Unkown identifer for bool: " + s);
  return dict[s];
}

using Config = Dict;

TC_NAMESPACE_END
#include <cstring>
#include <string>
#include <map>
#include <functional>
#include <memory>
#include <iostream>

TC_NAMESPACE_BEGIN

template <typename T>
TC_EXPORT std::shared_ptr<T> create_instance(const std::string &alias);

template <typename T>
TC_EXPORT std::shared_ptr<T> create_instance(const std::string &alias,
                                             const Config &config);

template <typename T>
TC_EXPORT std::unique_ptr<T> create_instance_unique(const std::string &alias);

template <typename T>
TC_EXPORT std::unique_ptr<T> create_instance_unique(const std::string &alias,
                                                    const Config &config);
template <typename T>
TC_EXPORT std::unique_ptr<T> create_instance_unique_ctor(
    const std::string &alias,
    const Config &config);

template <typename T>
TC_EXPORT T *create_instance_raw(const std::string &alias);

template <typename T>
TC_EXPORT T *create_instance_raw(const std::string &alias,
                                 const Config &config);

template <typename T>
TC_EXPORT T *create_instance_placement(const std::string &alias, void *place);

template <typename T>
TC_EXPORT T *create_instance_placement(const std::string &alias,
                                       void *place,
                                       const Config &config);

template <typename T>
TC_EXPORT std::vector<std::string> get_implementation_names();

class Unit {
 public:
  Unit() {
  }

  virtual void initialize(const Config &config) {
  }

  virtual bool test() const {
    return true;
  }

  virtual std::string get_name() const {
    TC_NOT_IMPLEMENTED;
    return "";
  }

  virtual std::string general_action(const Config &config) {
    TC_NOT_IMPLEMENTED;
    return "";
  }
};

#define TC_IMPLEMENTATION_HOLDER_NAME(T) ImplementationHolder_##T
#define TC_IMPLEMENTATION_HOLDER_PTR(T) instance_ImplementationHolder_##T

class ImplementationHolderBase {
 public:
  std::string name;

  virtual bool has(const std::string &alias) const = 0;

  virtual void remove(const std::string &alias) = 0;

  virtual std::vector<std::string> get_implementation_names() const = 0;
};

class InterfaceHolder {
 public:
  typedef std::function<void(void *)> RegistrationMethod;
  std::map<std::string, RegistrationMethod> methods;
  std::map<std::string, ImplementationHolderBase *> interfaces;

  void register_registration_method(const std::string &name,
                                    const RegistrationMethod &method) {
    methods[name] = method;
  }

  void register_interface(const std::string &name,
                          ImplementationHolderBase *interface_) {
    interfaces[name] = interface_;
  }

  static InterfaceHolder *get_instance() {
    static InterfaceHolder holder;
    return &holder;
  }
};

#define TC_INTERFACE(T)                                                       \
  extern void *get_implementation_holder_instance_##T();                      \
  class TC_IMPLEMENTATION_HOLDER_NAME(T) : public ImplementationHolderBase {  \
   public:                                                                    \
    TC_IMPLEMENTATION_HOLDER_NAME(T)(const std::string &name) {               \
      this->name = name;                                                      \
    }                                                                         \
    using FactoryMethod = std::function<std::shared_ptr<T>()>;                \
    using FactoryUniqueMethod = std::function<std::unique_ptr<T>()>;          \
    using FactoryUniqueCtorMethod =                                           \
        std::function<std::unique_ptr<T>(const Dict &config)>;                \
    using FactoryRawMethod = std::function<T *()>;                            \
    using FactoryPlacementMethod = std::function<T *(void *)>;                \
    std::map<std::string, FactoryMethod> implementation_factories;            \
    std::map<std::string, FactoryUniqueMethod>                                \
        implementation_unique_factories;                                      \
    std::map<std::string, FactoryUniqueCtorMethod>                            \
        implementation_unique_ctor_factories;                                 \
    std::map<std::string, FactoryRawMethod> implementation_raw_factories;     \
    std::map<std::string, FactoryPlacementMethod>                             \
        implementation_placement_factories;                                   \
    std::vector<std::string> get_implementation_names() const override {      \
      std::vector<std::string> names;                                         \
      for (auto &kv : implementation_factories) {                             \
        names.push_back(kv.first);                                            \
      }                                                                       \
      return names;                                                           \
    }                                                                         \
    template <typename G>                                                     \
    void insert(const std::string &alias) {                                   \
      implementation_factories.insert(                                        \
          std::make_pair(alias, [&]() { return std::make_shared<G>(); }));    \
      implementation_unique_factories.insert(                                 \
          std::make_pair(alias, [&]() { return std::make_unique<G>(); }));    \
      implementation_raw_factories.insert(                                    \
          std::make_pair(alias, [&]() { return new G(); }));                  \
      implementation_placement_factories.insert(std::make_pair(               \
          alias, [&](void *place) { return new (place) G(); }));              \
    }                                                                         \
    template <typename G>                                                     \
    void insert_new(const std::string &alias) {                               \
      /*with ctor*/                                                           \
      implementation_factories.insert(                                        \
          std::make_pair(alias, [&]() { return std::make_shared<G>(); }));    \
      implementation_unique_factories.insert(                                 \
          std::make_pair(alias, [&]() { return std::make_unique<G>(); }));    \
      implementation_unique_ctor_factories.insert(std::make_pair(             \
          alias,                                                              \
          [&](const Dict &config) { return std::make_unique<G>(config); }));  \
      implementation_raw_factories.insert(                                    \
          std::make_pair(alias, [&]() { return new G(); }));                  \
      implementation_placement_factories.insert(std::make_pair(               \
          alias, [&](void *place) { return new (place) G(); }));              \
    }                                                                         \
    void insert(const std::string &alias, const FactoryMethod &f) {           \
      implementation_factories.insert(std::make_pair(alias, f));              \
    }                                                                         \
    bool has(const std::string &alias) const override {                       \
      return implementation_factories.find(alias) !=                          \
             implementation_factories.end();                                  \
    }                                                                         \
    void remove(const std::string &alias) override {                          \
      assert_info(has(alias),                                                 \
                  std::string("Implemetation ") + alias + " not found!");     \
      implementation_factories.erase(alias);                                  \
    }                                                                         \
    void update(const std::string &alias, const FactoryMethod &f) {           \
      if (has(alias)) {                                                       \
        remove(alias);                                                        \
      }                                                                       \
      insert(alias, f);                                                       \
    }                                                                         \
    template <typename G>                                                     \
    void update(const std::string &alias) {                                   \
      if (has(alias)) {                                                       \
        remove(alias);                                                        \
      }                                                                       \
      insert<G>(alias);                                                       \
    }                                                                         \
    std::shared_ptr<T> create(const std::string &alias) {                     \
      auto factory = implementation_factories.find(alias);                    \
      assert_info(factory != implementation_factories.end(),                  \
                  "Implementation [" + name + "::" + alias + "] not found!"); \
      return (factory->second)();                                             \
    }                                                                         \
    std::unique_ptr<T> create_unique(const std::string &alias) {              \
      auto factory = implementation_unique_factories.find(alias);             \
      assert_info(factory != implementation_unique_factories.end(),           \
                  "Implementation [" + name + "::" + alias + "] not found!"); \
      return (factory->second)();                                             \
    }                                                                         \
    std::unique_ptr<T> create_unique_ctor(const std::string &alias,           \
                                          const Dict &config) {               \
      auto factory = implementation_unique_ctor_factories.find(alias);        \
      assert_info(factory != implementation_unique_ctor_factories.end(),      \
                  "Implementation [" + name + "::" + alias + "] not found!"); \
      return (factory->second)(config);                                       \
    }                                                                         \
    T *create_raw(const std::string &alias) {                                 \
      auto factory = implementation_raw_factories.find(alias);                \
      assert_info(factory != implementation_raw_factories.end(),              \
                  "Implementation [" + name + "::" + alias + "] not found!"); \
      return (factory->second)();                                             \
    }                                                                         \
    T *create_placement(const std::string &alias, void *place) {              \
      auto factory = implementation_placement_factories.find(alias);          \
      assert_info(factory != implementation_placement_factories.end(),        \
                  "Implementation [" + name + "::" + alias + "] not found!"); \
      return (factory->second)(place);                                        \
    }                                                                         \
    static TC_IMPLEMENTATION_HOLDER_NAME(T) * get_instance() {                \
      return static_cast<TC_IMPLEMENTATION_HOLDER_NAME(T) *>(                 \
          get_implementation_holder_instance_##T());                          \
    }                                                                         \
  };                                                                          \
  extern TC_IMPLEMENTATION_HOLDER_NAME(T) * TC_IMPLEMENTATION_HOLDER_PTR(T);

#define TC_INTERFACE_DEF(class_name, base_alias)                              \
  template <>                                                                 \
  TC_EXPORT std::shared_ptr<class_name> create_instance(                      \
      const std::string &alias) {                                             \
    return TC_IMPLEMENTATION_HOLDER_NAME(class_name)::get_instance()->create( \
        alias);                                                               \
  }                                                                           \
  template <>                                                                 \
  TC_EXPORT std::shared_ptr<class_name> create_instance(                      \
      const std::string &alias, const Config &config) {                       \
    auto instance = create_instance<class_name>(alias);                       \
    instance->initialize(config);                                             \
    return instance;                                                          \
  }                                                                           \
  template <>                                                                 \
  TC_EXPORT std::unique_ptr<class_name> create_instance_unique(               \
      const std::string &alias) {                                             \
    return TC_IMPLEMENTATION_HOLDER_NAME(class_name)::get_instance()          \
        ->create_unique(alias);                                               \
  }                                                                           \
  template <>                                                                 \
  TC_EXPORT std::unique_ptr<class_name> create_instance_unique(               \
      const std::string &alias, const Config &config) {                       \
    auto instance = create_instance_unique<class_name>(alias);                \
    instance->initialize(config);                                             \
    return instance;                                                          \
  }                                                                           \
  template <>                                                                 \
  TC_EXPORT std::unique_ptr<class_name> create_instance_unique_ctor(          \
      const std::string &alias, const Dict &config) {                         \
    return TC_IMPLEMENTATION_HOLDER_NAME(class_name)::get_instance()          \
        ->create_unique_ctor(alias, config);                                  \
  }                                                                           \
  template <>                                                                 \
  TC_EXPORT class_name *create_instance_raw(const std::string &alias) {       \
    return TC_IMPLEMENTATION_HOLDER_NAME(class_name)::get_instance()          \
        ->create_raw(alias);                                                  \
  }                                                                           \
  template <>                                                                 \
  TC_EXPORT class_name *create_instance_placement(const std::string &alias,   \
                                                  void *place) {              \
    return TC_IMPLEMENTATION_HOLDER_NAME(class_name)::get_instance()          \
        ->create_placement(alias, place);                                     \
  }                                                                           \
  template <>                                                                 \
  TC_EXPORT class_name *create_instance_placement(                            \
      const std::string &alias, void *place, const Config &config) {          \
    auto instance = create_instance_placement<class_name>(alias, place);      \
    instance->initialize(config);                                             \
    return instance;                                                          \
  }                                                                           \
  template <>                                                                 \
  TC_EXPORT class_name *create_instance_raw(const std::string &alias,         \
                                            const Config &config) {           \
    auto instance = create_instance_raw<class_name>(alias);                   \
    instance->initialize(config);                                             \
    return instance;                                                          \
  }                                                                           \
  template <>                                                                 \
  std::vector<std::string> get_implementation_names<class_name>() {           \
    return TC_IMPLEMENTATION_HOLDER_NAME(class_name)::get_instance()          \
        ->get_implementation_names();                                         \
  }                                                                           \
  TC_IMPLEMENTATION_HOLDER_NAME(class_name) *                                 \
      TC_IMPLEMENTATION_HOLDER_PTR(class_name) = nullptr;                     \
  void *get_implementation_holder_instance_##class_name() {                   \
    if (!TC_IMPLEMENTATION_HOLDER_PTR(class_name)) {                          \
      TC_IMPLEMENTATION_HOLDER_PTR(class_name) =                              \
          new TC_IMPLEMENTATION_HOLDER_NAME(class_name)(base_alias);          \
    }                                                                         \
    return TC_IMPLEMENTATION_HOLDER_PTR(class_name);                          \
  }                                                                           \
  class InterfaceInjector_##class_name {                                      \
   public:                                                                    \
    InterfaceInjector_##class_name(const std::string &name) {                 \
      InterfaceHolder::get_instance()->register_registration_method(          \
          base_alias, [&](void *m) {                                          \
            ((pybind11::module *)m)                                           \
                ->def("create_" base_alias,                                   \
                      static_cast<std::shared_ptr<class_name> (*)(            \
                          const std::string &name)>(                          \
                          &create_instance<class_name>));                     \
            ((pybind11::module *)m)                                           \
                ->def("register_" base_alias,                                 \
                      &AssetManager::insert_asset<class_name>);               \
            ((pybind11::module *)m)                                           \
                ->def("create_initialized_" base_alias,                       \
                      static_cast<std::shared_ptr<class_name> (*)(            \
                          const std::string &name, const Config &config)>(    \
                          &create_instance<class_name>));                     \
          });                                                                 \
      InterfaceHolder::get_instance()->register_interface(                    \
          base_alias, (ImplementationHolderBase *)                            \
                          get_implementation_holder_instance_##class_name()); \
    }                                                                         \
  } ImplementationInjector_##base_class_name##class_name##instance(base_alias);

#define TC_IMPLEMENTATION(base_class_name, class_name, alias)        \
  class ImplementationInjector_##base_class_name##class_name {       \
   public:                                                           \
    ImplementationInjector_##base_class_name##class_name() {         \
      TC_IMPLEMENTATION_HOLDER_NAME(base_class_name)::get_instance() \
          ->insert<class_name>(alias);                               \
    }                                                                \
  } ImplementationInjector_##base_class_name##class_name##instance;

#define TC_IMPLEMENTATION_NEW(base_class_name, class_name)           \
  class ImplementationInjector_##base_class_name##class_name {       \
   public:                                                           \
    ImplementationInjector_##base_class_name##class_name() {         \
      TC_IMPLEMENTATION_HOLDER_NAME(base_class_name)::get_instance() \
          ->insert_new<class_name>(class_name::get_name_static());   \
    }                                                                \
  } ImplementationInjector_##base_class_name##class_name##instance;

#define TC_NAME(alias)                            \
  virtual std::string get_name() const override { \
    return get_name_static();                     \
  }                                               \
  static std::string get_name_static() {          \
    return alias;                                 \
  }

TC_NAMESPACE_END

TC_NAMESPACE_BEGIN

#define TC_IMPLEMENTATION_LOADER(base_class_name, class_name, alias)          \
  class ImplementationLoader_##base_class_name##class_name {                  \
   public:                                                                    \
    ImplementationLoader_##base_class_name##class_name() {                    \
      TC_IMPLEMENTATION_HOLDER_NAME(base_class_name)::get_instance()          \
          ->insert<class_name>(alias);                                        \
    }                                                                         \
    ~ImplementationLoader_##base_class_name##class_name() {                   \
      TC_IMPLEMENTATION_HOLDER_NAME(base_class_name)::get_instance()->remove( \
          alias);                                                             \
    }                                                                         \
  } ImplementationLoader_##base_class_name##class_name##instance;

#define TC_IMPLEMENTATION_UPDATER(base_class_name, class_name, alias) \
  class ImplementationUpdater_##base_class_name##class_name {         \
   public:                                                            \
    ImplementationUpdater_##base_class_name##class_name() {           \
      TC_IMPLEMENTATION_HOLDER_NAME(base_class_name)::get_instance()  \
          ->update<class_name>(alias);                                \
    }                                                                 \
  } ImplementationUpdater_##base_class_name##class_name##instance;

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <vector>
#include <string>

TC_NAMESPACE_BEGIN

class Task : public Unit {
 public:
  virtual void run(const std::vector<std::string> &parameters) {
    assert_info(parameters.size() == 0, "No parameters supported.");
    this->run();
  }
  virtual void run() {
    this->run(std::vector<std::string>());
  }
};

TC_INTERFACE(Task)

#define TC_REGISTER_TASK(task)                                      \
  class Task_##task : public taichi::Task {                         \
    void run(const std::vector<std::string> &parameters) override { \
      task(parameters);                                             \
    }                                                               \
  };                                                                \
  TC_IMPLEMENTATION(Task, Task_##task, #task)

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/



#include <atomic>
#include <functional>
#include <thread>
#include <vector>
#if defined(TC_PLATFORM_WINDOWS)
#include <windows.h>
#else
// Mac and Linux
#include <unistd.h>
#endif

TC_NAMESPACE_BEGIN

class Spinlock {
 protected:
  std::atomic<bool> latch;

 public:
  Spinlock() : Spinlock(false) {
  }

  Spinlock(bool flag) {
    latch.store(flag);
  }

  Spinlock(int flag) : Spinlock(flag != 0) {
  }

  void lock() {
    bool unlatched = false;
    while (!latch.compare_exchange_weak(unlatched, true,
                                        std::memory_order_acquire)) {
      unlatched = false;
    }
  }

  void unlock() {
    latch.store(false, std::memory_order_release);
  }

  Spinlock(const Spinlock &o) {
    // We just ignore racing condition here...
    latch.store(o.latch.load());
  }

  Spinlock &operator=(const Spinlock &o) {
    // We just ignore racing condition here...
    latch.store(o.latch.load());
    return *this;
  }
};

class ThreadedTaskManager {
 public:
  template <typename T>
  void static run(const T &target, int begin, int end, int num_threads) {
  }

  template <typename T>
  void static run(const T &target, int end, int num_threads) {
    return run(target, 0, end, num_threads);
  }

  template <typename T>
  void static run(int begin, int end, int num_threads, const T &target) {
    return run(target, begin, end, num_threads);
  }

  template <typename T>
  void static run(int end, int num_threads, const T &target) {
    return run(target, 0, end, num_threads);
  }
};

class PID {
 public:
  static int get_pid() {
#if defined(TC_PLATFORM_WINDOWS)
    return (int)GetCurrentProcessId();
#else
    return (int)getpid();
#endif
  }
  static int get_parent_pid() {
#if defined(TC_PLATFORM_WINDOWS)
    TC_NOT_IMPLEMENTED
    return -1;
#else
    return (int)getppid();
#endif
  }
};

TC_NAMESPACE_END
#include <csignal>
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//
// spdlog main header file.
// see example.cpp for usage example


#define SPDLOG_VERSION "0.14.0"

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


///////////////////////////////////////////////////////////////////////////////
//
// Edit this file to squeeze more performance, and to customize supported features
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Under Linux, the much faster CLOCK_REALTIME_COARSE clock can be used.
// This clock is less accurate - can be off by dozens of millis - depending on the kernel HZ.
// Uncomment to use it instead of the regular clock.
//
// #define SPDLOG_CLOCK_COARSE
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment if date/time logging is not needed and never appear in the log pattern.
// This will prevent spdlog from quering the clock on each log call.
//
// WARNING: If the log pattern contains any date/time while this flag is on, the result is undefined.
//          You must set new pattern(spdlog::set_pattern(..") without any date/time in it
//
// #define SPDLOG_NO_DATETIME
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment if thread id logging is not needed (i.e. no %t in the log pattern).
// This will prevent spdlog from quering the thread id on each log call.
//
// WARNING: If the log pattern contains thread id (i.e, %t) while this flag is on, the result is undefined.
//
// #define SPDLOG_NO_THREAD_ID
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment if logger name logging is not needed.
// This will prevent spdlog from copying the logger name  on each log call.
//
// #define SPDLOG_NO_NAME
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable the SPDLOG_DEBUG/SPDLOG_TRACE macros.
//
// #define SPDLOG_DEBUG_ON
// #define SPDLOG_TRACE_ON
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to avoid locking in the registry operations (spdlog::get(), spdlog::drop() spdlog::register()).
// Use only if your code never modifes concurrently the registry.
// Note that upon creating a logger the registry is modified by spdlog..
//
// #define SPDLOG_NO_REGISTRY_MUTEX
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to avoid spdlog's usage of atomic log levels
// Use only if your code never modifies a logger's log levels concurrently by different threads.
//
// #define SPDLOG_NO_ATOMIC_LEVELS
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable usage of wchar_t for file names on Windows.
//
// #define SPDLOG_WCHAR_FILENAMES
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to override default eol ("\n" or "\r\n" under Linux/Windows)
//
// #define SPDLOG_EOL ";-)\n"
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to use your own copy of the fmt library instead of spdlog's copy.
// In this case spdlog will try to include <fmt/format.h> so set your -I flag accordingly.
//
// #define SPDLOG_FMT_EXTERNAL
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable syslog (disabled by default)
//
// #define SPDLOG_ENABLE_SYSLOG
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable wchar_t support (convert to utf8)
//
// #define SPDLOG_WCHAR_TO_UTF8_SUPPORT
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to prevent child processes from inheriting log file descriptors
//
// #define SPDLOG_PREVENT_CHILD_FD
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to mark some types as final, allowing more optimizations in release
// mode with recent compilers. See GCC's documentation for -Wsuggest-final-types
// for instance.
//
// #define SPDLOG_FINAL final
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable message counting feature. Adds %i logger pattern that
// prints log message sequence id.
//
// #define SPDLOG_ENABLE_MESSAGE_COUNTER
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable user defined tag names
//
// #define SPDLOG_LEVEL_NAMES  { "   TRACE", "   DEBUG", "    INFO",
// " WARNING", "   ERROR", "CRITICAL", "OFF" };
///////////////////////////////////////////////////////////////////////////////
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


#include <string>
#include <initializer_list>
#include <chrono>
#include <memory>
#include <atomic>
#include <exception>
#include<functional>

#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
#include <codecvt>
#include <locale>
#endif

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


#include <atomic>
// null, no cost dummy "mutex" and dummy "atomic" int

namespace spdlog
{
namespace details
{
struct null_mutex
{
    void lock() {}
    void unlock() {}
    bool try_lock()
    {
        return true;
    }
};

struct null_atomic_int
{
    int value;
    null_atomic_int() = default;

    null_atomic_int(int val):value(val)
    {}

    int load(std::memory_order) const
    {
        return value;
    }

    void store(int val)
    {
        value = val;
    }
};

}
}

//visual studio upto 2013 does not support noexcept nor constexpr
#if defined(_MSC_VER) && (_MSC_VER < 1900)
#define SPDLOG_NOEXCEPT throw()
#define SPDLOG_CONSTEXPR
#else
#define SPDLOG_NOEXCEPT noexcept
#define SPDLOG_CONSTEXPR constexpr
#endif

// See tweakme.h
#if !defined(SPDLOG_FINAL)
#define SPDLOG_FINAL
#endif

#if defined(__GNUC__)  || defined(__clang__)
#define SPDLOG_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define SPDLOG_DEPRECATED __declspec(deprecated)
#else
#define SPDLOG_DEPRECATED
#endif



namespace spdlog
{

class formatter;

namespace sinks
{
class sink;
}

using log_clock = std::chrono::system_clock;
using sink_ptr = std::shared_ptr < sinks::sink >;
using sinks_init_list = std::initializer_list < sink_ptr >;
using formatter_ptr = std::shared_ptr<spdlog::formatter>;
#if defined(SPDLOG_NO_ATOMIC_LEVELS)
using level_t = details::null_atomic_int;
#else
using level_t = std::atomic<int>;
#endif

using log_err_handler = std::function<void(const std::string &err_msg)>;

//Log level enum
namespace level
{
typedef enum
{
    trace = 0,
    debug = 1,
    info = 2,
    warn = 3,
    err = 4,
    critical = 5,
    off = 6
} level_enum;

#if !defined(SPDLOG_LEVEL_NAMES)
#define SPDLOG_LEVEL_NAMES { "trace", "debug", "info",  "warning", "error", "critical", "off" };
#endif
static const char* level_names[] SPDLOG_LEVEL_NAMES

static const char* short_level_names[] { "T", "D", "I", "W", "E", "C", "O" };

inline const char* to_str(spdlog::level::level_enum l)
{
    return level_names[l];
}

inline const char* to_short_str(spdlog::level::level_enum l)
{
    return short_level_names[l];
}
} //level


//
// Async overflow policy - block by default.
//
enum class async_overflow_policy
{
    block_retry, // Block / yield / sleep until message can be enqueued
    discard_log_msg // Discard the message it enqueue fails
};

//
// Pattern time - specific time getting to use for pattern_formatter.
// local time by default
//
enum class pattern_time_type
{
    local, // log localtime
    utc    // log utc
};

//
// Log exception
//
namespace details
{
namespace os
{
std::string errno_str(int err_num);
}
}
class spdlog_ex: public std::exception
{
public:
    spdlog_ex(const std::string& msg):_msg(msg)
    {}
    spdlog_ex(const std::string& msg, int last_errno)
    {
        _msg = msg + ": " + details::os::errno_str(last_errno);
    }
    const char* what() const SPDLOG_NOEXCEPT override
    {
        return _msg.c_str();
    }
private:
    std::string _msg;

};

//
// wchar support for windows file names (SPDLOG_WCHAR_FILENAMES must be defined)
//
#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
using filename_t = std::wstring;
#else
using filename_t = std::string;
#endif


} //spdlog
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


// Thread safe logger (except for set_pattern(..), set_formatter(..) and set_error_handler())
// Has name, log level, vector of std::shared sink pointers and formatter
// Upon each log write the logger:
// 1. Checks if its log level is enough to log the message
// 2. Format the message using the formatter function
// 3. Pass the formatted message to its sinks to performa the actual logging

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

//
// base sink templated over a mutex (either dummy or real)
// concrete implementation should only override the _sink_it method.
// all locking is taken care of here so no locking needed by the implementers..
//

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//



//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


#include <cstdio>
#include <ctime>
#include <functional>
#include <string>
#include <chrono>
#include <thread>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <sys/stat.h>
#include <sys/types.h>

#ifdef _WIN32

#ifndef NOMINMAX
#define NOMINMAX //prevent windows redefining min/max
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <process.h> //  _get_pid support
#include <io.h> // _get_osfhandle and _isatty support

#ifdef __MINGW32__
#include <share.h>
#endif

#else // unix

#include <unistd.h>
#include <fcntl.h>

#ifdef __linux__
#include <sys/syscall.h> //Use gettid() syscall under linux to get thread id

#elif __FreeBSD__
#include <sys/thr.h> //Use thr_self() syscall under FreeBSD to get thread id
#endif

#endif //unix

#ifndef __has_feature       // Clang - feature checking macros.
#define __has_feature(x) 0  // Compatibility with non-clang compilers.
#endif


namespace spdlog
{
namespace details
{
namespace os
{

inline spdlog::log_clock::time_point now()
{

#if defined __linux__ && defined SPDLOG_CLOCK_COARSE
    timespec ts;
    ::clock_gettime(CLOCK_REALTIME_COARSE, &ts);
    return std::chrono::time_point<log_clock, typename log_clock::duration>(
               std::chrono::duration_cast<typename log_clock::duration>(
                   std::chrono::seconds(ts.tv_sec) + std::chrono::nanoseconds(ts.tv_nsec)));


#else
    return log_clock::now();
#endif

}
inline std::tm localtime(const std::time_t &time_tt)
{

#ifdef _WIN32
    std::tm tm;
    localtime_s(&tm, &time_tt);
#else
    std::tm tm;
    localtime_r(&time_tt, &tm);
#endif
    return tm;
}

inline std::tm localtime()
{
    std::time_t now_t = time(nullptr);
    return localtime(now_t);
}


inline std::tm gmtime(const std::time_t &time_tt)
{

#ifdef _WIN32
    std::tm tm;
    gmtime_s(&tm, &time_tt);
#else
    std::tm tm;
    gmtime_r(&time_tt, &tm);
#endif
    return tm;
}

inline std::tm gmtime()
{
    std::time_t now_t = time(nullptr);
    return gmtime(now_t);
}
inline bool operator==(const std::tm& tm1, const std::tm& tm2)
{
    return (tm1.tm_sec == tm2.tm_sec &&
            tm1.tm_min == tm2.tm_min &&
            tm1.tm_hour == tm2.tm_hour &&
            tm1.tm_mday == tm2.tm_mday &&
            tm1.tm_mon == tm2.tm_mon &&
            tm1.tm_year == tm2.tm_year &&
            tm1.tm_isdst == tm2.tm_isdst);
}

inline bool operator!=(const std::tm& tm1, const std::tm& tm2)
{
    return !(tm1 == tm2);
}

// eol definition
#if !defined (SPDLOG_EOL)
#ifdef _WIN32
#define SPDLOG_EOL "\r\n"
#else
#define SPDLOG_EOL "\n"
#endif
#endif

SPDLOG_CONSTEXPR static const char* eol = SPDLOG_EOL;
SPDLOG_CONSTEXPR static int eol_size = sizeof(SPDLOG_EOL) - 1;

inline void prevent_child_fd(FILE *f)
{
#ifdef _WIN32
    auto file_handle = (HANDLE)_get_osfhandle(_fileno(f));
    if (!::SetHandleInformation(file_handle, HANDLE_FLAG_INHERIT, 0))
        throw spdlog_ex("SetHandleInformation failed", errno);
#else
    auto fd = fileno(f);
    if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
        throw spdlog_ex("fcntl with FD_CLOEXEC failed", errno);
#endif
}


//fopen_s on non windows for writing
inline int fopen_s(FILE** fp, const filename_t& filename, const filename_t& mode)
{
#ifdef _WIN32
#ifdef SPDLOG_WCHAR_FILENAMES
    *fp = _wfsopen((filename.c_str()), mode.c_str(), _SH_DENYWR);
#else
    *fp = _fsopen((filename.c_str()), mode.c_str(), _SH_DENYWR);
#endif
#else //unix
    *fp = fopen((filename.c_str()), mode.c_str());
#endif

#ifdef SPDLOG_PREVENT_CHILD_FD
    if (*fp != nullptr)
        prevent_child_fd(*fp);
#endif
    return *fp == nullptr;
}


inline int remove(const filename_t &filename)
{
#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
    return _wremove(filename.c_str());
#else
    return std::remove(filename.c_str());
#endif
}

inline int rename(const filename_t& filename1, const filename_t& filename2)
{
#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
    return _wrename(filename1.c_str(), filename2.c_str());
#else
    return std::rename(filename1.c_str(), filename2.c_str());
#endif
}


//Return if file exists
inline bool file_exists(const filename_t& filename)
{
#ifdef _WIN32
#ifdef SPDLOG_WCHAR_FILENAMES
    auto attribs = GetFileAttributesW(filename.c_str());
#else
    auto attribs = GetFileAttributesA(filename.c_str());
#endif
    return (attribs != INVALID_FILE_ATTRIBUTES && !(attribs & FILE_ATTRIBUTE_DIRECTORY));
#else //common linux/unix all have the stat system call
    struct stat buffer;
    return (stat(filename.c_str(), &buffer) == 0);
#endif
}




//Return file size according to open FILE* object
inline size_t filesize(FILE *f)
{
    if (f == nullptr)
        throw spdlog_ex("Failed getting file size. fd is null");
#ifdef _WIN32
    int fd = _fileno(f);
#if _WIN64 //64 bits
    struct _stat64 st;
    if (_fstat64(fd, &st) == 0)
        return st.st_size;

#else //windows 32 bits
    long ret = _filelength(fd);
    if (ret >= 0)
        return static_cast<size_t>(ret);
#endif

#else // unix
    int fd = fileno(f);
    //64 bits(but not in osx, where fstat64 is deprecated)
#if !defined(__FreeBSD__) && !defined(__APPLE__) && (defined(__x86_64__) || defined(__ppc64__))
    struct stat64 st;
    if (fstat64(fd, &st) == 0)
        return static_cast<size_t>(st.st_size);
#else // unix 32 bits or osx
    struct stat st;
    if (fstat(fd, &st) == 0)
        return static_cast<size_t>(st.st_size);
#endif
#endif
    throw spdlog_ex("Failed getting file size from fd", errno);
}




//Return utc offset in minutes or throw spdlog_ex on failure
inline int utc_minutes_offset(const std::tm& tm = details::os::localtime())
{

#ifdef _WIN32
#if _WIN32_WINNT < _WIN32_WINNT_WS08
    TIME_ZONE_INFORMATION tzinfo;
    auto rv = GetTimeZoneInformation(&tzinfo);
#else
    DYNAMIC_TIME_ZONE_INFORMATION tzinfo;
    auto rv = GetDynamicTimeZoneInformation(&tzinfo);
#endif
    if (rv == TIME_ZONE_ID_INVALID)
        throw spdlog::spdlog_ex("Failed getting timezone info. ", errno);

    int offset = -tzinfo.Bias;
    if (tm.tm_isdst)
        offset -= tzinfo.DaylightBias;
    else
        offset -= tzinfo.StandardBias;
    return offset;
#else

#if defined(sun) || defined(__sun)
    // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris
    struct helper
    {
        static long int calculate_gmt_offset(const std::tm & localtm = details::os::localtime(), const std::tm & gmtm = details::os::gmtime())
        {
            int local_year = localtm.tm_year + (1900 - 1);
            int gmt_year = gmtm.tm_year + (1900 - 1);

            long int days = (
                                // difference in day of year
                                localtm.tm_yday - gmtm.tm_yday

                                // + intervening leap days
                                + ((local_year >> 2) - (gmt_year >> 2))
                                - (local_year / 100 - gmt_year / 100)
                                + ((local_year / 100 >> 2) - (gmt_year / 100 >> 2))

                                // + difference in years * 365 */
                                + (long int)(local_year - gmt_year) * 365
                            );

            long int hours = (24 * days) + (localtm.tm_hour - gmtm.tm_hour);
            long int mins = (60 * hours) + (localtm.tm_min - gmtm.tm_min);
            long int secs = (60 * mins) + (localtm.tm_sec - gmtm.tm_sec);

            return secs;
        }
    };

    long int offset_seconds = helper::calculate_gmt_offset(tm);
#else
    long int offset_seconds = tm.tm_gmtoff;
#endif

    return static_cast<int>(offset_seconds / 60);
#endif
}

//Return current thread id as size_t
//It exists because the std::this_thread::get_id() is much slower(espcially under VS 2013)
inline size_t _thread_id()
{
#ifdef _WIN32
    return  static_cast<size_t>(::GetCurrentThreadId());
#elif __linux__
# if defined(__ANDROID__) && defined(__ANDROID_API__) && (__ANDROID_API__ < 21)
#  define SYS_gettid __NR_gettid
# endif
    return  static_cast<size_t>(syscall(SYS_gettid));
#elif __FreeBSD__
    long tid;
    thr_self(&tid);
    return static_cast<size_t>(tid);
#elif __APPLE__
    uint64_t tid;
    pthread_threadid_np(nullptr, &tid);
    return static_cast<size_t>(tid);
#else //Default to standard C++11 (other Unix)
    return static_cast<size_t>(std::hash<std::thread::id>()(std::this_thread::get_id()));
#endif
}

//Return current thread id as size_t (from thread local storage)
inline size_t thread_id()
{
#if defined(_MSC_VER) && (_MSC_VER < 1900) || defined(__clang__) && !__has_feature(cxx_thread_local)
    return _thread_id();
#else
    static thread_local const size_t tid = _thread_id();
    return tid;
#endif
}




// wchar support for windows file names (SPDLOG_WCHAR_FILENAMES must be defined)
#if defined(_WIN32) && defined(SPDLOG_WCHAR_FILENAMES)
#define SPDLOG_FILENAME_T(s) L ## s
inline std::string filename_to_str(const filename_t& filename)
{
    std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> c;
    return c.to_bytes(filename);
}
#else
#define SPDLOG_FILENAME_T(s) s
inline std::string filename_to_str(const filename_t& filename)
{
    return filename;
}
#endif

inline std::string errno_to_string(char[256], char* res)
{
    return std::string(res);
}

inline std::string errno_to_string(char buf[256], int res)
{
    if (res == 0)
    {
        return std::string(buf);
    }
    else
    {
        return "Unknown error";
    }
}

// Return errno string (thread safe)
inline std::string errno_str(int err_num)
{
    char buf[256];
    SPDLOG_CONSTEXPR auto buf_size = sizeof(buf);

#ifdef _WIN32
    if (strerror_s(buf, buf_size, err_num) == 0)
        return std::string(buf);
    else
        return "Unknown error";

#elif defined(__FreeBSD__) || defined(__APPLE__) || defined(ANDROID) || defined(__SUNPRO_CC) || \
      ((_POSIX_C_SOURCE >= 200112L) && ! defined(_GNU_SOURCE)) // posix version

    if (strerror_r(err_num, buf, buf_size) == 0)
        return std::string(buf);
    else
        return "Unknown error";

#else  // gnu version (might not use the given buf, so its retval pointer must be used)
    auto err = strerror_r(err_num, buf, buf_size); // let compiler choose type
    return errno_to_string(buf, err); // use overloading to select correct stringify function
#endif
}

inline int pid()
{

#ifdef _WIN32
    return ::_getpid();
#else
    return static_cast<int>(::getpid());
#endif

}


// Detrmine if the terminal supports colors
// Source: https://github.com/agauniyal/rang/
inline bool is_color_terminal()
{
#ifdef _WIN32
    return true;
#else
    static constexpr const char* Terms[] =
    {
        "ansi", "color", "console", "cygwin", "gnome", "konsole", "kterm",
        "linux", "msys", "putty", "rxvt", "screen", "vt100", "xterm"
    };

    const char *env_p = std::getenv("TERM");
    if (env_p == nullptr)
    {
        return false;
    }

    static const bool result = std::any_of(
                                   std::begin(Terms), std::end(Terms), [&](const char* term)
    {
        return std::strstr(env_p, term) != nullptr;
    });
    return result;
#endif
}


// Detrmine if the terminal attached
// Source: https://github.com/agauniyal/rang/
inline bool in_terminal(FILE* file)
{

#ifdef _WIN32
    return _isatty(_fileno(file)) ? true : false;
#else
    return isatty(fileno(file)) ? true : false;
#endif
}
} //os
} //details
} //spdlog


#include <string>
#include <utility>

namespace spdlog
{
namespace details
{
struct log_msg
{
    log_msg() = default;
    log_msg(const std::string *loggers_name, level::level_enum lvl) :
        logger_name(loggers_name),
        level(lvl),
        msg_id(0)
    {
#ifndef SPDLOG_NO_DATETIME
        time = os::now();
#endif

#ifndef SPDLOG_NO_THREAD_ID
        thread_id = os::thread_id();
#endif
    }

    log_msg(const log_msg& other)  = delete;
    log_msg& operator=(log_msg&& other) = delete;
    log_msg(log_msg&& other) = delete;


    const std::string *logger_name;
    level::level_enum level;
    log_clock::time_point time;
    size_t thread_id;
    fmt::MemoryWriter raw;
    fmt::MemoryWriter formatted;
    size_t msg_id;
};
}
}

namespace spdlog
{
namespace sinks
{
class sink
{
public:
    sink()
    {
        _level = level::trace;
    }

    virtual ~sink() {}
    virtual void log(const details::log_msg& msg) = 0;
    virtual void flush() = 0;

    bool should_log(level::level_enum msg_level) const;
    void set_level(level::level_enum log_level);
    level::level_enum level() const;

private:
    level_t _level;

};

inline bool sink::should_log(level::level_enum msg_level) const
{
    return msg_level >= _level.load(std::memory_order_relaxed);
}

inline void sink::set_level(level::level_enum log_level)
{
    _level.store(log_level);
}

inline level::level_enum sink::level() const
{
    return static_cast<spdlog::level::level_enum>(_level.load(std::memory_order_relaxed));
}

}
}

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//



#include <vector>
#include <string>
#include <memory>

namespace spdlog
{
namespace details
{
class flag_formatter;
}

class formatter
{
public:
    virtual ~formatter() {}
    virtual void format(details::log_msg& msg) = 0;
};

class pattern_formatter SPDLOG_FINAL : public formatter
{

public:
    explicit pattern_formatter(const std::string& pattern, pattern_time_type pattern_time = pattern_time_type::local);
    pattern_formatter(const pattern_formatter&) = delete;
    pattern_formatter& operator=(const pattern_formatter&) = delete;
    void format(details::log_msg& msg) override;
private:
    const std::string _pattern;
    const pattern_time_type _pattern_time;
    std::vector<std::unique_ptr<details::flag_formatter>> _formatters;
    std::tm get_time(details::log_msg& msg);
    void handle_flag(char flag);
    void compile_pattern(const std::string& pattern);
};
}

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//



#include <chrono>
#include <ctime>
#include <memory>
#include <mutex>
#include <string>
#include <thread>
#include <utility>
#include <vector>
#include <array>

namespace spdlog
{
namespace details
{
class flag_formatter
{
public:
    virtual ~flag_formatter()
    {}
    virtual void format(details::log_msg& msg, const std::tm& tm_time) = 0;
};

///////////////////////////////////////////////////////////////////////
// name & level pattern appenders
///////////////////////////////////////////////////////////////////////
namespace
{
class name_formatter:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        msg.formatted << *msg.logger_name;
    }
};
}

// log level appender
class level_formatter:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        msg.formatted << level::to_str(msg.level);
    }
};

// short log level appender
class short_level_formatter:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        msg.formatted << level::to_short_str(msg.level);
    }
};

///////////////////////////////////////////////////////////////////////
// Date time pattern appenders
///////////////////////////////////////////////////////////////////////

static const char* ampm(const tm& t)
{
    return t.tm_hour >= 12 ? "PM" : "AM";
}

static int to12h(const tm& t)
{
    return t.tm_hour > 12 ? t.tm_hour - 12 : t.tm_hour;
}

//Abbreviated weekday name
static const std::string days[] { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
class a_formatter:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << days[tm_time.tm_wday];
    }
};

//Full weekday name
static const std::string full_days[] { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
class A_formatter:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << full_days[tm_time.tm_wday];
    }
};

//Abbreviated month
static const std::string  months[] { "Jan", "Feb", "Mar", "Apr", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec" };
class b_formatter:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << months[tm_time.tm_mon];
    }
};

//Full month name
static const std::string full_months[] { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
class B_formatter:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << full_months[tm_time.tm_mon];
    }
};


//write 2 ints seperated by sep with padding of 2
static fmt::MemoryWriter& pad_n_join(fmt::MemoryWriter& w, int v1, int v2, char sep)
{
    w << fmt::pad(v1, 2, '0') << sep << fmt::pad(v2, 2, '0');
    return w;
}

//write 3 ints seperated by sep with padding of 2
static fmt::MemoryWriter& pad_n_join(fmt::MemoryWriter& w, int v1, int v2, int v3, char sep)
{
    w << fmt::pad(v1, 2, '0') << sep << fmt::pad(v2, 2, '0') << sep << fmt::pad(v3, 2, '0');
    return w;
}


//Date and time representation (Thu Aug 23 15:35:46 2014)
class c_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << days[tm_time.tm_wday] << ' ' << months[tm_time.tm_mon] << ' ' << tm_time.tm_mday << ' ';
        pad_n_join(msg.formatted, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec, ':') << ' ' << tm_time.tm_year + 1900;
    }
};


// year - 2 digit
class C_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << fmt::pad(tm_time.tm_year % 100, 2, '0');
    }
};



// Short MM/DD/YY date, equivalent to %m/%d/%y 08/23/01
class D_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        pad_n_join(msg.formatted, tm_time.tm_mon + 1, tm_time.tm_mday, tm_time.tm_year % 100, '/');
    }
};


// year - 4 digit
class Y_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << tm_time.tm_year + 1900;
    }
};

// month 1-12
class m_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << fmt::pad(tm_time.tm_mon + 1, 2, '0');
    }
};

// day of month 1-31
class d_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << fmt::pad(tm_time.tm_mday, 2, '0');
    }
};

// hours in 24 format  0-23
class H_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << fmt::pad(tm_time.tm_hour, 2, '0');
    }
};

// hours in 12 format  1-12
class I_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << fmt::pad(to12h(tm_time), 2, '0');
    }
};

// minutes 0-59
class M_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << fmt::pad(tm_time.tm_min, 2, '0');
    }
};

// seconds 0-59
class S_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << fmt::pad(tm_time.tm_sec, 2, '0');
    }
};

// milliseconds
class e_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        auto duration = msg.time.time_since_epoch();
        auto millis = std::chrono::duration_cast<std::chrono::milliseconds>(duration).count() % 1000;
        msg.formatted << fmt::pad(static_cast<int>(millis), 3, '0');
    }
};

// microseconds
class f_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        auto duration = msg.time.time_since_epoch();
        auto micros = std::chrono::duration_cast<std::chrono::microseconds>(duration).count() % 1000000;
        msg.formatted << fmt::pad(static_cast<int>(micros), 6, '0');
    }
};

// nanoseconds
class F_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        auto duration = msg.time.time_since_epoch();
        auto ns = std::chrono::duration_cast<std::chrono::nanoseconds>(duration).count() % 1000000000;
        msg.formatted << fmt::pad(static_cast<int>(ns), 9, '0');
    }
};

// AM/PM
class p_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        msg.formatted << ampm(tm_time);
    }
};


// 12 hour clock 02:55:02 pm
class r_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        pad_n_join(msg.formatted, to12h(tm_time), tm_time.tm_min, tm_time.tm_sec, ':') << ' ' << ampm(tm_time);
    }
};

// 24-hour HH:MM time, equivalent to %H:%M
class R_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        pad_n_join(msg.formatted, tm_time.tm_hour, tm_time.tm_min, ':');
    }
};

// ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S
class T_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
        pad_n_join(msg.formatted, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec, ':');
    }
};

// ISO 8601 offset from UTC in timezone (+-HH:MM)
class z_formatter SPDLOG_FINAL:public flag_formatter
{
public:
    const std::chrono::seconds cache_refresh = std::chrono::seconds(5);

    z_formatter():_last_update(std::chrono::seconds(0)), _offset_minutes(0)
    {}
    z_formatter(const z_formatter&) = delete;
    z_formatter& operator=(const z_formatter&) = delete;

    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
#ifdef _WIN32
        int total_minutes = get_cached_offset(msg, tm_time);
#else
        // No need to chache under gcc,
        // it is very fast (already stored in tm.tm_gmtoff)
        int total_minutes = os::utc_minutes_offset(tm_time);
#endif
        bool is_negative = total_minutes < 0;
        char sign;
        if (is_negative)
        {
            total_minutes = -total_minutes;
            sign = '-';
        }
        else
        {
            sign = '+';
        }

        int h = total_minutes / 60;
        int m = total_minutes % 60;
        msg.formatted << sign;
        pad_n_join(msg.formatted, h, m, ':');
    }
private:
    log_clock::time_point _last_update;
    int _offset_minutes;
    std::mutex _mutex;

    int get_cached_offset(const log_msg& msg, const std::tm& tm_time)
    {
        using namespace std::chrono;
        std::lock_guard<std::mutex> l(_mutex);
        if (msg.time - _last_update >= cache_refresh)
        {
            _offset_minutes = os::utc_minutes_offset(tm_time);
            _last_update = msg.time;
        }
        return _offset_minutes;
    }
};



// Thread id
class t_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        msg.formatted << msg.thread_id;
    }
};

// Current pid
class pid_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        msg.formatted << details::os::pid();
    }
};


class v_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm&) override
    {
        msg.formatted << fmt::StringRef(msg.raw.data(), msg.raw.size());
    }
};

class ch_formatter SPDLOG_FINAL:public flag_formatter
{
public:
    explicit ch_formatter(char ch): _ch(ch)
    {}
    void format(details::log_msg& msg, const std::tm&) override
    {
        msg.formatted << _ch;
    }
private:
    char _ch;
};


//aggregate user chars to display as is
class aggregate_formatter SPDLOG_FINAL:public flag_formatter
{
public:
    aggregate_formatter()
    {}
    void add_ch(char ch)
    {
        _str += ch;
    }
    void format(details::log_msg& msg, const std::tm&) override
    {
        msg.formatted << _str;
    }
private:
    std::string _str;
};

// Full info formatter
// pattern: [%Y-%m-%d %H:%M:%S.%e] [%n] [%l] %v
class full_formatter SPDLOG_FINAL:public flag_formatter
{
    void format(details::log_msg& msg, const std::tm& tm_time) override
    {
#ifndef SPDLOG_NO_DATETIME
        auto duration = msg.time.time_since_epoch();
        auto millis = std::chrono::duration_cast<std::chrono::milliseconds>(duration).count() % 1000;

        /* Slower version(while still very fast - about 3.2 million lines/sec under 10 threads),
        msg.formatted.write("[{:d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}.{:03d}] [{}] [{}] {} ",
        tm_time.tm_year + 1900,
        tm_time.tm_mon + 1,
        tm_time.tm_mday,
        tm_time.tm_hour,
        tm_time.tm_min,
        tm_time.tm_sec,
        static_cast<int>(millis),
        msg.logger_name,
        level::to_str(msg.level),
        msg.raw.str());*/


        // Faster (albeit uglier) way to format the line (5.6 million lines/sec under 10 threads)
        msg.formatted << '[' << static_cast<unsigned int>(tm_time.tm_year + 1900) << '-'
                      << fmt::pad(static_cast<unsigned int>(tm_time.tm_mon + 1), 2, '0') << '-'
                      << fmt::pad(static_cast<unsigned int>(tm_time.tm_mday), 2, '0') << ' '
                      << fmt::pad(static_cast<unsigned int>(tm_time.tm_hour), 2, '0') << ':'
                      << fmt::pad(static_cast<unsigned int>(tm_time.tm_min), 2, '0') << ':'
                      << fmt::pad(static_cast<unsigned int>(tm_time.tm_sec), 2, '0') << '.'
                      << fmt::pad(static_cast<unsigned int>(millis), 3, '0') << "] ";

        //no datetime needed
#else
        (void)tm_time;
#endif

#ifndef SPDLOG_NO_NAME
        msg.formatted << '[' << *msg.logger_name << "] ";
#endif

        msg.formatted << '[' << level::to_str(msg.level) << "] ";
        msg.formatted << fmt::StringRef(msg.raw.data(), msg.raw.size());
    }
};



}
}
///////////////////////////////////////////////////////////////////////////////
// pattern_formatter inline impl
///////////////////////////////////////////////////////////////////////////////
inline spdlog::pattern_formatter::pattern_formatter(const std::string& pattern, pattern_time_type pattern_time)
    : _pattern_time(pattern_time)
{
    compile_pattern(pattern);
}

inline void spdlog::pattern_formatter::compile_pattern(const std::string& pattern)
{
    auto end = pattern.end();
    std::unique_ptr<details::aggregate_formatter> user_chars;
    for (auto it = pattern.begin(); it != end; ++it)
    {
        if (*it == '%')
        {
            if (user_chars) //append user chars found so far
                _formatters.push_back(std::move(user_chars));

            if (++it != end)
                handle_flag(*it);
            else
                break;
        }
        else // chars not following the % sign should be displayed as is
        {
            if (!user_chars)
                user_chars = std::unique_ptr<details::aggregate_formatter>(new details::aggregate_formatter());
            user_chars->add_ch(*it);
        }
    }
    if (user_chars) //append raw chars found so far
    {
        _formatters.push_back(std::move(user_chars));
    }

}
inline void spdlog::pattern_formatter::handle_flag(char flag)
{
    switch (flag)
    {
    // logger name
    case 'n':
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::name_formatter()));
        break;

    case 'l':
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::level_formatter()));
        break;

    case 'L':
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::short_level_formatter()));
        break;

    case('t'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::t_formatter()));
        break;

    case('v'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::v_formatter()));
        break;

    case('a'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::a_formatter()));
        break;

    case('A'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::A_formatter()));
        break;

    case('b'):
    case('h'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::b_formatter()));
        break;

    case('B'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::B_formatter()));
        break;
    case('c'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::c_formatter()));
        break;

    case('C'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::C_formatter()));
        break;

    case('Y'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::Y_formatter()));
        break;

    case('D'):
    case('x'):

        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::D_formatter()));
        break;

    case('m'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::m_formatter()));
        break;

    case('d'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::d_formatter()));
        break;

    case('H'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::H_formatter()));
        break;

    case('I'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::I_formatter()));
        break;

    case('M'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::M_formatter()));
        break;

    case('S'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::S_formatter()));
        break;

    case('e'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::e_formatter()));
        break;

    case('f'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::f_formatter()));
        break;
    case('F'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::F_formatter()));
        break;

    case('p'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::p_formatter()));
        break;

    case('r'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::r_formatter()));
        break;

    case('R'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::R_formatter()));
        break;

    case('T'):
    case('X'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::T_formatter()));
        break;

    case('z'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::z_formatter()));
        break;

    case ('+'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::full_formatter()));
        break;

    case ('P'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::pid_formatter()));
        break;

#if defined(SPDLOG_ENABLE_MESSAGE_COUNTER)
    case ('i'):
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::i_formatter()));
        break;
#endif

    default: //Unknown flag appears as is
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::ch_formatter('%')));
        _formatters.push_back(std::unique_ptr<details::flag_formatter>(new details::ch_formatter(flag)));
        break;
    }
}

inline std::tm spdlog::pattern_formatter::get_time(details::log_msg& msg)
{
    if (_pattern_time == pattern_time_type::local)
        return details::os::localtime(log_clock::to_time_t(msg.time));
    else
        return details::os::gmtime(log_clock::to_time_t(msg.time));
}

inline void spdlog::pattern_formatter::format(details::log_msg& msg)
{

#ifndef SPDLOG_NO_DATETIME
    auto tm_time = get_time(msg);
#else
    std::tm tm_time;
#endif
    for (auto &f : _formatters)
    {
        f->format(msg, tm_time);
    }
    //write eol
    msg.formatted.write(details::os::eol, details::os::eol_size);
}


#include <mutex>

namespace spdlog
{
namespace sinks
{
template<class Mutex>
class base_sink:public sink
{
public:
    base_sink():_mutex() {}
    virtual ~base_sink() = default;

    base_sink(const base_sink&) = delete;
    base_sink& operator=(const base_sink&) = delete;

    void log(const details::log_msg& msg) SPDLOG_FINAL override
    {
        std::lock_guard<Mutex> lock(_mutex);
        _sink_it(msg);
    }
    void flush() SPDLOG_FINAL override
    {
        _flush();
    }

protected:
    virtual void _sink_it(const details::log_msg& msg) = 0;
    virtual void _flush() = 0;
    Mutex _mutex;
};
}
}

#include <vector>
#include <memory>
#include <string>

namespace spdlog
{

class logger
{
public:
    logger(const std::string& logger_name, sink_ptr single_sink);
    logger(const std::string& name, sinks_init_list);
    template<class It>
    logger(const std::string& name, const It& begin, const It& end);

    virtual ~logger();
    logger(const logger&) = delete;
    logger& operator=(const logger&) = delete;


    template <typename... Args> void log(level::level_enum lvl, const char* fmt, const Args&... args);
    template <typename... Args> void log(level::level_enum lvl, const char* msg);
    template <typename Arg1, typename... Args> void trace(const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void debug(const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void info(const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void warn(const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void error(const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void critical(const char* fmt, const Arg1&, const Args&... args);

    template <typename... Args> void log_if(const bool flag, level::level_enum lvl, const char* fmt, const Args&... args);
    template <typename... Args> void log_if(const bool flag, level::level_enum lvl, const char* msg);
    template <typename Arg1, typename... Args> void trace_if(const bool flag, const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void debug_if(const bool flag, const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void info_if(const bool flag, const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void warn_if(const bool flag, const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void error_if(const bool flag, const char* fmt, const Arg1&, const Args&... args);
    template <typename Arg1, typename... Args> void critical_if(const bool flag, const char* fmt, const Arg1&, const Args&... args);

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
    template <typename... Args> void log(level::level_enum lvl, const wchar_t* msg);
    template <typename... Args> void log(level::level_enum lvl, const wchar_t* fmt, const Args&... args);
    template <typename... Args> void trace(const wchar_t* fmt, const Args&... args);
    template <typename... Args> void debug(const wchar_t* fmt, const Args&... args);
    template <typename... Args> void info(const wchar_t* fmt, const Args&... args);
    template <typename... Args> void warn(const wchar_t* fmt, const Args&... args);
    template <typename... Args> void error(const wchar_t* fmt, const Args&... args);
    template <typename... Args> void critical(const wchar_t* fmt, const Args&... args);

    template <typename... Args> void log_if(const bool flag, level::level_enum lvl, const wchar_t* msg);
    template <typename... Args> void log_if(const bool flag, level::level_enum lvl, const wchar_t* fmt, const Args&... args);
    template <typename... Args> void trace_if(const bool flag, const wchar_t* fmt, const Args&... args);
    template <typename... Args> void debug_if(const bool flag, const wchar_t* fmt, const Args&... args);
    template <typename... Args> void info_if(const bool flag, const wchar_t* fmt, const Args&... args);
    template <typename... Args> void warn_if(const bool flag, const wchar_t* fmt, const Args&... args);
    template <typename... Args> void error_if(const bool flag, const wchar_t* fmt, const Args&... args);
    template <typename... Args> void critical_if(const bool flag, const wchar_t* fmt, const Args&... args);
#endif // SPDLOG_WCHAR_TO_UTF8_SUPPORT

    template <typename T> void log(level::level_enum lvl, const T&);
    template <typename T> void trace(const T&);
    template <typename T> void debug(const T&);
    template <typename T> void info(const T&);
    template <typename T> void warn(const T&);
    template <typename T> void error(const T&);
    template <typename T> void critical(const T&);

    template <typename T> void log_if(const bool flag, level::level_enum lvl, const T&);
    template <typename T> void trace_if(const bool flag, const T&);
    template <typename T> void debug_if(const bool flag, const T&);
    template <typename T> void info_if(const bool flag, const T&);
    template <typename T> void warn_if(const bool flag, const T&);
    template <typename T> void error_if(const bool flag, const T&);
    template <typename T> void critical_if(const bool flag, const T&);

    bool should_log(level::level_enum) const;
    void set_level(level::level_enum);
    level::level_enum level() const;
    const std::string& name() const;
    void set_pattern(const std::string&, pattern_time_type = pattern_time_type::local);
    void set_formatter(formatter_ptr);

    // automatically call flush() if message level >= log_level
    void flush_on(level::level_enum log_level);

    virtual void flush();

    const std::vector<sink_ptr>& sinks() const;

    // error handler
    virtual void set_error_handler(log_err_handler);
    virtual log_err_handler error_handler();

protected:
    virtual void _sink_it(details::log_msg&);
    virtual void _set_pattern(const std::string&, pattern_time_type);
    virtual void _set_formatter(formatter_ptr);

    // default error handler: print the error to stderr with the max rate of 1 message/minute
    virtual void _default_err_handler(const std::string &msg);

    // return true if the given message level should trigger a flush
    bool _should_flush_on(const details::log_msg&);

    const std::string _name;
    std::vector<sink_ptr> _sinks;
    formatter_ptr _formatter;
    spdlog::level_t _level;
    spdlog::level_t _flush_level;
    log_err_handler _err_handler;
    std::atomic<time_t> _last_err_time;
    std::atomic<size_t> _msg_counter;
};
}

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//



#include <cstdio>
#include <memory>
#include <mutex>

namespace spdlog
{
namespace sinks
{

template <class Mutex>
class stdout_sink SPDLOG_FINAL : public base_sink<Mutex>
{
    using MyType = stdout_sink<Mutex>;
public:
    stdout_sink()
    {}
    static std::shared_ptr<MyType> instance()
    {
        static std::shared_ptr<MyType> instance = std::make_shared<MyType>();
        return instance;
    }
protected:
    void _sink_it(const details::log_msg& msg) override
    {
        fwrite(msg.formatted.data(), sizeof(char), msg.formatted.size(), stdout);
        _flush();
    }

    void _flush() override
    {
        fflush(stdout);
    }
};

typedef stdout_sink<details::null_mutex> stdout_sink_st;
typedef stdout_sink<std::mutex> stdout_sink_mt;


template <class Mutex>
class stderr_sink SPDLOG_FINAL : public base_sink<Mutex>
{
    using MyType = stderr_sink<Mutex>;
public:
    stderr_sink()
    {}
    static std::shared_ptr<MyType> instance()
    {
        static std::shared_ptr<MyType> instance = std::make_shared<MyType>();
        return instance;
    }
protected:
    void _sink_it(const details::log_msg& msg) override
    {
        fwrite(msg.formatted.data(), sizeof(char), msg.formatted.size(), stderr);
        _flush();
    }

    void _flush() override
    {
        fflush(stderr);
    }
};

typedef stderr_sink<std::mutex> stderr_sink_mt;
typedef stderr_sink<details::null_mutex> stderr_sink_st;
}
}

#include <memory>
#include <string>


// create logger with given name, sinks and the default pattern formatter
// all other ctors will call this one
template<class It>
inline spdlog::logger::logger(const std::string& logger_name, const It& begin, const It& end):
    _name(logger_name),
    _sinks(begin, end),
    _formatter(std::make_shared<pattern_formatter>("%+")),
    _level(level::info),
    _flush_level(level::off),
    _last_err_time(0),
    _msg_counter(1)  // message counter will start from 1. 0-message id will be reserved for controll messages
{
    _err_handler = [this](const std::string &msg)
    {
        this->_default_err_handler(msg);
    };
}

// ctor with sinks as init list
inline spdlog::logger::logger(const std::string& logger_name, sinks_init_list sinks_list):
    logger(logger_name, sinks_list.begin(), sinks_list.end())
{}


// ctor with single sink
inline spdlog::logger::logger(const std::string& logger_name, spdlog::sink_ptr single_sink):
    logger(logger_name,
{
    single_sink
})
{}


inline spdlog::logger::~logger() = default;


inline void spdlog::logger::set_formatter(spdlog::formatter_ptr msg_formatter)
{
    _set_formatter(msg_formatter);
}

inline void spdlog::logger::set_pattern(const std::string& pattern, pattern_time_type pattern_time)
{
    _set_pattern(pattern, pattern_time);
}


template <typename... Args>
inline void spdlog::logger::log(level::level_enum lvl, const char* fmt, const Args&... args)
{
    if (!should_log(lvl)) return;

    try
    {
        details::log_msg log_msg(&_name, lvl);
        log_msg.raw.write(fmt, args...);
        _sink_it(log_msg);
    }
    catch (const std::exception &ex)
    {
        _err_handler(ex.what());
    }
    catch (...)
    {
        _err_handler("Unknown exception");
    }
}

template <typename... Args>
inline void spdlog::logger::log(level::level_enum lvl, const char* msg)
{
    if (!should_log(lvl)) return;
    try
    {
        details::log_msg log_msg(&_name, lvl);
        log_msg.raw << msg;
        _sink_it(log_msg);
    }
    catch (const std::exception &ex)
    {
        _err_handler(ex.what());
    }
    catch (...)
    {
        _err_handler("Unknown exception");
    }

}

template<typename T>
inline void spdlog::logger::log(level::level_enum lvl, const T& msg)
{
    if (!should_log(lvl)) return;
    try
    {
        details::log_msg log_msg(&_name, lvl);
        log_msg.raw << msg;
        _sink_it(log_msg);
    }
    catch (const std::exception &ex)
    {
        _err_handler(ex.what());
    }
    catch (...)
    {
        _err_handler("Unknown exception");
    }
}


template <typename Arg1, typename... Args>
inline void spdlog::logger::trace(const char* fmt, const Arg1 &arg1, const Args&... args)
{
    log(level::trace, fmt, arg1, args...);
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::debug(const char* fmt, const Arg1 &arg1, const Args&... args)
{
    log(level::debug, fmt, arg1, args...);
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::info(const char* fmt, const Arg1 &arg1, const Args&... args)
{
    log(level::info, fmt, arg1, args...);
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::warn(const char* fmt, const Arg1 &arg1, const Args&... args)
{
    log(level::warn, fmt, arg1, args...);
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::error(const char* fmt, const Arg1 &arg1, const Args&... args)
{
    log(level::err, fmt, arg1, args...);
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::critical(const char* fmt, const Arg1 &arg1, const Args&... args)
{
    log(level::critical, fmt, arg1, args...);
}

template <typename... Args>
inline void spdlog::logger::log_if(const bool flag, level::level_enum lvl, const char* msg)
{
    if (flag)
    {
        log(lvl, msg);
    }
}

template<typename T>
inline void spdlog::logger::log_if(const bool flag, level::level_enum lvl, const T& msg)
{
    if (flag)
    {
        log(lvl, msg);
    }
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::trace_if(const bool flag, const char* fmt, const Arg1 &arg1, const Args&... args)
{
    if (flag)
    {
        log(level::trace, fmt, arg1, args...);
    }
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::debug_if(const bool flag, const char* fmt, const Arg1 &arg1, const Args&... args)
{
    if (flag)
    {
        log(level::debug, fmt, arg1, args...);
    }
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::info_if(const bool flag, const char* fmt, const Arg1 &arg1, const Args&... args)
{
    if (flag)
    {
        log(level::info, fmt, arg1, args...);
    }
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::warn_if(const bool flag, const char* fmt, const Arg1& arg1, const Args&... args)
{
    if (flag)
    {
        log(level::warn, fmt, arg1, args...);
    }
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::error_if(const bool flag, const char* fmt, const Arg1 &arg1, const Args&... args)
{
    if (flag)
    {
        log(level::err, fmt, arg1, args...);
    }
}

template <typename Arg1, typename... Args>
inline void spdlog::logger::critical_if(const bool flag, const char* fmt, const Arg1 &arg1, const Args&... args)
{
    if (flag)
    {
        log(level::critical, fmt, arg1, args...);
    }
}


template<typename T>
inline void spdlog::logger::trace(const T& msg)
{
    log(level::trace, msg);
}

template<typename T>
inline void spdlog::logger::debug(const T& msg)
{
    log(level::debug, msg);
}


template<typename T>
inline void spdlog::logger::info(const T& msg)
{
    log(level::info, msg);
}


template<typename T>
inline void spdlog::logger::warn(const T& msg)
{
    log(level::warn, msg);
}

template<typename T>
inline void spdlog::logger::error(const T& msg)
{
    log(level::err, msg);
}

template<typename T>
inline void spdlog::logger::critical(const T& msg)
{
    log(level::critical, msg);
}

template<typename T>
inline void spdlog::logger::trace_if(const bool flag, const T& msg)
{
    if (flag)
    {
        log(level::trace, msg);
    }
}

template<typename T>
inline void spdlog::logger::debug_if(const bool flag, const T& msg)
{
    if (flag)
    {
        log(level::debug, msg);
    }
}

template<typename T>
inline void spdlog::logger::info_if(const bool flag, const T& msg)
{
    if (flag)
    {
        log(level::info, msg);
    }
}

template<typename T>
inline void spdlog::logger::warn_if(const bool flag, const T& msg)
{
    if (flag)
    {
        log(level::warn, msg);
    }
}

template<typename T>
inline void spdlog::logger::error_if(const bool flag, const T& msg)
{
    if (flag)
    {
        log(level::err, msg);
    }
}

template<typename T>
inline void spdlog::logger::critical_if(const bool flag, const T& msg)
{
    if (flag)
    {
        log(level::critical, msg);
    }
}


#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
#include <codecvt>

template <typename... Args>
inline void spdlog::logger::log(level::level_enum lvl, const wchar_t* msg)
{
    std::wstring_convert<std::codecvt_utf8<wchar_t> > conv;

    log(lvl, conv.to_bytes(msg));
}

template <typename... Args>
inline void spdlog::logger::log(level::level_enum lvl, const wchar_t* fmt, const Args&... args)
{
    fmt::WMemoryWriter wWriter;

    wWriter.write(fmt, args...);
    log(lvl, wWriter.c_str());
}

template <typename... Args>
inline void spdlog::logger::trace(const wchar_t* fmt, const Args&... args)
{
    log(level::trace, fmt, args...);
}

template <typename... Args>
inline void spdlog::logger::debug(const wchar_t* fmt, const Args&... args)
{
    log(level::debug, fmt, args...);
}

template <typename... Args>
inline void spdlog::logger::info(const wchar_t* fmt, const Args&... args)
{
    log(level::info, fmt, args...);
}


template <typename... Args>
inline void spdlog::logger::warn(const wchar_t* fmt, const Args&... args)
{
    log(level::warn, fmt, args...);
}

template <typename... Args>
inline void spdlog::logger::error(const wchar_t* fmt, const Args&... args)
{
    log(level::err, fmt, args...);
}

template <typename... Args>
inline void spdlog::logger::critical(const wchar_t* fmt, const Args&... args)
{
    log(level::critical, fmt, args...);
}

//
// conditional logging
//

template <typename... Args>
inline void spdlog::logger::log_if(const bool flag, level::level_enum lvl, const wchar_t* msg)
{
    if (flag)
    {
        log(lvl, msg);
    }
}

template <typename... Args>
inline void spdlog::logger::log_if(const bool flag, level::level_enum lvl, const wchar_t* fmt, const Args&... args)
{
    if (flag)
    {
        log(lvl, fmt, args);
    }
}

template <typename... Args>
inline void spdlog::logger::trace_if(const bool flag, const wchar_t* fmt, const Args&... args)
{
    if (flag)
    {
        log(level::trace, fmt, args...);
    }
}

template <typename... Args>
inline void spdlog::logger::debug_if(const bool flag, const wchar_t* fmt, const Args&... args)
{
    if (flag)
    {
        log(level::debug, fmt, args...);
    }
}

template <typename... Args>
inline void spdlog::logger::info_if(const bool flag, const wchar_t* fmt, const Args&... args)
{
    if (flag)
    {
        log(level::info, fmt, args...);
    }
}


template <typename... Args>
inline void spdlog::logger::warn_if(const bool flag, const wchar_t* fmt, const Args&... args)
{
    if (flag)
    {
        log(level::warn, fmt, args...);
    }
}

template <typename... Args>
inline void spdlog::logger::error_if(const bool flag, const wchar_t* fmt, const Args&... args)
{
    if (flag)
    {
        log(level::err, fmt, args...);
    }
}

template <typename... Args>
inline void spdlog::logger::critical_if(const bool flag, const wchar_t* fmt, const Args&... args)
{
    if (flag)
    {
        log(level::critical, fmt, args...);
    }
}

#endif // SPDLOG_WCHAR_TO_UTF8_SUPPORT



//
// name and level
//
inline const std::string& spdlog::logger::name() const
{
    return _name;
}

inline void spdlog::logger::set_level(spdlog::level::level_enum log_level)
{
    _level.store(log_level);
}

inline void spdlog::logger::set_error_handler(spdlog::log_err_handler err_handler)
{
    _err_handler = err_handler;
}

inline spdlog::log_err_handler spdlog::logger::error_handler()
{
    return _err_handler;
}


inline void spdlog::logger::flush_on(level::level_enum log_level)
{
    _flush_level.store(log_level);
}

inline spdlog::level::level_enum spdlog::logger::level() const
{
    return static_cast<spdlog::level::level_enum>(_level.load(std::memory_order_relaxed));
}

inline bool spdlog::logger::should_log(spdlog::level::level_enum msg_level) const
{
    return msg_level >= _level.load(std::memory_order_relaxed);
}

//
// protected virtual called at end of each user log call (if enabled) by the line_logger
//
inline void spdlog::logger::_sink_it(details::log_msg& msg)
{
#if defined(SPDLOG_ENABLE_MESSAGE_COUNTER)
    msg.msg_id = _msg_counter.fetch_add(1, std::memory_order_relaxed);
#endif
    _formatter->format(msg);
    for (auto &sink : _sinks)
    {
        if( sink->should_log( msg.level))
        {
            sink->log(msg);
        }
    }

    if(_should_flush_on(msg))
        flush();
}

inline void spdlog::logger::_set_pattern(const std::string& pattern, pattern_time_type pattern_time)
{
    _formatter = std::make_shared<pattern_formatter>(pattern, pattern_time);
}
inline void spdlog::logger::_set_formatter(formatter_ptr msg_formatter)
{
    _formatter = msg_formatter;
}

inline void spdlog::logger::flush()
{
    for (auto& sink : _sinks)
        sink->flush();
}

inline void spdlog::logger::_default_err_handler(const std::string &msg)
{
    auto now = time(nullptr);
    if (now - _last_err_time < 60)
        return;
    auto tm_time = details::os::localtime(now);
    char date_buf[100];
    std::strftime(date_buf, sizeof(date_buf), "%Y-%m-%d %H:%M:%S", &tm_time);
    details::log_msg  err_msg;
    err_msg.formatted.write("[*** LOG ERROR ***] [{}] [{}] [{}]{}", name(), msg, date_buf, details::os::eol);
    sinks::stderr_sink_mt::instance()->log(err_msg);
    _last_err_time = now;
}

inline bool spdlog::logger::_should_flush_on(const details::log_msg &msg)
{
    const auto flush_level = _flush_level.load(std::memory_order_relaxed);
    return (msg.level >= flush_level) && (msg.level != level::off);
}

inline const std::vector<spdlog::sink_ptr>& spdlog::logger::sinks() const
{
    return _sinks;
}

#include <memory>
#include <functional>
#include <chrono>
#include <string>

namespace spdlog
{

//
// Return an existing logger or nullptr if a logger with such name doesn't exist.
// example: spdlog::get("my_logger")->info("hello {}", "world");
//
std::shared_ptr<logger> get(const std::string& name);


//
// Set global formatting
// example: spdlog::set_pattern("%Y-%m-%d %H:%M:%S.%e %l : %v");
//
void set_pattern(const std::string& format_string);
void set_formatter(formatter_ptr f);

//
// Set global logging level for
//
void set_level(level::level_enum log_level);

//
// Set global error handler
//
void set_error_handler(log_err_handler);

//
// Turn on async mode (off by default) and set the queue size for each async_logger.
// effective only for loggers created after this call.
// queue_size: size of queue (must be power of 2):
//    Each logger will pre-allocate a dedicated queue with queue_size entries upon construction.
//
// async_overflow_policy (optional, block_retry by default):
//    async_overflow_policy::block_retry - if queue is full, block until queue has room for the new log entry.
//    async_overflow_policy::discard_log_msg - never block and discard any new messages when queue  overflows.
//
// worker_warmup_cb (optional):
//     callback function that will be called in worker thread upon start (can be used to init stuff like thread affinity)
//
// worker_teardown_cb (optional):
//     callback function that will be called in worker thread upon exit
//
void set_async_mode(size_t queue_size, const async_overflow_policy overflow_policy = async_overflow_policy::block_retry, const std::function<void()>& worker_warmup_cb = nullptr, const std::chrono::milliseconds& flush_interval_ms = std::chrono::milliseconds::zero(), const std::function<void()>& worker_teardown_cb = nullptr);

// Turn off async mode
void set_sync_mode();


//
// Create and register multi/single threaded basic file logger.
// Basic logger simply writes to given file without any limitations or rotations.
//
std::shared_ptr<logger> basic_logger_mt(const std::string& logger_name, const filename_t& filename, bool truncate = false);
std::shared_ptr<logger> basic_logger_st(const std::string& logger_name, const filename_t& filename, bool truncate = false);

//
// Create and register multi/single threaded rotating file logger
//
std::shared_ptr<logger> rotating_logger_mt(const std::string& logger_name, const filename_t& filename, size_t max_file_size, size_t max_files);
std::shared_ptr<logger> rotating_logger_st(const std::string& logger_name, const filename_t& filename, size_t max_file_size, size_t max_files);

//
// Create file logger which creates new file on the given time (default in  midnight):
//
std::shared_ptr<logger> daily_logger_mt(const std::string& logger_name, const filename_t& filename, int hour=0, int minute=0);
std::shared_ptr<logger> daily_logger_st(const std::string& logger_name, const filename_t& filename, int hour=0, int minute=0);

//
// Create and register stdout/stderr loggers
//
std::shared_ptr<logger> stdout_logger_mt(const std::string& logger_name);
std::shared_ptr<logger> stdout_logger_st(const std::string& logger_name);
std::shared_ptr<logger> stderr_logger_mt(const std::string& logger_name);
std::shared_ptr<logger> stderr_logger_st(const std::string& logger_name);
//
// Create and register colored stdout/stderr loggers
//
std::shared_ptr<logger> stdout_color_mt(const std::string& logger_name);
std::shared_ptr<logger> stdout_color_st(const std::string& logger_name);
std::shared_ptr<logger> stderr_color_mt(const std::string& logger_name);
std::shared_ptr<logger> stderr_color_st(const std::string& logger_name);


//
// Create and register a syslog logger
//
#ifdef SPDLOG_ENABLE_SYSLOG
std::shared_ptr<logger> syslog_logger(const std::string& logger_name, const std::string& ident = "", int syslog_option = 0);
#endif

#if defined(__ANDROID__)
std::shared_ptr<logger> android_logger(const std::string& logger_name, const std::string& tag = "spdlog");
#endif

// Create and register a logger with a single sink
std::shared_ptr<logger> create(const std::string& logger_name, const sink_ptr& sink);

// Create and register a logger with multiple sinks
std::shared_ptr<logger> create(const std::string& logger_name, sinks_init_list sinks);
template<class It>
std::shared_ptr<logger> create(const std::string& logger_name, const It& sinks_begin, const It& sinks_end);


// Create and register a logger with templated sink type
// Example:
// spdlog::create<daily_file_sink_st>("mylog", "dailylog_filename");
template <typename Sink, typename... Args>
std::shared_ptr<spdlog::logger> create(const std::string& logger_name, Args...);

// Create and register an async logger with a single sink
std::shared_ptr<logger> create_async(const std::string& logger_name, const sink_ptr& sink, size_t queue_size, const async_overflow_policy overflow_policy = async_overflow_policy::block_retry, const std::function<void()>& worker_warmup_cb = nullptr, const std::chrono::milliseconds& flush_interval_ms = std::chrono::milliseconds::zero(), const std::function<void()>& worker_teardown_cb = nullptr);

// Create and register an async logger with multiple sinks
std::shared_ptr<logger> create_async(const std::string& logger_name, sinks_init_list sinks, size_t queue_size, const async_overflow_policy overflow_policy = async_overflow_policy::block_retry, const std::function<void()>& worker_warmup_cb = nullptr, const std::chrono::milliseconds& flush_interval_ms = std::chrono::milliseconds::zero(), const std::function<void()>& worker_teardown_cb = nullptr);
template<class It>
std::shared_ptr<logger> create_async(const std::string& logger_name, const It& sinks_begin, const It& sinks_end, size_t queue_size, const async_overflow_policy overflow_policy = async_overflow_policy::block_retry, const std::function<void()>& worker_warmup_cb = nullptr, const std::chrono::milliseconds& flush_interval_ms = std::chrono::milliseconds::zero(), const std::function<void()>& worker_teardown_cb = nullptr);

// Register the given logger with the given name
void register_logger(std::shared_ptr<logger> logger);

// Apply a user defined function on all registered loggers
// Example:
// spdlog::apply_all([&](std::shared_ptr<spdlog::logger> l) {l->flush();});
void apply_all(std::function<void(std::shared_ptr<logger>)> fun);

// Drop the reference to the given logger
void drop(const std::string &name);

// Drop all references from the registry
void drop_all();


///////////////////////////////////////////////////////////////////////////////
//
// Trace & Debug can be switched on/off at compile time for zero cost debug statements.
// Uncomment SPDLOG_DEBUG_ON/SPDLOG_TRACE_ON in teakme.h to enable.
// SPDLOG_TRACE(..) will also print current file and line.
//
// Example:
// spdlog::set_level(spdlog::level::trace);
// SPDLOG_TRACE(my_logger, "some trace message");
// SPDLOG_TRACE(my_logger, "another trace message {} {}", 1, 2);
// SPDLOG_DEBUG(my_logger, "some debug message {} {}", 3, 4);
// SPDLOG_DEBUG_IF(my_logger, true, "some debug message {} {}", 3, 4);
///////////////////////////////////////////////////////////////////////////////

#ifdef SPDLOG_TRACE_ON
#define SPDLOG_STR_H(x) #x
#define SPDLOG_STR_HELPER(x) SPDLOG_STR_H(x)
#define SPDLOG_TRACE(logger, ...) logger->trace("[" __FILE__ " line #" SPDLOG_STR_HELPER(__LINE__) "] " __VA_ARGS__)
#define SPDLOG_TRACE_IF(logger, flag, ...) logger->trace_if(flag, "[" __FILE__ " line #" SPDLOG_STR_HELPER(__LINE__) "] " __VA_ARGS__)
#else
#define SPDLOG_TRACE(logger, ...)
#define SPDLOG_TRACE_IF(logger, flag, ...)
#endif

#ifdef SPDLOG_DEBUG_ON
#define SPDLOG_DEBUG(logger, ...) logger->debug(__VA_ARGS__)
#define SPDLOG_DEBUG_IF(logger, flag, ...) logger->debug_if(flag, __VA_ARGS__)
#else
#define SPDLOG_DEBUG(logger, ...)
#define SPDLOG_DEBUG_IF(logger, flag, ...)
#endif

}


//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


//
// Global registry functions
//
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


// Loggers registy of unique name->logger pointer
// An attempt to create a logger with an already existing name will be ignored
// If user requests a non existing logger, nullptr will be returned
// This class is thread safe

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


// Very fast asynchronous logger (millions of logs per second on an average desktop)
// Uses pre allocated lockfree queue for maximum throughput even under large number of threads.
// Creates a single back thread to pop messages from the queue and log them.
//
// Upon each log write the logger:
//    1. Checks if its log level is enough to log the message
//    2. Push a new copy of the message to a queue (or block the caller until space is available in the queue)
//    3. will throw spdlog_ex upon log exceptions
// Upon destruction, logs all remaining messages in the queue before destructing..


#include <chrono>
#include <functional>
#include <string>
#include <memory>

namespace spdlog
{

namespace details
{
class async_log_helper;
}

class async_logger SPDLOG_FINAL :public logger
{
public:
    template<class It>
    async_logger(const std::string& name,
                 const It& begin,
                 const It& end,
                 size_t queue_size,
                 const async_overflow_policy overflow_policy =  async_overflow_policy::block_retry,
                 const std::function<void()>& worker_warmup_cb = nullptr,
                 const std::chrono::milliseconds& flush_interval_ms = std::chrono::milliseconds::zero(),
                 const std::function<void()>& worker_teardown_cb = nullptr);

    async_logger(const std::string& logger_name,
                 sinks_init_list sinks,
                 size_t queue_size,
                 const async_overflow_policy overflow_policy = async_overflow_policy::block_retry,
                 const std::function<void()>& worker_warmup_cb = nullptr,
                 const std::chrono::milliseconds& flush_interval_ms = std::chrono::milliseconds::zero(),
                 const std::function<void()>& worker_teardown_cb = nullptr);

    async_logger(const std::string& logger_name,
                 sink_ptr single_sink,
                 size_t queue_size,
                 const async_overflow_policy overflow_policy =  async_overflow_policy::block_retry,
                 const std::function<void()>& worker_warmup_cb = nullptr,
                 const std::chrono::milliseconds& flush_interval_ms = std::chrono::milliseconds::zero(),
                 const std::function<void()>& worker_teardown_cb = nullptr);

    //Wait for the queue to be empty, and flush synchronously
    //Warning: this can potentially last forever as we wait it to complete
    void flush() override;

    // Error handler
    virtual void set_error_handler(log_err_handler) override;
    virtual log_err_handler error_handler() override;

protected:
    void _sink_it(details::log_msg& msg) override;
    void _set_formatter(spdlog::formatter_ptr msg_formatter) override;
    void _set_pattern(const std::string& pattern, pattern_time_type pattern_time) override;

private:
    std::unique_ptr<details::async_log_helper> _async_log_helper;
};
}


//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


// Async Logger implementation
// Use an async_sink (queue per logger) to perform the logging in a worker thread

//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

// async log helper :
// Process logs asynchronously using a back thread.
//
// If the internal queue of log messages reaches its max size,
// then the client call will block until there is more room.
//


/*
A modified version of Bounded MPMC queue by Dmitry Vyukov.

Original code from:
http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue

licensed by Dmitry Vyukov under the terms below:

Simplified BSD license

Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright notice, this list of
conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list
of conditions and the following disclaimer in the documentation and/or other materials
provided with the distribution.

THIS SOFTWARE IS PROVIDED BY DMITRY VYUKOV "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL DMITRY VYUKOV OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those of the authors and
should not be interpreted as representing official policies, either expressed or implied, of Dmitry Vyukov.
*/

/*
The code in its current form adds the license below:

Copyright(c) 2015 Gabi Melman.
Distributed under the MIT License (http://opensource.org/licenses/MIT)

*/



#include <atomic>
#include <utility>

namespace spdlog
{
namespace details
{

template<typename T>
class mpmc_bounded_queue
{
public:

    using item_type = T;
    mpmc_bounded_queue(size_t buffer_size)
        :max_size_(buffer_size),
         buffer_(new cell_t [buffer_size]),
         buffer_mask_(buffer_size - 1)
    {
        //queue size must be power of two
        if(!((buffer_size >= 2) && ((buffer_size & (buffer_size - 1)) == 0)))
            throw spdlog_ex("async logger queue size must be power of two");

        for (size_t i = 0; i != buffer_size; i += 1)
            buffer_[i].sequence_.store(i, std::memory_order_relaxed);
        enqueue_pos_.store(0, std::memory_order_relaxed);
        dequeue_pos_.store(0, std::memory_order_relaxed);
    }

    ~mpmc_bounded_queue()
    {
        delete [] buffer_;
    }


    bool enqueue(T&& data)
    {
        cell_t* cell;
        size_t pos = enqueue_pos_.load(std::memory_order_relaxed);
        for (;;)
        {
            cell = &buffer_[pos & buffer_mask_];
            size_t seq = cell->sequence_.load(std::memory_order_acquire);
            intptr_t dif = (intptr_t)seq - (intptr_t)pos;
            if (dif == 0)
            {
                if (enqueue_pos_.compare_exchange_weak(pos, pos + 1, std::memory_order_relaxed))
                    break;
            }
            else if (dif < 0)
            {
                return false;
            }
            else
            {
                pos = enqueue_pos_.load(std::memory_order_relaxed);
            }
        }
        cell->data_ = std::move(data);
        cell->sequence_.store(pos + 1, std::memory_order_release);
        return true;
    }

    bool dequeue(T& data)
    {
        cell_t* cell;
        size_t pos = dequeue_pos_.load(std::memory_order_relaxed);
        for (;;)
        {
            cell = &buffer_[pos & buffer_mask_];
            size_t seq =
                cell->sequence_.load(std::memory_order_acquire);
            intptr_t dif = (intptr_t)seq - (intptr_t)(pos + 1);
            if (dif == 0)
            {
                if (dequeue_pos_.compare_exchange_weak(pos, pos + 1, std::memory_order_relaxed))
                    break;
            }
            else if (dif < 0)
                return false;
            else
                pos = dequeue_pos_.load(std::memory_order_relaxed);
        }
        data = std::move(cell->data_);
        cell->sequence_.store(pos + buffer_mask_ + 1, std::memory_order_release);
        return true;
    }

    size_t approx_size()
    {
        size_t first_pos = dequeue_pos_.load(std::memory_order_relaxed);
        size_t last_pos = enqueue_pos_.load(std::memory_order_relaxed);
        if (last_pos <= first_pos)
            return 0;
        auto size = last_pos - first_pos;
        return size < max_size_ ? size : max_size_;
    }

private:
    struct cell_t
    {
        std::atomic<size_t>   sequence_;
        T                     data_;
    };

    size_t const max_size_;

    static size_t const     cacheline_size = 64;
    typedef char            cacheline_pad_t [cacheline_size];

    cacheline_pad_t         pad0_;
    cell_t* const           buffer_;
    size_t const            buffer_mask_;
    cacheline_pad_t         pad1_;
    std::atomic<size_t>     enqueue_pos_;
    cacheline_pad_t         pad2_;
    std::atomic<size_t>     dequeue_pos_;
    cacheline_pad_t         pad3_;

    mpmc_bounded_queue(mpmc_bounded_queue const&) = delete;
    void operator= (mpmc_bounded_queue const&) = delete;
};

} // ns details
} // ns spdlog

#include <chrono>
#include <exception>
#include <functional>
#include <memory>
#include <string>
#include <thread>
#include <utility>
#include <vector>

namespace spdlog
{
namespace details
{

class async_log_helper
{
    // Async msg to move to/from the queue
    // Movable only. should never be copied
    enum class async_msg_type
    {
        log,
        flush,
        terminate
    };
    struct async_msg
    {
        std::string logger_name;
        level::level_enum level;
        log_clock::time_point time;
        size_t thread_id;
        std::string txt;
        async_msg_type msg_type;
        size_t msg_id;

        async_msg() = default;
        ~async_msg() = default;


async_msg(async_msg&& other) SPDLOG_NOEXCEPT:
        logger_name(std::move(other.logger_name)),
                    level(std::move(other.level)),
                    time(std::move(other.time)),
                    thread_id(other.thread_id),
                    txt(std::move(other.txt)),
                    msg_type(std::move(other.msg_type)),
                    msg_id(other.msg_id)
        {}

        async_msg(async_msg_type m_type):
            level(level::info),
            thread_id(0),
            msg_type(m_type),
            msg_id(0)
        {}

        async_msg& operator=(async_msg&& other) SPDLOG_NOEXCEPT
        {
            logger_name = std::move(other.logger_name);
            level = other.level;
            time = std::move(other.time);
            thread_id = other.thread_id;
            txt = std::move(other.txt);
            msg_type = other.msg_type;
            msg_id = other.msg_id;
            return *this;
        }

        // never copy or assign. should only be moved..
        async_msg(const async_msg&) = delete;
        async_msg& operator=(const async_msg& other) = delete;

        // construct from log_msg
        async_msg(const details::log_msg& m):
            level(m.level),
            time(m.time),
            thread_id(m.thread_id),
            txt(m.raw.data(), m.raw.size()),
            msg_type(async_msg_type::log),
            msg_id(m.msg_id)
        {
#ifndef SPDLOG_NO_NAME
            logger_name = *m.logger_name;
#endif
        }


        // copy into log_msg
        void fill_log_msg(log_msg &msg)
        {
            msg.logger_name = &logger_name;
            msg.level = level;
            msg.time = time;
            msg.thread_id = thread_id;
            msg.raw << txt;
            msg.msg_id = msg_id;
        }
    };

public:

    using item_type = async_msg;
    using q_type = details::mpmc_bounded_queue<item_type>;

    using clock = std::chrono::steady_clock;


    async_log_helper(formatter_ptr formatter,
                     const std::vector<sink_ptr>& sinks,
                     size_t queue_size,
                     const log_err_handler err_handler,
                     const async_overflow_policy overflow_policy = async_overflow_policy::block_retry,
                     const std::function<void()>& worker_warmup_cb = nullptr,
                     const std::chrono::milliseconds& flush_interval_ms = std::chrono::milliseconds::zero(),
                     const std::function<void()>& worker_teardown_cb = nullptr);

    void log(const details::log_msg& msg);

    // stop logging and join the back thread
    ~async_log_helper();

    void set_formatter(formatter_ptr);

    void flush(bool wait_for_q);

    void set_error_handler(spdlog::log_err_handler err_handler);

private:
    formatter_ptr _formatter;
    std::vector<std::shared_ptr<sinks::sink>> _sinks;

    // queue of messages to log
    q_type _q;

    log_err_handler _err_handler;

    bool _flush_requested;

    bool _terminate_requested;


    // overflow policy
    const async_overflow_policy _overflow_policy;

    // worker thread warmup callback - one can set thread priority, affinity, etc
    const std::function<void()> _worker_warmup_cb;

    // auto periodic sink flush parameter
    const std::chrono::milliseconds _flush_interval_ms;

    // worker thread teardown callback
    const std::function<void()> _worker_teardown_cb;

    // worker thread
    std::thread _worker_thread;

    void push_msg(async_msg&& new_msg);

    // worker thread main loop
    void worker_loop();

    // pop next message from the queue and process it. will set the last_pop to the pop time
    // return false if termination of the queue is required
    bool process_next_msg(log_clock::time_point& last_pop, log_clock::time_point& last_flush);

    void handle_flush_interval(log_clock::time_point& now, log_clock::time_point& last_flush);

    // sleep,yield or return immediately using the time passed since last message as a hint
    static void sleep_or_yield(const spdlog::log_clock::time_point& now, const log_clock::time_point& last_op_time);

    // wait until the queue is empty
    void wait_empty_q();

};
}
}

///////////////////////////////////////////////////////////////////////////////
// async_sink class implementation
///////////////////////////////////////////////////////////////////////////////
inline spdlog::details::async_log_helper::async_log_helper(
    formatter_ptr formatter,
    const std::vector<sink_ptr>& sinks,
    size_t queue_size,
    log_err_handler err_handler,
    const async_overflow_policy overflow_policy,
    const std::function<void()>& worker_warmup_cb,
    const std::chrono::milliseconds& flush_interval_ms,
    const std::function<void()>& worker_teardown_cb):
    _formatter(formatter),
    _sinks(sinks),
    _q(queue_size),
    _err_handler(err_handler),
    _flush_requested(false),
    _terminate_requested(false),
    _overflow_policy(overflow_policy),
    _worker_warmup_cb(worker_warmup_cb),
    _flush_interval_ms(flush_interval_ms),
    _worker_teardown_cb(worker_teardown_cb),
    _worker_thread(&async_log_helper::worker_loop, this)
{}

// Send to the worker thread termination message(level=off)
// and wait for it to finish gracefully
inline spdlog::details::async_log_helper::~async_log_helper()
{
    try
    {
        push_msg(async_msg(async_msg_type::terminate));
        _worker_thread.join();
    }
    catch (...) // don't crash in destructor
    {
    }
}


//Try to push and block until succeeded (if the policy is not to discard when the queue is full)
inline void spdlog::details::async_log_helper::log(const details::log_msg& msg)
{
    push_msg(async_msg(msg));
}

inline void spdlog::details::async_log_helper::push_msg(details::async_log_helper::async_msg&& new_msg)
{
    if (!_q.enqueue(std::move(new_msg)) && _overflow_policy != async_overflow_policy::discard_log_msg)
    {
        auto last_op_time = details::os::now();
        auto now = last_op_time;
        do
        {
            now = details::os::now();
            sleep_or_yield(now, last_op_time);
        }
        while (!_q.enqueue(std::move(new_msg)));
    }
}

// optionally wait for the queue be empty and request flush from the sinks
inline void spdlog::details::async_log_helper::flush(bool wait_for_q)
{
    push_msg(async_msg(async_msg_type::flush));
    if (wait_for_q)
        wait_empty_q(); //return only make after the above flush message was processed
}

inline void spdlog::details::async_log_helper::worker_loop()
{
    if (_worker_warmup_cb) _worker_warmup_cb();
    auto last_pop = details::os::now();
    auto last_flush = last_pop;
    auto active = true;
    while (active)
    {
        try
        {
            active = process_next_msg(last_pop, last_flush);
        }
        catch (const std::exception &ex)
        {
            _err_handler(ex.what());
        }
        catch (...)
        {
            _err_handler("Unknown exception");
        }
    }
    if (_worker_teardown_cb) _worker_teardown_cb();


}

// process next message in the queue
// return true if this thread should still be active (while no terminate msg was received)
inline bool spdlog::details::async_log_helper::process_next_msg(log_clock::time_point& last_pop, log_clock::time_point& last_flush)
{
    async_msg incoming_async_msg;

    if (_q.dequeue(incoming_async_msg))
    {
        last_pop = details::os::now();
        switch (incoming_async_msg.msg_type)
        {
        case async_msg_type::flush:
            _flush_requested = true;
            break;

        case async_msg_type::terminate:
            _flush_requested = true;
            _terminate_requested = true;
            break;

        default:
            log_msg incoming_log_msg;
            incoming_async_msg.fill_log_msg(incoming_log_msg);
            _formatter->format(incoming_log_msg);
            for (auto &s : _sinks)
            {
                if (s->should_log(incoming_log_msg.level))
                {
                    s->log(incoming_log_msg);
                }
            }
        }
        return true;
    }

    // Handle empty queue..
    // This is the only place where the queue can terminate or flush to avoid losing messages already in the queue
    else
    {
        auto now = details::os::now();
        handle_flush_interval(now, last_flush);
        sleep_or_yield(now, last_pop);
        return !_terminate_requested;
    }
}

// flush all sinks if _flush_interval_ms has expired
inline void spdlog::details::async_log_helper::handle_flush_interval(log_clock::time_point& now, log_clock::time_point& last_flush)
{
    auto should_flush = _flush_requested || (_flush_interval_ms != std::chrono::milliseconds::zero() && now - last_flush >= _flush_interval_ms);
    if (should_flush)
    {
        for (auto &s : _sinks)
            s->flush();
        now = last_flush = details::os::now();
        _flush_requested = false;
    }
}

inline void spdlog::details::async_log_helper::set_formatter(formatter_ptr msg_formatter)
{
    _formatter = msg_formatter;
}


// spin, yield or sleep. use the time passed since last message as a hint
inline void spdlog::details::async_log_helper::sleep_or_yield(const spdlog::log_clock::time_point& now, const spdlog::log_clock::time_point& last_op_time)
{
    using namespace std::this_thread;
    using std::chrono::milliseconds;
    using std::chrono::microseconds;

    auto time_since_op = now - last_op_time;

    // spin upto 50 micros
    if (time_since_op <= microseconds(50))
        return;

    // yield upto 150 micros
    if (time_since_op <= microseconds(100))
        return std::this_thread::yield();

    // sleep for 20 ms upto 200 ms
    if (time_since_op <= milliseconds(200))
        return sleep_for(milliseconds(20));

    // sleep for 200 ms
    return sleep_for(milliseconds(200));
}

// wait for the queue to be empty
inline void spdlog::details::async_log_helper::wait_empty_q()
{
    auto last_op = details::os::now();
    while (_q.approx_size() > 0)
    {
        sleep_or_yield(details::os::now(), last_op);
    }
}

inline void spdlog::details::async_log_helper::set_error_handler(spdlog::log_err_handler err_handler)
{
    _err_handler = err_handler;
}




#include <string>
#include <functional>
#include <chrono>
#include <memory>

template<class It>
inline spdlog::async_logger::async_logger(const std::string& logger_name,
        const It& begin,
        const It& end,
        size_t queue_size,
        const  async_overflow_policy overflow_policy,
        const std::function<void()>& worker_warmup_cb,
        const std::chrono::milliseconds& flush_interval_ms,
        const std::function<void()>& worker_teardown_cb) :
    logger(logger_name, begin, end),
    _async_log_helper(new details::async_log_helper(_formatter, _sinks, queue_size, _err_handler, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb))
{
}

inline spdlog::async_logger::async_logger(const std::string& logger_name,
        sinks_init_list sinks_list,
        size_t queue_size,
        const  async_overflow_policy overflow_policy,
        const std::function<void()>& worker_warmup_cb,
        const std::chrono::milliseconds& flush_interval_ms,
        const std::function<void()>& worker_teardown_cb) :
    async_logger(logger_name, sinks_list.begin(), sinks_list.end(), queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb) {}

inline spdlog::async_logger::async_logger(const std::string& logger_name,
        sink_ptr single_sink,
        size_t queue_size,
        const  async_overflow_policy overflow_policy,
        const std::function<void()>& worker_warmup_cb,
        const std::chrono::milliseconds& flush_interval_ms,
        const std::function<void()>& worker_teardown_cb) :
    async_logger(logger_name,
{
    single_sink
}, queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb) {}


inline void spdlog::async_logger::flush()
{
    _async_log_helper->flush(true);
}

// Error handler
inline void spdlog::async_logger::set_error_handler(spdlog::log_err_handler err_handler)
{
    _err_handler = err_handler;
    _async_log_helper->set_error_handler(err_handler);

}
inline spdlog::log_err_handler spdlog::async_logger::error_handler()
{
    return _err_handler;
}


inline void spdlog::async_logger::_set_formatter(spdlog::formatter_ptr msg_formatter)
{
    _formatter = msg_formatter;
    _async_log_helper->set_formatter(_formatter);
}

inline void spdlog::async_logger::_set_pattern(const std::string& pattern, pattern_time_type pattern_time)
{
    _formatter = std::make_shared<pattern_formatter>(pattern, pattern_time);
    _async_log_helper->set_formatter(_formatter);
}


inline void spdlog::async_logger::_sink_it(details::log_msg& msg)
{
    try
    {
#if defined(SPDLOG_ENABLE_MESSAGE_COUNTER)
        msg.msg_id = _msg_counter.fetch_add(1, std::memory_order_relaxed);
#endif
        _async_log_helper->log(msg);
        if (_should_flush_on(msg))
            _async_log_helper->flush(false); // do async flush
    }
    catch (const std::exception &ex)
    {
        _err_handler(ex.what());
    }
    catch (...)
    {
        _err_handler("Unknown exception");
    }
}

#include <chrono>
#include <functional>
#include <memory>
#include <mutex>
#include <string>
#include <unordered_map>

namespace spdlog
{
namespace details
{
template <class Mutex> class registry_t
{
public:

    void register_logger(std::shared_ptr<logger> logger)
    {
        std::lock_guard<Mutex> lock(_mutex);
        auto logger_name = logger->name();
        throw_if_exists(logger_name);
        _loggers[logger_name] = logger;
    }


    std::shared_ptr<logger> get(const std::string& logger_name)
    {
        std::lock_guard<Mutex> lock(_mutex);
        auto found = _loggers.find(logger_name);
        return found == _loggers.end() ? nullptr : found->second;
    }

    template<class It>
    std::shared_ptr<logger> create(const std::string& logger_name, const It& sinks_begin, const It& sinks_end)
    {
        std::lock_guard<Mutex> lock(_mutex);
        throw_if_exists(logger_name);
        std::shared_ptr<logger> new_logger;
        if (_async_mode)
            new_logger = std::make_shared<async_logger>(logger_name, sinks_begin, sinks_end, _async_q_size, _overflow_policy, _worker_warmup_cb, _flush_interval_ms, _worker_teardown_cb);
        else
            new_logger = std::make_shared<logger>(logger_name, sinks_begin, sinks_end);

        if (_formatter)
            new_logger->set_formatter(_formatter);

        if (_err_handler)
            new_logger->set_error_handler(_err_handler);

        new_logger->set_level(_level);


        //Add to registry
        _loggers[logger_name] = new_logger;
        return new_logger;
    }

    template<class It>
    std::shared_ptr<async_logger> create_async(const std::string& logger_name, size_t queue_size, const async_overflow_policy overflow_policy, const std::function<void()>& worker_warmup_cb, const std::chrono::milliseconds& flush_interval_ms, const std::function<void()>& worker_teardown_cb, const It& sinks_begin, const It& sinks_end)
    {
        std::lock_guard<Mutex> lock(_mutex);
        throw_if_exists(logger_name);
        auto new_logger = std::make_shared<async_logger>(logger_name, sinks_begin, sinks_end, queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb);

        if (_formatter)
            new_logger->set_formatter(_formatter);

        if (_err_handler)
            new_logger->set_error_handler(_err_handler);

        new_logger->set_level(_level);

        //Add to registry
        _loggers[logger_name] = new_logger;
        return new_logger;
    }

    void apply_all(std::function<void(std::shared_ptr<logger>)> fun)
    {
        std::lock_guard<Mutex> lock(_mutex);
        for (auto &l : _loggers)
            fun(l.second);
    }

    void drop(const std::string& logger_name)
    {
        std::lock_guard<Mutex> lock(_mutex);
        _loggers.erase(logger_name);
    }

    void drop_all()
    {
        std::lock_guard<Mutex> lock(_mutex);
        _loggers.clear();
    }
    std::shared_ptr<logger> create(const std::string& logger_name, sinks_init_list sinks)
    {
        return create(logger_name, sinks.begin(), sinks.end());
    }

    std::shared_ptr<logger> create(const std::string& logger_name, sink_ptr sink)
    {
        return create(logger_name, { sink });
    }

    std::shared_ptr<async_logger> create_async(const std::string& logger_name, size_t queue_size, const async_overflow_policy overflow_policy, const std::function<void()>& worker_warmup_cb, const std::chrono::milliseconds& flush_interval_ms, const std::function<void()>& worker_teardown_cb, sinks_init_list sinks)
    {
        return create_async(logger_name, queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb, sinks.begin(), sinks.end());
    }

    std::shared_ptr<async_logger> create_async(const std::string& logger_name, size_t queue_size, const async_overflow_policy overflow_policy, const std::function<void()>& worker_warmup_cb, const std::chrono::milliseconds& flush_interval_ms, const std::function<void()>& worker_teardown_cb, sink_ptr sink)
    {
        return create_async(logger_name, queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb, { sink });
    }

    void formatter(formatter_ptr f)
    {
        std::lock_guard<Mutex> lock(_mutex);
        _formatter = f;
        for (auto& l : _loggers)
            l.second->set_formatter(_formatter);
    }

    void set_pattern(const std::string& pattern)
    {
        std::lock_guard<Mutex> lock(_mutex);
        _formatter = std::make_shared<pattern_formatter>(pattern);
        for (auto& l : _loggers)
            l.second->set_formatter(_formatter);
    }

    void set_level(level::level_enum log_level)
    {
        std::lock_guard<Mutex> lock(_mutex);
        for (auto& l : _loggers)
            l.second->set_level(log_level);
        _level = log_level;
    }

    void set_error_handler(log_err_handler handler)
    {
        for (auto& l : _loggers)
            l.second->set_error_handler(handler);
        _err_handler = handler;
    }

    void set_async_mode(size_t q_size, const async_overflow_policy overflow_policy, const std::function<void()>& worker_warmup_cb, const std::chrono::milliseconds& flush_interval_ms, const std::function<void()>& worker_teardown_cb)
    {
        std::lock_guard<Mutex> lock(_mutex);
        _async_mode = true;
        _async_q_size = q_size;
        _overflow_policy = overflow_policy;
        _worker_warmup_cb = worker_warmup_cb;
        _flush_interval_ms = flush_interval_ms;
        _worker_teardown_cb = worker_teardown_cb;
    }

    void set_sync_mode()
    {
        std::lock_guard<Mutex> lock(_mutex);
        _async_mode = false;
    }

    static registry_t<Mutex>& instance()
    {
        static registry_t<Mutex> s_instance;
        return s_instance;
    }

private:
    registry_t<Mutex>() {}
    registry_t<Mutex>(const registry_t<Mutex>&) = delete;
    registry_t<Mutex>& operator=(const registry_t<Mutex>&) = delete;

    void throw_if_exists(const std::string &logger_name)
    {
        if (_loggers.find(logger_name) != _loggers.end())
            throw spdlog_ex("logger with name '" + logger_name + "' already exists");
    }
    Mutex _mutex;
    std::unordered_map <std::string, std::shared_ptr<logger>> _loggers;
    formatter_ptr _formatter;
    level::level_enum _level = level::info;
    log_err_handler _err_handler;
    bool _async_mode = false;
    size_t _async_q_size = 0;
    async_overflow_policy _overflow_policy = async_overflow_policy::block_retry;
    std::function<void()> _worker_warmup_cb = nullptr;
    std::chrono::milliseconds _flush_interval_ms;
    std::function<void()> _worker_teardown_cb = nullptr;
};
#ifdef SPDLOG_NO_REGISTRY_MUTEX
typedef registry_t<spdlog::details::null_mutex> registry;
#else
typedef registry_t<std::mutex> registry;
#endif
}
}
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


// Helper class for file sink
// When failing to open a file, retry several times(5) with small delay between the tries(10 ms)
// Throw spdlog_ex exception on errors


#include <chrono>
#include <cstdio>
#include <string>
#include <thread>
#include <cerrno>

namespace spdlog
{
namespace details
{

class file_helper
{

public:
    const int open_tries = 5;
    const int open_interval = 10;

    explicit file_helper() :
        _fd(nullptr)
    {}

    file_helper(const file_helper&) = delete;
    file_helper& operator=(const file_helper&) = delete;

    ~file_helper()
    {
        close();
    }


    void open(const filename_t& fname, bool truncate = false)
    {

        close();
        auto *mode = truncate ? SPDLOG_FILENAME_T("wb") : SPDLOG_FILENAME_T("ab");
        _filename = fname;
        for (int tries = 0; tries < open_tries; ++tries)
        {
            if (!os::fopen_s(&_fd, fname, mode))
                return;

            std::this_thread::sleep_for(std::chrono::milliseconds(open_interval));
        }

        throw spdlog_ex("Failed opening file " + os::filename_to_str(_filename) + " for writing", errno);
    }

    void reopen(bool truncate)
    {
        if (_filename.empty())
            throw spdlog_ex("Failed re opening file - was not opened before");
        open(_filename, truncate);

    }

    void flush()
    {
        std::fflush(_fd);
    }

    void close()
    {
        if (_fd)
        {
            std::fclose(_fd);
            _fd = nullptr;
        }
    }

    void write(const log_msg& msg)
    {

        size_t msg_size = msg.formatted.size();
        auto data = msg.formatted.data();
        if (std::fwrite(data, 1, msg_size, _fd) != msg_size)
            throw spdlog_ex("Failed writing to file " + os::filename_to_str(_filename), errno);
    }

    size_t size()
    {
        if (!_fd)
            throw spdlog_ex("Cannot use size() on closed file " + os::filename_to_str(_filename));
        return os::filesize(_fd);
    }

    const filename_t& filename() const
    {
        return _filename;
    }

    static bool file_exists(const filename_t& name)
    {

        return os::file_exists(name);
    }

private:
    FILE* _fd;
    filename_t _filename;
};
}
}

#include <algorithm>
#include <chrono>
#include <cstdio>
#include <ctime>
#include <mutex>
#include <string>
#include <cerrno>

namespace spdlog
{
namespace sinks
{
/*
 * Trivial file sink with single file as target
 */
template<class Mutex>
class simple_file_sink SPDLOG_FINAL : public base_sink < Mutex >
{
public:
    explicit simple_file_sink(const filename_t &filename, bool truncate = false):_force_flush(false)
    {
        _file_helper.open(filename, truncate);
    }

    void set_force_flush(bool force_flush)
    {
        _force_flush = force_flush;
    }

protected:
    void _sink_it(const details::log_msg& msg) override
    {
        _file_helper.write(msg);
        if(_force_flush)
            _file_helper.flush();
    }
    void _flush() override
    {
        _file_helper.flush();
    }
private:
    details::file_helper _file_helper;
    bool _force_flush;
};

typedef simple_file_sink<std::mutex> simple_file_sink_mt;
typedef simple_file_sink<details::null_mutex> simple_file_sink_st;

/*
 * Rotating file sink based on size
 */
template<class Mutex>
class rotating_file_sink SPDLOG_FINAL : public base_sink < Mutex >
{
public:
    rotating_file_sink(const filename_t &base_filename,
                       std::size_t max_size, std::size_t max_files) :
        _base_filename(base_filename),
        _max_size(max_size),
        _max_files(max_files),
        _current_size(0),
        _file_helper()
    {
        _file_helper.open(calc_filename(_base_filename, 0));
        _current_size = _file_helper.size(); //expensive. called only once
    }


protected:
    void _sink_it(const details::log_msg& msg) override
    {
        _current_size += msg.formatted.size();
        if (_current_size > _max_size)
        {
            _rotate();
            _current_size = msg.formatted.size();
        }
        _file_helper.write(msg);
    }

    void _flush() override
    {
        _file_helper.flush();
    }

private:
    static filename_t calc_filename(const filename_t& filename, std::size_t index)
    {
        std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;
        if (index)
            w.write(SPDLOG_FILENAME_T("{}.{}"), filename, index);
        else
            w.write(SPDLOG_FILENAME_T("{}"), filename);
        return w.str();
    }

    // Rotate files:
    // log.txt -> log.txt.1
    // log.txt.1 -> log.txt.2
    // log.txt.2 -> log.txt.3
    // lo3.txt.3 -> delete

    void _rotate()
    {
        using details::os::filename_to_str;
        _file_helper.close();
        for (auto i = _max_files; i > 0; --i)
        {
            filename_t src = calc_filename(_base_filename, i - 1);
            filename_t target = calc_filename(_base_filename, i);

            if (details::file_helper::file_exists(target))
            {
                if (details::os::remove(target) != 0)
                {
                    throw spdlog_ex("rotating_file_sink: failed removing " + filename_to_str(target), errno);
                }
            }
            if (details::file_helper::file_exists(src) && details::os::rename(src, target))
            {
                throw spdlog_ex("rotating_file_sink: failed renaming " + filename_to_str(src) + " to " + filename_to_str(target), errno);
            }
        }
        _file_helper.reopen(true);
    }
    filename_t _base_filename;
    std::size_t _max_size;
    std::size_t _max_files;
    std::size_t _current_size;
    details::file_helper _file_helper;
};

typedef rotating_file_sink<std::mutex> rotating_file_sink_mt;
typedef rotating_file_sink<details::null_mutex>rotating_file_sink_st;

/*
 * Default generator of daily log file names.
 */
struct default_daily_file_name_calculator
{
    // Create filename for the form basename.YYYY-MM-DD_hh-mm
    static filename_t calc_filename(const filename_t& basename)
    {
        std::tm tm = spdlog::details::os::localtime();
        std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;
        w.write(SPDLOG_FILENAME_T("{}_{:04d}-{:02d}-{:02d}_{:02d}-{:02d}"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);
        return w.str();
    }
};

/*
 * Generator of daily log file names in format basename.YYYY-MM-DD
 */
struct dateonly_daily_file_name_calculator
{
    // Create filename for the form basename.YYYY-MM-DD
    static filename_t calc_filename(const filename_t& basename)
    {
        std::tm tm = spdlog::details::os::localtime();
        std::conditional<std::is_same<filename_t::value_type, char>::value, fmt::MemoryWriter, fmt::WMemoryWriter>::type w;
        w.write(SPDLOG_FILENAME_T("{}_{:04d}-{:02d}-{:02d}"), basename, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);
        return w.str();
    }
};

/*
 * Rotating file sink based on date. rotates at midnight
 */
template<class Mutex, class FileNameCalc = default_daily_file_name_calculator>
class daily_file_sink SPDLOG_FINAL :public base_sink < Mutex >
{
public:
    //create daily file sink which rotates on given time
    daily_file_sink(
        const filename_t& base_filename,
        int rotation_hour,
        int rotation_minute) : _base_filename(base_filename),
        _rotation_h(rotation_hour),
        _rotation_m(rotation_minute)
    {
        if (rotation_hour < 0 || rotation_hour > 23 || rotation_minute < 0 || rotation_minute > 59)
            throw spdlog_ex("daily_file_sink: Invalid rotation time in ctor");
        _rotation_tp = _next_rotation_tp();
        _file_helper.open(FileNameCalc::calc_filename(_base_filename));
    }


protected:
    void _sink_it(const details::log_msg& msg) override
    {
        if (std::chrono::system_clock::now() >= _rotation_tp)
        {
            _file_helper.open(FileNameCalc::calc_filename(_base_filename));
            _rotation_tp = _next_rotation_tp();
        }
        _file_helper.write(msg);
    }

    void _flush() override
    {
        _file_helper.flush();
    }

private:
    std::chrono::system_clock::time_point _next_rotation_tp()
    {
        auto now = std::chrono::system_clock::now();
        time_t tnow = std::chrono::system_clock::to_time_t(now);
        tm date = spdlog::details::os::localtime(tnow);
        date.tm_hour = _rotation_h;
        date.tm_min = _rotation_m;
        date.tm_sec = 0;
        auto rotation_time = std::chrono::system_clock::from_time_t(std::mktime(&date));
        if (rotation_time > now)
            return rotation_time;
        else
            return std::chrono::system_clock::time_point(rotation_time + std::chrono::hours(24));
    }

    filename_t _base_filename;
    int _rotation_h;
    int _rotation_m;
    std::chrono::system_clock::time_point _rotation_tp;
    details::file_helper _file_helper;
};

typedef daily_file_sink<std::mutex> daily_file_sink_mt;
typedef daily_file_sink<details::null_mutex> daily_file_sink_st;
}
}
#ifdef SPDLOG_ENABLE_SYSLOG
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//



#ifdef SPDLOG_ENABLE_SYSLOG


#include <array>
#include <string>
#include <syslog.h>


namespace spdlog
{
namespace sinks
{
/**
 * Sink that write to syslog using the `syscall()` library call.
 *
 * Locking is not needed, as `syslog()` itself is thread-safe.
 */
class syslog_sink : public sink
{
public:
    //
    syslog_sink(const std::string& ident = "", int syslog_option=0, int syslog_facility=LOG_USER):
        _ident(ident)
    {
        _priorities[static_cast<int>(level::trace)] = LOG_DEBUG;
        _priorities[static_cast<int>(level::debug)] = LOG_DEBUG;
        _priorities[static_cast<int>(level::info)] = LOG_INFO;
        _priorities[static_cast<int>(level::warn)] = LOG_WARNING;
        _priorities[static_cast<int>(level::err)] = LOG_ERR;
        _priorities[static_cast<int>(level::critical)] = LOG_CRIT;
        _priorities[static_cast<int>(level::off)] = LOG_INFO;

        //set ident to be program name if empty
        ::openlog(_ident.empty()? nullptr:_ident.c_str(), syslog_option, syslog_facility);
    }
    ~syslog_sink()
    {
        ::closelog();
    }

    syslog_sink(const syslog_sink&) = delete;
    syslog_sink& operator=(const syslog_sink&) = delete;

    void log(const details::log_msg &msg) override
    {
        ::syslog(syslog_prio_from_level(msg), "%s", msg.raw.str().c_str());
    }

    void flush() override
    {
    }


private:
    std::array<int, 7> _priorities;
    //must store the ident because the man says openlog might use the pointer as is and not a string copy
    const std::string _ident;

    //
    // Simply maps spdlog's log level to syslog priority level.
    //
    int syslog_prio_from_level(const details::log_msg &msg) const
    {
        return _priorities[static_cast<int>(msg.level)];
    }
};
}
}

#endif
#endif

#ifdef _WIN32
//
// Copyright(c) 2016 spdlog
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//



#include <mutex>
#include <string>
#include <map>
#include <wincon.h>

namespace spdlog
{
namespace sinks
{
/*
 * Windows color console sink. Uses WriteConsoleA to write to the console with colors
 */
template<class Mutex>
class wincolor_sink: public  base_sink<Mutex>
{
public:
    const WORD BOLD = FOREGROUND_INTENSITY;
    const WORD RED = FOREGROUND_RED;
    const WORD CYAN = FOREGROUND_GREEN | FOREGROUND_BLUE;
    const WORD WHITE = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
    const WORD YELLOW = FOREGROUND_RED | FOREGROUND_GREEN;

    wincolor_sink(HANDLE std_handle): out_handle_(std_handle)
    {
        colors_[level::trace] = CYAN;
        colors_[level::debug] = CYAN;
        colors_[level::info] = WHITE | BOLD;
        colors_[level::warn] = YELLOW | BOLD;
        colors_[level::err] = RED | BOLD; // red bold
        colors_[level::critical] = BACKGROUND_RED | WHITE | BOLD; // white bold on red background
        colors_[level::off] = 0;
    }

    virtual ~wincolor_sink()
    {
        this->flush();
    }

    wincolor_sink(const wincolor_sink& other) = delete;
    wincolor_sink& operator=(const wincolor_sink& other) = delete;

protected:
    virtual void _sink_it(const details::log_msg& msg) override
    {
        auto color = colors_[msg.level];
        auto orig_attribs = set_console_attribs(color);
        WriteConsoleA(out_handle_, msg.formatted.data(), static_cast<DWORD>(msg.formatted.size()), nullptr, nullptr);
        SetConsoleTextAttribute(out_handle_, orig_attribs); //reset to orig colors
    }

    virtual void _flush() override
    {
        // windows console always flushed?
    }

    // change the  color for the given level
    void set_color(level::level_enum level, WORD color)
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::_mutex);
        colors_[level] = color;
    }

private:
    HANDLE out_handle_;
    std::map<level::level_enum, WORD> colors_;

    // set color and return the orig console attributes (for resetting later)
    WORD set_console_attribs(WORD attribs)
    {
        CONSOLE_SCREEN_BUFFER_INFO orig_buffer_info;
        GetConsoleScreenBufferInfo(out_handle_, &orig_buffer_info);
        WORD back_color = orig_buffer_info.wAttributes;
        // retrieve the current background color
        back_color &= ~(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY);
        // keep the background color unchanged
        SetConsoleTextAttribute(out_handle_, attribs | back_color);
        return  orig_buffer_info.wAttributes; //return orig attribs
    }
};

//
// windows color console to stdout
//
template<class Mutex>
class wincolor_stdout_sink: public wincolor_sink<Mutex>
{
public:
    wincolor_stdout_sink() : wincolor_sink<Mutex>(GetStdHandle(STD_OUTPUT_HANDLE))
    {}
};

typedef wincolor_stdout_sink<std::mutex> wincolor_stdout_sink_mt;
typedef wincolor_stdout_sink<details::null_mutex> wincolor_stdout_sink_st;

//
// windows color console to stderr
//
template<class Mutex>
class wincolor_stderr_sink: public wincolor_sink<Mutex>
{
public:
    wincolor_stderr_sink() : wincolor_sink<Mutex>(GetStdHandle(STD_ERROR_HANDLE))
    {}
};

typedef wincolor_stderr_sink<std::mutex> wincolor_stderr_sink_mt;
typedef wincolor_stderr_sink<details::null_mutex> wincolor_stderr_sink_st;

}
}
#else
//
// Copyright(c) 2017 spdlog authors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//



#include <string>
#include <map>

namespace spdlog
{
namespace sinks
{

/**
 * This sink prefixes the output with an ANSI escape sequence color code depending on the severity
 * of the message.
 * If no color terminal detected, omit the escape codes.
 */
template <class Mutex>
class ansicolor_sink: public base_sink<Mutex>
{
public:
    ansicolor_sink(FILE* file): target_file_(file)
    {
        should_do_colors_ = details::os::in_terminal(file) && details::os::is_color_terminal();
        colors_[level::trace] = cyan;
        colors_[level::debug] = cyan;
        colors_[level::info] = reset;
        colors_[level::warn] = yellow + bold;
        colors_[level::err] = red + bold;
        colors_[level::critical] = bold + on_red;
        colors_[level::off] = reset;
    }
    virtual ~ansicolor_sink()
    {
        _flush();
    }

    void set_color(level::level_enum color_level, const std::string& color)
    {
        std::lock_guard<Mutex> lock(base_sink<Mutex>::_mutex);
        colors_[color_level] = color;
    }

    /// Formatting codes
    const std::string reset = "\033[00m";
    const std::string bold = "\033[1m";
    const std::string dark = "\033[2m";
    const std::string underline = "\033[4m";
    const std::string blink = "\033[5m";
    const std::string reverse = "\033[7m";
    const std::string concealed = "\033[8m";

    // Foreground colors
    const std::string grey = "\033[30m";
    const std::string red = "\033[31m";
    const std::string green = "\033[32m";
    const std::string yellow = "\033[33m";
    const std::string blue = "\033[34m";
    const std::string magenta = "\033[35m";
    const std::string cyan = "\033[36m";
    const std::string white = "\033[37m";

    /// Background colors
    const std::string on_grey = "\033[40m";
    const std::string on_red = "\033[41m";
    const std::string on_green = "\033[42m";
    const std::string on_yellow = "\033[43m";
    const std::string on_blue = "\033[44m";
    const std::string on_magenta = "\033[45m";
    const std::string on_cyan = "\033[46m";
    const std::string on_white = "\033[47m";

protected:
    virtual void _sink_it(const details::log_msg& msg) override
    {
        // Wrap the originally formatted message in color codes.
        // If color is not supported in the terminal, log as is instead.
        if (should_do_colors_)
        {
            const std::string& prefix = colors_[msg.level];
            fwrite(prefix.data(), sizeof(char), prefix.size(), target_file_);
            fwrite(msg.formatted.data(), sizeof(char), msg.formatted.size(), target_file_);
            fwrite(reset.data(), sizeof(char), reset.size(), target_file_);
        }
        else
        {
            fwrite(msg.formatted.data(), sizeof(char), msg.formatted.size(), target_file_);
        }
        _flush();
    }

    void _flush() override
    {
        fflush(target_file_);
    }
    FILE* target_file_;
    bool should_do_colors_;
    std::map<level::level_enum, std::string> colors_;
};


template<class Mutex>
class ansicolor_stdout_sink: public ansicolor_sink<Mutex>
{
public:
    ansicolor_stdout_sink(): ansicolor_sink<Mutex>(stdout)
    {}
};

template<class Mutex>
class ansicolor_stderr_sink: public ansicolor_sink<Mutex>
{
public:
    ansicolor_stderr_sink(): ansicolor_sink<Mutex>(stderr)
    {}
};

typedef ansicolor_stdout_sink<std::mutex> ansicolor_stdout_sink_mt;
typedef ansicolor_stdout_sink<details::null_mutex> ansicolor_stdout_sink_st;

typedef ansicolor_stderr_sink<std::mutex> ansicolor_stderr_sink_mt;
typedef ansicolor_stderr_sink<details::null_mutex> ansicolor_stderr_sink_st;

} // namespace sinks
} // namespace spdlog

#endif


#ifdef __ANDROID__
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//


#if defined(__ANDROID__)


#include <mutex>
#include <string>
#include <android/log.h>
#include <thread>
#include <chrono>

#if !defined(SPDLOG_ANDROID_RETRIES)
#define SPDLOG_ANDROID_RETRIES 2
#endif

namespace spdlog
{
namespace sinks
{

/*
* Android sink (logging using __android_log_write)
* __android_log_write is thread-safe. No lock is needed.
*/
class android_sink : public sink
{
public:
    explicit android_sink(const std::string& tag = "spdlog", bool use_raw_msg = false): _tag(tag), _use_raw_msg(use_raw_msg) {}

    void log(const details::log_msg& msg) override
    {
        const android_LogPriority priority = convert_to_android(msg.level);
        const char *msg_output = (_use_raw_msg ? msg.raw.c_str() : msg.formatted.c_str());

        // See system/core/liblog/logger_write.c for explanation of return value
        int ret = __android_log_write(priority, _tag.c_str(), msg_output);
        int retry_count = 0;
        while ((ret == -11/*EAGAIN*/) && (retry_count < SPDLOG_ANDROID_RETRIES))
        {
            std::this_thread::sleep_for(std::chrono::milliseconds(5));
            ret = __android_log_write(priority, _tag.c_str(), msg_output);
            retry_count++;
        }

        if (ret < 0)
        {
            throw spdlog_ex("__android_log_write() failed", ret);
        }
    }

    void flush() override
    {
    }

private:
    static android_LogPriority convert_to_android(spdlog::level::level_enum level)
    {
        switch(level)
        {
        case spdlog::level::trace:
            return ANDROID_LOG_VERBOSE;
        case spdlog::level::debug:
            return ANDROID_LOG_DEBUG;
        case spdlog::level::info:
            return ANDROID_LOG_INFO;
        case spdlog::level::warn:
            return ANDROID_LOG_WARN;
        case spdlog::level::err:
            return ANDROID_LOG_ERROR;
        case spdlog::level::critical:
            return ANDROID_LOG_FATAL;
        default:
            return ANDROID_LOG_DEFAULT;
        }
    }

    std::string _tag;
    bool _use_raw_msg;
};

}
}

#endif
#endif

#include <chrono>
#include <functional>
#include <memory>
#include <string>

inline void spdlog::register_logger(std::shared_ptr<logger> logger)
{
    return details::registry::instance().register_logger(logger);
}

inline std::shared_ptr<spdlog::logger> spdlog::get(const std::string& name)
{
    return details::registry::instance().get(name);
}

inline void spdlog::drop(const std::string &name)
{
    details::registry::instance().drop(name);
}

// Create multi/single threaded simple file logger
inline std::shared_ptr<spdlog::logger> spdlog::basic_logger_mt(const std::string& logger_name, const filename_t& filename, bool truncate)
{
    return create<spdlog::sinks::simple_file_sink_mt>(logger_name, filename, truncate);
}

inline std::shared_ptr<spdlog::logger> spdlog::basic_logger_st(const std::string& logger_name, const filename_t& filename, bool truncate)
{
    return create<spdlog::sinks::simple_file_sink_st>(logger_name, filename, truncate);
}

// Create multi/single threaded rotating file logger
inline std::shared_ptr<spdlog::logger> spdlog::rotating_logger_mt(const std::string& logger_name, const filename_t& filename, size_t max_file_size, size_t max_files)
{
    return create<spdlog::sinks::rotating_file_sink_mt>(logger_name, filename, max_file_size, max_files);
}

inline std::shared_ptr<spdlog::logger> spdlog::rotating_logger_st(const std::string& logger_name, const filename_t& filename, size_t max_file_size, size_t max_files)
{
    return create<spdlog::sinks::rotating_file_sink_st>(logger_name, filename, max_file_size, max_files);
}

// Create file logger which creates new file at midnight):
inline std::shared_ptr<spdlog::logger> spdlog::daily_logger_mt(const std::string& logger_name, const filename_t& filename, int hour, int minute)
{
    return create<spdlog::sinks::daily_file_sink_mt>(logger_name, filename, hour, minute);
}

inline std::shared_ptr<spdlog::logger> spdlog::daily_logger_st(const std::string& logger_name, const filename_t& filename, int hour, int minute)
{
    return create<spdlog::sinks::daily_file_sink_st>(logger_name, filename, hour, minute);
}


//
// stdout/stderr loggers
//
inline std::shared_ptr<spdlog::logger> spdlog::stdout_logger_mt(const std::string& logger_name)
{
    return spdlog::details::registry::instance().create(logger_name, spdlog::sinks::stdout_sink_mt::instance());
}

inline std::shared_ptr<spdlog::logger> spdlog::stdout_logger_st(const std::string& logger_name)
{
    return spdlog::details::registry::instance().create(logger_name, spdlog::sinks::stdout_sink_st::instance());
}

inline std::shared_ptr<spdlog::logger> spdlog::stderr_logger_mt(const std::string& logger_name)
{
    return spdlog::details::registry::instance().create(logger_name, spdlog::sinks::stderr_sink_mt::instance());
}

inline std::shared_ptr<spdlog::logger> spdlog::stderr_logger_st(const std::string& logger_name)
{
    return spdlog::details::registry::instance().create(logger_name, spdlog::sinks::stderr_sink_st::instance());
}

//
// stdout/stderr color loggers
//
#ifdef _WIN32
inline std::shared_ptr<spdlog::logger> spdlog::stdout_color_mt(const std::string& logger_name)
{
    auto sink = std::make_shared<spdlog::sinks::wincolor_stdout_sink_mt>();
    return spdlog::details::registry::instance().create(logger_name, sink);
}

inline std::shared_ptr<spdlog::logger> spdlog::stdout_color_st(const std::string& logger_name)
{
    auto sink = std::make_shared<spdlog::sinks::wincolor_stdout_sink_st>();
    return spdlog::details::registry::instance().create(logger_name, sink);
}

inline std::shared_ptr<spdlog::logger> spdlog::stderr_color_mt(const std::string& logger_name)
{
    auto sink = std::make_shared<spdlog::sinks::wincolor_stderr_sink_mt>();
    return spdlog::details::registry::instance().create(logger_name, sink);
}


inline std::shared_ptr<spdlog::logger> spdlog::stderr_color_st(const std::string& logger_name)
{
    auto sink = std::make_shared<spdlog::sinks::wincolor_stderr_sink_st>();
    return spdlog::details::registry::instance().create(logger_name, sink);
}

#else //ansi terminal colors

inline std::shared_ptr<spdlog::logger> spdlog::stdout_color_mt(const std::string& logger_name)
{
    auto sink = std::make_shared<spdlog::sinks::ansicolor_stdout_sink_mt>();
    return spdlog::details::registry::instance().create(logger_name, sink);
}

inline std::shared_ptr<spdlog::logger> spdlog::stdout_color_st(const std::string& logger_name)
{
    auto sink = std::make_shared<spdlog::sinks::ansicolor_stdout_sink_st>();
    return spdlog::details::registry::instance().create(logger_name, sink);
}

inline std::shared_ptr<spdlog::logger> spdlog::stderr_color_mt(const std::string& logger_name)
{
    auto sink = std::make_shared<spdlog::sinks::ansicolor_stderr_sink_mt>();
    return spdlog::details::registry::instance().create(logger_name, sink);
}

inline std::shared_ptr<spdlog::logger> spdlog::stderr_color_st(const std::string& logger_name)
{
    auto sink = std::make_shared<spdlog::sinks::ansicolor_stderr_sink_st>();
    return spdlog::details::registry::instance().create(logger_name, sink);
}
#endif

#ifdef SPDLOG_ENABLE_SYSLOG
// Create syslog logger
inline std::shared_ptr<spdlog::logger> spdlog::syslog_logger(const std::string& logger_name, const std::string& syslog_ident, int syslog_option)
{
    return create<spdlog::sinks::syslog_sink>(logger_name, syslog_ident, syslog_option);
}
#endif

#ifdef __ANDROID__
inline std::shared_ptr<spdlog::logger> spdlog::android_logger(const std::string& logger_name, const std::string& tag)
{
    return create<spdlog::sinks::android_sink>(logger_name, tag);
}
#endif

// Create and register a logger a single sink
inline std::shared_ptr<spdlog::logger> spdlog::create(const std::string& logger_name, const spdlog::sink_ptr& sink)
{
    return details::registry::instance().create(logger_name, sink);
}

//Create logger with multiple sinks

inline std::shared_ptr<spdlog::logger> spdlog::create(const std::string& logger_name, spdlog::sinks_init_list sinks)
{
    return details::registry::instance().create(logger_name, sinks);
}


template <typename Sink, typename... Args>
inline std::shared_ptr<spdlog::logger> spdlog::create(const std::string& logger_name, Args... args)
{
    sink_ptr sink = std::make_shared<Sink>(args...);
    return details::registry::instance().create(logger_name, { sink });
}


template<class It>
inline std::shared_ptr<spdlog::logger> spdlog::create(const std::string& logger_name, const It& sinks_begin, const It& sinks_end)
{
    return details::registry::instance().create(logger_name, sinks_begin, sinks_end);
}

// Create and register an async logger with a single sink
inline std::shared_ptr<spdlog::logger> spdlog::create_async(const std::string& logger_name, const sink_ptr& sink, size_t queue_size, const async_overflow_policy overflow_policy, const std::function<void()>& worker_warmup_cb, const std::chrono::milliseconds& flush_interval_ms, const std::function<void()>& worker_teardown_cb)
{
    return details::registry::instance().create_async(logger_name, queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb, sink);
}

// Create and register an async logger with multiple sinks
inline std::shared_ptr<spdlog::logger> spdlog::create_async(const std::string& logger_name, sinks_init_list sinks, size_t queue_size, const async_overflow_policy overflow_policy, const std::function<void()>& worker_warmup_cb, const std::chrono::milliseconds& flush_interval_ms, const std::function<void()>& worker_teardown_cb )
{
    return details::registry::instance().create_async(logger_name, queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb, sinks);
}

template<class It>
inline std::shared_ptr<spdlog::logger> spdlog::create_async(const std::string& logger_name, const It& sinks_begin, const It& sinks_end, size_t queue_size, const async_overflow_policy overflow_policy, const std::function<void()>& worker_warmup_cb, const std::chrono::milliseconds& flush_interval_ms, const std::function<void()>& worker_teardown_cb)
{
    return details::registry::instance().create_async(logger_name, queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb, sinks_begin, sinks_end);
}

inline void spdlog::set_formatter(spdlog::formatter_ptr f)
{
    details::registry::instance().formatter(f);
}

inline void spdlog::set_pattern(const std::string& format_string)
{
    return details::registry::instance().set_pattern(format_string);
}

inline void spdlog::set_level(level::level_enum log_level)
{
    return details::registry::instance().set_level(log_level);
}

inline void spdlog::set_error_handler(log_err_handler handler)
{
    return details::registry::instance().set_error_handler(handler);
}


inline void spdlog::set_async_mode(size_t queue_size, const async_overflow_policy overflow_policy, const std::function<void()>& worker_warmup_cb, const std::chrono::milliseconds& flush_interval_ms, const std::function<void()>& worker_teardown_cb)
{
    details::registry::instance().set_async_mode(queue_size, overflow_policy, worker_warmup_cb, flush_interval_ms, worker_teardown_cb);
}

inline void spdlog::set_sync_mode()
{
    details::registry::instance().set_sync_mode();
}

inline void spdlog::apply_all(std::function<void(std::shared_ptr<logger>)> fun)
{
    details::registry::instance().apply_all(fun);
}

inline void spdlog::drop_all()
{
    details::registry::instance().drop_all();
}
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/




/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <vector>

TC_NAMESPACE_BEGIN

class Ray {
 public:
  Ray(){};
  Ray(Vector3 orig, Vector3 dir, real time = 0)
      : orig(orig), dir(dir), time(time), dist(DIST_INFINITE) {
    triangle_id = -1;
  }

  Vector3 at(real d) const {
    return orig + d * dir;
  }

  Vector3 orig, dir;
  real time, dist;
  int triangle_id;
  Vector3 geometry_normal;
  real u, v;

  const static real DIST_INFINITE;
};

struct Face {
  Face() {
  }

  Face(int v0, int v1, int v2) {
    vert_ind[0] = v0;
    vert_ind[1] = v1;
    vert_ind[2] = v2;
  }

  int vert_ind[3];
  int material;
};

struct Triangle {
  Triangle(){};
  int id;
  Vector3 v[3];
  Vector3 v10, v20, iv10, iv20;  // iv10 = (v1 - v0) / length(v1 - v0)^2
  Vector3 normal;
  Vector3 n0;
  Vector2 uv0, uv10, uv20;
  Vector3 n10, n20;
  real area;
  real temperature;
  real heat_capacity;
  Triangle(const Vector3 &v0,
           const Vector3 &v1,
           const Vector3 &v2,
           const Vector3 &n0,
           const Vector3 &n1,
           const Vector3 &n2,
           const Vector2 &uv0,
           const Vector2 &uv1,
           const Vector2 &uv2,
           int id = -1) {
    v[0] = v0;
    v[1] = v1;
    v[2] = v2;
    this->n0 = n0;
    this->uv0 = uv0;
    this->uv10 = uv1 - uv0;
    this->uv20 = uv2 - uv0;
    v10 = v1 - v0;
    v20 = v2 - v0;
    iv10 = 1.0_f / dot(v10, v10) * v10;
    iv20 = 1.0_f / dot(v20, v20) * v20;
    n10 = n1 - n0;
    n20 = n2 - n0;
    this->id = id;
    normal = normalized(cross(v10, v20));
    area = 0.5f * length(cross(v[1] - v[0], v[2] - v[0]));
  }

  Triangle get_transformed(const Matrix4 &transform) const {
    const Matrix4 normal_transform = transposed(inversed(transform));
    return Triangle(multiply_matrix4(transform, v[0], 1.0_f),
                    multiply_matrix4(transform, v[0] + v10, 1.0_f),
                    multiply_matrix4(transform, v[0] + v20, 1.0_f),
                    multiply_matrix4(normal_transform, n0, 0.0_f),
                    multiply_matrix4(normal_transform, n0 + n10, 0.0_f),
                    multiply_matrix4(normal_transform, n0 + n20, 0.0_f), uv0,
                    uv0 + uv10, uv0 + uv20, id);
  }

  void get_coord(const Ray &ray,
                 real dist,
                 real &coord_u,
                 real &coord_v) const {
    const Vector3 inter_local = ray.orig + ray.dir * dist - v[0];
    const Vector3 u = v10, v = v20;
    real uv = dot(u, v), vv = dot(v, v), wu = dot(inter_local, u),
         uu = dot(u, u), wv = dot(inter_local, v);
    real dom = uv * uv - uu * vv;
    coord_u = (uv * wv - vv * wu) / dom;
    coord_v = (uv * wu - uu * wv) / dom;
  }

  void get_coord(const Vector3 &inter, real &coord_u, real &coord_v) const {
    const Vector3 inter_local = inter - v[0];
    const Vector3 u = v10, v = v20;
    real uv = dot(u, v), vv = dot(v, v), wu = dot(inter_local, u),
         uu = dot(u, u), wv = dot(inter_local, v);
    real dom = uv * uv - uu * vv;
    coord_u = (uv * wv - vv * wu) / dom;
    coord_v = (uv * wu - uu * wv) / dom;
  }

  void intersect(Ray &ray) {
    const Vector3 &orig = ray.orig;
    const Vector3 &dir = ray.dir;
    real dir_n = dot(dir, normal);
    real dist_n = dot(v[0] - orig, normal);
    real dist = dist_n / dir_n;
    if (dist <= 0.0_f) {
      return;
    } else {
      if (dist > 0 && dist < ray.dist) {
        real coord_u, coord_v;
        get_coord(ray, dist, coord_u, coord_v);
        if (coord_u >= 0 && coord_v >= 0 && coord_u + coord_v <= 1) {
          ray.dist = dist;
          ray.triangle_id = id;
          ray.u = coord_u;
          ray.v = coord_v;
        }
      }
    }
  }
  Vector3 get_normal(real u, real v) const {
    return normalized(n0 + u * n10 + v * n20);
  }
  Vector2 get_uv(real u, real v) const {
    return uv0 + u * uv10 + v * uv20;
  }
  Vector2 get_duv(Vector3 dx) const {
    return uv10 * dot(iv10, dx) + uv20 * dot(iv20, dx);
  }
  Vector3 sample_point() const {
    return sample_point(rand(), rand());
  }
  Vector3 sample_point(real x, real y) const {
    if (x + y > 1) {
      x = 1 - x;
      y = 1 - y;
    }
    return v[0] + v10 * x + v20 * y;
  }
  real get_height(const Vector3 &p) const {
    return dot(normal, p - v[0]);
  }
  int get_relative_location_to_plane(const Vector3 &p) const {
    return sgn(get_height(p));
  }
  real max_edge_length(int &max_id) const {
    real ret = 0;
    for (int i = 0; i < 3; i++) {
      real dist = length(v[i] - v[(i + 1) % 3]);
      if (dist > ret) {
        max_id = i;
        ret = dist;
      }
    }
    return ret;
  }
  bool operator==(const Triangle &b) const {
    return false;
  }

  Vector3 get_center() const {
    return (v[0] + v[1] + v[2]) * (1.0_f / 3);
  }
};

class BoundingBox {
 public:
  Vector3 lower_boundary;
  Vector3 upper_boundary;
};

class Instance {
  Matrix4 transform;
};

TC_NAMESPACE_END

TC_NAMESPACE_BEGIN

template <int n, typename T>
using VectorLengthed = std::conditional_t<n != 1, VectorND<n, T>, T>;

template <int n, int m, typename T>
using VectorFunction =
    std::function<VectorLengthed<m, T>(VectorLengthed<n, T>)>;

using Function11 = VectorFunction<1, 1, real>;
using Function12 = VectorFunction<1, 2, real>;
using Function13 = VectorFunction<1, 3, real>;

using Function21 = VectorFunction<2, 1, real>;
using Function22 = VectorFunction<2, 2, real>;
using Function23 = VectorFunction<2, 3, real>;

using Function31 = VectorFunction<3, 1, real>;
using Function32 = VectorFunction<3, 2, real>;
using Function33 = VectorFunction<3, 3, real>;

class Mesh3D {
 public:
  // norm and uv can be null
  static std::vector<Triangle> generate(const Vector2i res,
                                        const Function23 *surf,
                                        const Function23 *norm,
                                        const Function22 *uv,
                                        bool smooth_normal);
};

TC_NAMESPACE_END

TC_NAMESPACE_BEGIN

Function11 python_at_exit;

void signal_handler(int signo);

#define TC_REGISTER_SIGNAL_HANDLER(name, handler)                    \
  {                                                                  \
    if (std::signal(name, handler) == SIG_ERR)                       \
      std::printf("Can not register signal handler for" #name "\n"); \
  }

void Logger::set_level(const std::string &level) {
  /*
  trace = 0,
  debug = 1,
  info = 2,
  warn = 3,
  err = 4,
  critical = 5,
  off = 6
  */
  if (level == "trace") {
    spdlog::set_level(spdlog::level::trace);
  } else if (level == "debug") {
    spdlog::set_level(spdlog::level::debug);
  } else if (level == "info") {
    spdlog::set_level(spdlog::level::info);
  } else if (level == "warn") {
    spdlog::set_level(spdlog::level::warn);
  } else if (level == "error") {
    spdlog::set_level(spdlog::level::err);
  } else if (level == "critical") {
    spdlog::set_level(spdlog::level::critical);
  } else if (level == "off") {
    spdlog::set_level(spdlog::level::off);
  } else {
    TC_ERROR(
        "Unknown logging level [{}]. Levels = trace, debug, info, warn, error, "
        "critical, off",
        level);
  }
}

Logger::Logger() {
  console = spdlog::stdout_color_mt("console");
  TC_LOG_SET_PATTERN("[%L %D %X.%e] %v")

  TC_REGISTER_SIGNAL_HANDLER(SIGSEGV, signal_handler);
  TC_REGISTER_SIGNAL_HANDLER(SIGABRT, signal_handler);
#if !defined(_WIN64)
  TC_REGISTER_SIGNAL_HANDLER(SIGBUS, signal_handler);
#endif
  TC_REGISTER_SIGNAL_HANDLER(SIGFPE, signal_handler);
  spdlog::set_level(spdlog::level::trace);
  TC_TRACE("Taichi core started. Thread ID = {}", PID::get_pid());
}

void Logger::trace(const std::string &s) {
  console->trace(s);
}

void Logger::debug(const std::string &s) {
  console->debug(s);
}

void Logger::info(const std::string &s) {
  console->info(s);
}

void Logger::warn(const std::string &s) {
  console->warn(s);
}
void Logger::error(const std::string &s, bool raise_signal) {
  console->error(s);
  if (raise_signal) {
    std::raise(SIGABRT);
  }
}
void Logger::critical(const std::string &s, bool raise_signal) {
  console->critical(s);
  if (raise_signal) {
    std::raise(SIGABRT);
  }
}
void Logger::flush() {
  console->flush();
}

Logger logger;

std::string signal_name(int sig) {
#if !defined(_WIN64)
  return strsignal(sig);
#else
  if (sig == SIGABRT) {
    return "SIGABRT";
  } else if (sig == SIGFPE) {
    return "SIGFPE";
  } else if (sig == SIGILL) {
    return "SIGFPE";
  } else if (sig == SIGSEGV) {
    return "SIGSEGV";
  } else if (sig == SIGTERM) {
    return "SIGTERM";
  } else {
    return "SIGNAL-Unknown";
  }
#endif
}

bool python_at_exit_called = false;

void signal_handler(int signo) {
  logger.error(
      fmt::format("Received signal {} ({})", signo, signal_name(signo)), false);
  TC_FLUSH_LOGGER;
  taichi::print_traceback();
  if (taichi::CoreState::get_instance().trigger_gdb_when_crash) {
    trash(system(fmt::format("sudo gdb -p {}", PID::get_pid()).c_str()));
  }
  if (python_at_exit && !python_at_exit_called) {
    python_at_exit_called = true;
    TC_INFO("Invoking registered Python at_exit...");
    python_at_exit(0);
    TC_INFO("Python-side at_exit returned.");
  }
  if (taichi::CoreState::get_instance().python_imported) {
    std::string msg = fmt::format("Taichi Core Exception: {} ({})", signo,
                                  signal_name(signo));
  }
  std::exit(-1);
}

TC_NAMESPACE_END
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/

#include <vector>
#include <iostream>
#ifdef __APPLE__
#include <execinfo.h>
#include <cxxabi.h>
#endif
#ifdef __linux__
#include <execinfo.h>
#include <signal.h>
#include <ucontext.h>
#include <unistd.h>
#include <cxxabi.h>
#endif
#include <string>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <memory>
#include <mutex>

TC_NAMESPACE_BEGIN

static std::mutex traceback_printer_mutex;

TC_EXPORT void print_traceback() {
#ifdef __APPLE__
  // Modified based on
  // http://www.nullptr.me/2013/04/14/generating-stack-trace-on-os-x/
  // TODO: print line number instead of offset
  // (https://stackoverflow.com/questions/8278691/how-to-fix-backtrace-line-number-error-in-c)

  // record stack trace upto 128 frames
  int callstack[128] = {};
  // collect stack frames
  int frames = backtrace((void **)callstack, 128);
  // get the human-readable symbols (mangled)
  char **strs = backtrace_symbols((void **)callstack, frames);
  std::vector<std::string> stack_frames;
  for (int i = 0; i < frames; i++) {
    char function_symbol[1024] = {};
    char module_name[1024] = {};
    int offset = 0;
    char addr[48] = {};
    // split the string, take out chunks out of stack trace
    // we are primarily interested in module, function and address
    sscanf(strs[i], "%*s %s %s %s %*s %d", module_name, addr, function_symbol,
           &offset);

    int valid_cpp_name = 0;
    //  if this is a C++ library, symbol will be demangled
    //  on success function returns 0
    char *function_name =
        abi::__cxa_demangle(function_symbol, NULL, 0, &valid_cpp_name);

    char stack_frame[4096] = {};
    bool is_valid_cpp_name = (valid_cpp_name == 0);
    sprintf(stack_frame, "* %28s | %7d | %s", module_name, offset,
            function_name);
    if (function_name != nullptr)
      free(function_name);

    std::string frameStr(stack_frame);
    stack_frames.push_back(frameStr);
  }
  free(strs);

  // Pretty print the traceback table
  // Exclude this function itself
  stack_frames.erase(stack_frames.begin());
  std::reverse(stack_frames.begin(), stack_frames.end());
  std::lock_guard<std::mutex> guard(traceback_printer_mutex);
  printf("\n");
  printf(
      "                            * Taichi Core - Stack Traceback *           "
      "                  \n");
  printf(
      "========================================================================"
      "==================\n");
  printf(
      "|                       Module |  Offset | Function                     "
      "                 |\n");
  printf(
      "|-----------------------------------------------------------------------"
      "-----------------|\n");
  for (auto trace : stack_frames) {
    const int function_start = 39;
    const int line_width = 86;
    const int function_width = line_width - function_start - 2;
    int i;
    for (i = 0; i < (int)trace.size(); i++) {
      std::cout << trace[i];
      if (i > function_start + 3 &&
          (i - 3 - function_start) % function_width == 0) {
        std::cout << " |" << std::endl << " ";
        for (int j = 0; j < function_start; j++) {
          std::cout << " ";
        }
        std::cout << " | ";
      }
    }
    for (int j = 0;
         j < function_width + 2 - (i - 3 - function_start) % function_width;
         j++) {
      std::cout << " ";
    }
    std::cout << "|" << std::endl;
  }
  printf(
      "========================================================================"
      "==================\n");
  printf("\n");
#elif defined(_WIN64)
// Windows
#else
  // Based on http://man7.org/linux/man-pages/man3/backtrace.3.html
  constexpr int BT_BUF_SIZE = 1024;
  int nptrs;
  void *buffer[BT_BUF_SIZE];
  char **strings;

  nptrs = backtrace(buffer, BT_BUF_SIZE);

  // std::printf("backtrace() returned %d addresses\n", nptrs);

  /* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)
     would produce similar output to the following: */

  strings = backtrace_symbols(buffer, nptrs);
  if (strings == NULL) {
    perror("backtrace_symbols");
    exit(EXIT_FAILURE);
  }

  fmt::print_colored(fmt::MAGENTA, "***************************\n");
  fmt::print_colored(fmt::MAGENTA, "* Taichi Core Stack Trace *\n");
  fmt::print_colored(fmt::MAGENTA, "***************************\n");

  // j = 0: taichi::print_traceback
  for (int j = 1; j < nptrs; j++) {
    std::string s(strings[j]);
    std::size_t start = s.find("(");
    std::size_t end = s.rfind("+");

    std::string line;

    if (start < end) {
      std::string name = s.substr(start + 1, end - start - 1);

      char *demangled_name_;

      int status = -1;

      demangled_name_ = abi::__cxa_demangle(name.c_str(), NULL, NULL, &status);

      if (demangled_name_) {
        name = std::string(demangled_name_);
      }

      std::string prefix = s.substr(0, start);

      line = fmt::format("{}: {}", prefix, name);
      free(demangled_name_);
    } else {
      line = s;
    }
    fmt::print_colored(fmt::MAGENTA, "{}\n", line);
  }
  std::free(strings);
#endif
}

TC_NAMESPACE_END

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/

#include <numeric>

TC_NAMESPACE_BEGIN

#if defined(TC_PLATFORM_LINUX) || (defined(TC_PLATFORM_OSX) && defined(TC_AMALGAMATED))
#define TC_GUI_X11
#endif

#if defined(TC_GUI_X11)

class Canvas {
 public:
  Array2D<Vector4> &img;
  Matrix3 transform_matrix;

  Canvas(Array2D<Vector4> &img) : img(img) {
    transform_matrix = Matrix3(Vector3(img.get_res().cast<real>(), 1.0_f));
  }

  TC_FORCE_INLINE Vector2 transform(Vector2 x) {
    return Vector2(transform_matrix * Vector3(x, 1.0_f));
  }

  void line(Vector2 start, Vector2 end, Vector4 color) {
    // convert to screen space
    start = transform(start);
    end = transform(end);
    real len = length(end - start);
    int samples = (int)len * 2 + 4;
    for (int i = 0; i < samples; i++) {
      real alpha = (1.0_f / (samples - 1)) * i;
      Vector2i coord = (lerp(alpha, start, end)).floor().cast<int>();
      if (img.inside(coord)) {
        img[coord] = color;
      }
    }
  }

  void triangle(Vector2 a, Vector2 b, Vector2 c, Vector4 color) {
    a = transform(a);
    b = transform(b);
    c = transform(c);

    // real points[3] = {a, b, c};
    // std::sort(points, points + 3, [](const Vector2 &a, const Vector2 &b) {
    //  return a.y < b.y;
    //});
    Vector2 limits[2];
    limits[0].x = min(a.x, min(b.x, c.x));
    limits[0].y = min(a.y, min(b.y, c.y));
    limits[1].x = max(a.x, max(b.x, c.x));
    limits[1].y = max(a.y, max(b.y, c.y));
    for (int i = std::floor(limits[0].x); i < std::ceil(limits[1].x); i++) {
      for (int j = std::floor(limits[0].y); j < std::ceil(limits[1].y); j++) {
        Vector2 pixel(i + 0.5_f, j + 0.5_f);
        bool inside_a = cross(pixel - a, b - a) <= 0;
        bool inside_b = cross(pixel - b, c - b) <= 0;
        bool inside_c = cross(pixel - c, a - c) <= 0;
        if (inside_a && inside_b && inside_c && img.inside(i, j)) {
          img[i][j] = color;
        }
      }
    }
  }

  void text(const std::string &str,
            Vector2 position,
            real size,
            Vector4 color) {
    position = transform(position);
    char *root_dir = std::getenv("TAICHI_REPO_DIR");
    TC_ASSERT(root_dir != nullptr);
    img.write_text(root_dir + std::string("/assets/fonts/go/Go-Bold.ttf"), str,
                   size, position.x, position.y, color);
  }

  void clear(Vector4 color) {
    img.reset(color);
  }

  ~Canvas() {
    TC_INFO("Canvas Dtor");
  }
};

class CXImage;

class GUI {
 public:
  std::string window_name;
  int width, height;
  void *display;
  void *visual;
  unsigned long window;
  std::unique_ptr<CXImage> img;
  int frame_id = 0;
  const int fps = 60;
  float64 start_time;
  Array2D<Vector4> buffer;
  std::vector<real> last_frame_interval;
  std::unique_ptr<Canvas> canvas;
  float64 last_frame_time;
  bool key_pressed;
  std::vector<std::string> log_entries;

  void process_event();

  GUI(const std::string &window_name, int width = 800, int height = 800);

  GUI(const std::string &window_name, Vector2i res)
      : GUI(window_name, res[0], res[1]) {
  }

  Canvas &get_canvas() {
    return *canvas;
  }

  void update();

  void wait_key();

  void draw_log();

  void log(std::string entry) {
    log_entries.push_back(entry);
    if (log_entries.size() > 15) {
      log_entries.erase(log_entries.begin());
    }
  }

  ~GUI();
};

#endif

TC_NAMESPACE_END
#include <numeric>

#if defined(TC_GUI_X11)
#include <X11/Xlib.h>
#include <X11/Xutil.h>

// Undo terrible unprefixed macros in X.h
#ifdef None
#undef None
#endif
#ifdef Success
#undef Success
#endif

TC_NAMESPACE_BEGIN

class CXImage {
 public:
  XImage *image;
  std::vector<uint8> image_data;
  int width, height;
  CXImage(Display *display, Visual *visual, int width, int height)
      : width(width), height(height) {
    image_data.resize(width * height * 4);
    image = XCreateImage(display, visual, 24, ZPixmap, 0,
                         (char *)image_data.data(), width, height, 32, 0);
    TC_ASSERT((void *)image->data == image_data.data());
  }

  void set_data(const Array2D<Vector4> &color) {
    auto p = image_data.data();
    for (int j = 0; j < height; j++) {
      for (int i = 0; i < width; i++) {
        auto c = color[i][height - j - 1];
        *p++ = uint8(clamp(int(c[2] * 255.0_f), 0, 255));
        *p++ = uint8(clamp(int(c[1] * 255.0_f), 0, 255));
        *p++ = uint8(clamp(int(c[0] * 255.0_f), 0, 255));
        *p++ = uint8(clamp(int(c[3] * 255.0_f), 0, 255));
      }
    }
  }

  ~CXImage() {
    delete image;  // image->data is automatically released in image_data
  }
};

void GUI::process_event() {
  while (XPending((Display *)display)) {
    XEvent ev;
    XNextEvent((Display *)display, &ev);
    switch (ev.type) {
      case Expose:
        break;
      case ButtonPress:
        break;
      case KeyPress:
        key_pressed = true;
        break;
    }
  }
}

GUI::GUI(const std::string &window_name, int width, int height)
    : window_name(window_name),
      width(width),
      height(height),
      key_pressed(false) {
  display = XOpenDisplay(nullptr);
  visual = DefaultVisual(display, 0);
  window =
      XCreateSimpleWindow((Display *)display, RootWindow((Display *)display, 0),
                          0, 0, width, height, 1, 0, 0);
  XStoreName((Display *)display, window, window_name.c_str());
  XSelectInput((Display *)display, window,
               ButtonPressMask | ExposureMask | KeyPressMask | KeyReleaseMask);
  XMapWindow((Display *)display, window);
  img = std::make_unique<CXImage>((Display *)display, (Visual *)visual, width,
                                  height);
  start_time = taichi::Time::get_time();
  buffer.initialize(Vector2i(width, height));
  canvas = std::make_unique<Canvas>(buffer);
  last_frame_time = taichi::Time::get_time();
}

void GUI::draw_log() {
  for (int i = 0; i < (int)log_entries.size(); i++) {
    canvas->text(log_entries[i], Vector2(0.0, -0.02 * i), 15, Vector4(0));
  }
}

void GUI::update() {
  img->set_data(buffer);
  frame_id++;
  while (taichi::Time::get_time() < start_time + frame_id / (real)fps) {
  }
  XPutImage((Display *)display, window, DefaultGC(display, 0), img->image, 0, 0,
            0, 0, width, height);
  process_event();
  while (last_frame_interval.size() > 30) {
    last_frame_interval.erase(last_frame_interval.begin());
  }
  auto real_fps = last_frame_interval.size() /
                  (std::accumulate(last_frame_interval.begin(),
                                   last_frame_interval.end(), 0.0_f));
  XStoreName((Display *)display, window,
             fmt::format("{} ({:.02f} FPS)", window_name, real_fps).c_str());
  if (last_frame_time != 0) {
    last_frame_interval.push_back(taichi::Time::get_time() - last_frame_time);
  }
  last_frame_time = taichi::Time::get_time();
}

void GUI::wait_key() {
  while (true) {
    key_pressed = false;
    update();
    if (key_pressed) {
      break;
    }
  }
}

GUI::~GUI() {
}

TC_NAMESPACE_END
#endif
/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/

/*******************************************************************************
    Copyright (c) The Taichi Authors (2016- ). All Rights Reserved.
    The use of this software is governed by the LICENSE file.
*******************************************************************************/


#include <memory>

TC_NAMESPACE_BEGIN

template <typename T>
class ImageAccumulator {
 public:
  std::vector<Spinlock> locks;

  ImageAccumulator() {
  }

  ImageAccumulator(Vector2i res) : buffer(res), counter(res), res(res) {
    for (int i = 0; i < res[0] * res[1]; i++) {
      locks.push_back(Spinlock());
    }
  }

  Array2D<T> get_averaged(T default_value = T(0)) {
    Array2D<T> result(res);
    for (int i = 0; i < res[0]; i++) {
      for (int j = 0; j < res[1]; j++) {
        if (counter[i][j] > 0) {
          real inv = (real)1 / counter[i][j];
          result[i][j] = inv * buffer[i][j];
        } else {
          result[i][j] = default_value;
        }
      }
    }
    return result;
  }

  void accumulate(int x, int y, T val) {
    int lock_id = x * res[1] + y;
    locks[lock_id].lock();
    counter[x][y]++;
    buffer[x][y] += val;
    locks[lock_id].unlock();
  }

  void accumulate(ImageAccumulator<T> &other) {
    for (int i = 0; i < res[0]; i++) {
      for (int j = 0; j < res[1]; j++) {
        counter[i][j] += other.counter[i][j];
        buffer[i][j] += other.buffer[i][j];
      }
    }
  }

  int get_width() const {
    return res[0];
  }

  int get_height() const {
    return res[1];
  }

 private:
  Array2D<T> buffer;
  Array2D<int> counter;
  Vector2i res;
};

TC_NAMESPACE_END


TC_NAMESPACE_BEGIN

template <typename T>
void Array2D<T>::load_image(const std::string &filename, bool linearize) {
}

template <typename T>
void Array2D<T>::write_as_image(const std::string &filename) {
}

template <typename T>
void Array2D<T>::write_text(const std::string &font_fn,
                            const std::string &content_,
                            real size,
                            int dx,
                            int dy,
                            T color) {
}


void write_pgm(Array2D<real> img, const std::string &fn) {
  std::ofstream fs(fn, std::ios_base::binary);
  Vector2i res = img.get_res();
  fs << fmt::format("P5\n{} {}\n{}\n", res[0], res[1], 255);
  for (int j = 0; j < res[1]; j++) {
    std::string line;
    for (int i = 0; i < res[0]; i++) {
      uint8_t v = clamp((int)(img[i][res[1] - j - 1] * 255), 0, 255);
      line.push_back(v);
    }
    fs.write(line.c_str(), line.size());
  }
}

TC_NAMESPACE_END
